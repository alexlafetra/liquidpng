import c from "../BaseFormFieldCreator/BaseFormFieldCreator.vue.es.js";
import p from "../../mixins/i18n.es.js";
import "./BaseForm.vue.es2.js";
import "./BaseForm.vue.es3.js";
import h from "../../_virtual/_plugin-vue2_normalizer.es.js";
const _ = [
  "errorMessage",
  "invalid",
  "isActive",
  "isLoading",
  "linkedListOption",
  "activeTab",
  "validationTexts"
], y = {
  name: "BaseForm",
  components: {
    BaseButton: () => import("../BaseButton/BaseButton.vue.es.js").then((e) => e.default || e),
    BaseIcon: () => import("../BaseIcon/BaseIcon.vue.es.js").then((e) => e.default || e),
    BaseFormFieldCreator: c
  },
  mixins: [p],
  props: {
    /**
     * the json object containing all the field information incl. `x-attrs` custom field
     * for placeholder, field type, etc. (for further documentation and configuration options see
     * further down below [slots](BaseForm.html#slots))
     */
    formFieldJson: {
      type: Object,
      required: !0
    },
    /**
     * the values for each field if any already present
     */
    valueList: {
      type: Object,
      default: () => ({})
    },
    /**
     * set current language
     */
    language: {
      type: String,
      default: "en"
    },
    /**
     * provide information about all available languages
     */
    availableLocales: {
      type: Array,
      default: () => []
    },
    /**
     * an id for field groups to still have unique field ids
     */
    formId: {
      type: String,
      default: ""
    },
    /**
     * define additional style for the form
     * should be an object e.g. `{ 'padding-top': 0 }`
     */
    formStyle: {
      type: Object,
      default: () => ({})
    },
    /**
     * define fields (specify field name!) for which tabs should be shown
     */
    fieldsWithTabs: {
      type: Array,
      default: () => []
    },
    /**
     * enter the field name of a field that is currently fetching autocomplete
     * results
     */
    fieldIsLoading: {
      type: String,
      default: ""
    },
    /**
     * provide an object that contains the options list for all
     * fields with autocomplete / chips input
     * for field type `group` provide a nested object with field names
     * as properties and an array for each field to ensure the correct options are assigned
     * even if field names within different groups are identical
     */
    dropDownLists: {
      type: Object,
      default: () => ({})
    },
    /**
     * define if error icon should be shown.
     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)
     */
    showErrorIcon: {
      type: Boolean,
      default: !1
    },
    /**
     * if `true` a remove icon will be shown allowing to remove
     * all input at once.
     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)
     */
    clearable: {
      type: Boolean,
      default: !1
    },
    /**
     * provide an object with settings and properties for each field. This takes an object
     * with the field name as properties with the props nested.
     * `{ [fieldName1]: { required: false, ... }, [fieldName2]: { ... } }`
     *
     * find the possible variables at the respective input components:
     * [BaseInput](BaseInput)
     * [BaseAutocompleteInput](BaseAutocompleteInput)
     * [BaseMultilineTextInput](BaseMultilineTextInput)
     * [BaseChipsInput](BaseChipsInput)
     * [BaseChipsBelow](BaseChipsBelow)
     * [BaseDateInput](BaseDateInput)
     * [BaseToggle](BaseToggle)
     *
     * **special case repeatable fields**: the following field props can be set individually
     * per repeated field:
     *  `errorMessage`, `invalid`, `isActive`, `isLoading`,
     *  `linkedListOption`, `activeTab`
     *  the field property value should be set as object specifying the field index as key:
     *  `{ [fieldIndex]: [value to be set] }` (e.g. `{ required: { 0: false }}`)
     */
    fieldProps: {
      type: Object,
      default: () => ({}),
      validator: (e) => Object.keys(e).length === 0 || Object.values(e).every((t) => Object.keys(t))
    },
    /**
     * in case the field `form_group_title` was added to the `x-attrs` field, this is
     * is rendered as a header above the form and here the HTML tag may be defined.
     */
    renderHeaderAs: {
      type: String,
      default: "div"
    },
    /**
     * define validation texts to be displayed below form field if input is invalid.
     * for an example see [BaseInput](BaseInput)
     */
    validationTexts: {
      type: Object,
      default: () => ({
        text: {
          min: "Value must be greater than or equal to {value}.",
          max: "Value must be less than or equal to {value}.",
          minLength: "Text must be at least {value} character(s) long.",
          maxLength: "Text cannot be longer than {value} characters."
        },
        chips: {
          required: "Select an option."
        }
      }),
      // checking if all necessary properties are part of the provided object
      validator: (e) => ["text"].every((t) => Object.keys(e).includes(t)) && ["min", "max", "minLength", "maxLength"].every((t) => Object.keys(e.text).includes(t))
    },
    /**
     * specify the object property that should be used as identifier.
     * used for chips input as well as dropdowns.
     */
    identifierPropertyName: {
      type: String,
      default: "source"
    },
    /**
     * specify the object property that should be used as value to be displayed.
     * used for chips input as well as dropdowns.
     */
    labelPropertyName: {
      type: String,
      default: "label"
    },
    /**
     * this prop gives the option to add assistive text for screen readers
     * properties:
     *
     * Options for inputs type `autocomplete`, `chips`, `chips-below`:
     * **loaderActive**: text that is announced when options are being fetched (prop
     *  `isLoading` is set `true`)
     *
     * Options for inputs type `chips`:
     * **optionToRemoveSelected**: text read when option is marked active for removal (by using
     *  backspace in empty input field). string {label} could be added to be replaced
     *  by the actual chip label (value in [`labelPropertyName`])
     *
     * Options for inputs type `chips`, `chips-below`:
     * **resultsRetrieved**: text that is announced when results were retrieved (drop down
     *  list changed)
     * **optionAdded**: text read when option was added to the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     * **optionRemoved**: text read when option was removed from the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     */
    assistiveText: {
      type: Object,
      default: () => ({
        loaderActive: "loading.",
        resultsRetrieved: "{number} options in drop down.",
        optionAdded: "option {label} added to selected list.",
        optionToRemoveSelected: "option {label} from selected list marked for removal. Press delete or backspace to remove.",
        optionRemoved: "option {label} removed."
      })
    }
  },
  data() {
    return {
      /**
       * variable to be able to focus to the field after multiply
       * @type {?Object}
       * @property {number} index - the index of the new field in the array
       * @property {string} name - the name of the field
       */
      multiplyParams: null,
      /**
       * remember the field for which autocomplete is fetching
       * @type {string}
       */
      fetchingAutocompleteFor: "",
      /**
       * internal representation of valueList (containing values for all input fields)
       * @type {Object}
       * @property {?string|?Array|?Object} [the name of the input field]
       */
      valueListInt: {}
    };
  },
  computed: {
    /**
     * the form fields provided in the prop `formFieldJson` as filtered (remove unneeded and hidden fields)
     * and sorted list with the field key added to the object as `name` property.
     * @returns {(*&{name: *})[]}
     */
    cleanedAndSortedFormFieldList() {
      return Object.entries(this.formFieldJson).filter(([, e]) => {
        var t;
        return !e.$ref && !((t = e["x-attrs"]) != null && t.hidden);
      }).map(([e, t]) => ({ name: e, ...t })).sort((e, t) => {
        var i, a;
        return ((i = e["x-attrs"]) == null ? void 0 : i.order) > ((a = t["x-attrs"]) == null ? void 0 : a.order) ? 1 : -1;
      });
    },
    /**
     * internal form field list, sorted and with additional name property to save
     * the name of the input field in a variable, also filtered from fields that
     * should not be shown
     *
     * @returns {Object}
     * @property {string} name - the name of the input field
     * @property {*} [*] all other properties contained in the swagger
     */
    formFieldListInt() {
      return this.cleanedAndSortedFormFieldList.reduce((e, t) => {
        var u, s;
        const { field_format: i, order: a, field_type: l } = t["x-attrs"], n = e.length - 1;
        return i && l !== "group" && ["half", "third"].includes(i) && e[n] && ((u = e[n]) == null ? void 0 : u.type) === i && (i === "half" && e[n].data.length < 2 || i === "third" && e[n].data.length < 3) && e[n].data.at(-1)["x-attrs"].order + 1 >= a ? e[n].data.push(t) : e.push({
          // field type group should always be full
          type: i && ((s = t["x-attrs"]) == null ? void 0 : s.field_type) !== "group" ? i : "full",
          data: [t]
        }), e;
      }, []);
    },
    /**
     * get the title string for the form header if one was set in the OpenAPI definition
     * @returns {string}
     */
    formHeader() {
      const e = this.cleanedAndSortedFormFieldList.find((t) => t["x-attrs"] && t["x-attrs"].form_group_title);
      return e ? e["x-attrs"].form_group_title : "";
    }
  },
  watch: {
    /**
     * watch the prop to see if it has changed from outside
     */
    valueList: {
      handler(e) {
        Object.keys(this.valueListInt).some((i) => JSON.stringify(this.valueListInt[i]) !== JSON.stringify(e[i])) && this.initializeValueObject();
      },
      deep: !0
    },
    /**
     * if the form fields definition was changed from outside - reinitialize the internal value list
     */
    formFieldJson: {
      handler() {
        this.valueListInt = {}, this.initializeValueObject();
      },
      immediate: !0
    }
  },
  updated() {
    if (this.multiplyParams && this.multiplyParams.name) {
      const e = this.$refs[this.multiplyParams.name];
      e.length && setTimeout((t) => {
        const i = e[t.index].getElementsByTagName("textarea").length ? e[t.index].getElementsByTagName("textarea") : e[t.index].getElementsByTagName("input");
        i.length && i[0].focus();
      }, 50, this.multiplyParams), this.multiplyParams = null;
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.$emit("form-mounted");
    });
  },
  methods: {
    /** FORM INPUT HANDLING */
    fetchAutocomplete(e) {
      this.fetchingAutocompleteFor = e.name, this.$emit("fetch-autocomplete", e);
    },
    /**
     * function triggered when an input field input was completed (e.g. an option selected in chips input or
     *  an enter key triggered in BaseInput or after a date was validated)
     *
     * @param {string|number|Object|Array} value - the updated value
     * @param {string} fieldName - the name of the field in question
     * @param {number} index - if field is repeatable - the index in the valueList array
     */
    onInputComplete(e, t, i = -1) {
      this.setFieldValue(e, t, i), this.$emit("input-complete", this.valueListInt);
    },
    /**
     * triggered if value in form field changed
     * @param {*} value - the altered field value
     * @param {string} fieldName - the property name of the altered field
     * @param {number} index - the field index if field is repeatable
     */
    setFieldValue(e, t, i = -1) {
      i >= 0 ? this.$set(this.valueListInt[t], i, JSON.parse(JSON.stringify(e))) : this.$set(this.valueListInt, t, e && JSON.parse(JSON.stringify(e))), this.propagateValueListChanges();
    },
    /**
     * emit the value list changes (only triggered by repeatable field manipulation)
     */
    propagateValueListChanges() {
      this.$emit("values-changed", this.valueListInt);
    },
    /** FIELD VALUE INITIALIZATION */
    /**
     * go through all fields relevant for display and assign an appropriate value
     */
    initializeValueObject() {
      this.cleanedAndSortedFormFieldList.forEach((e) => {
        this.$set(
          this.valueListInt,
          e.name,
          this.getInitialFieldValue(e)
        );
      });
    },
    /**
     * function to determine the appropriate value for a field
     * @param {Object} field - the openAPI definition of the field
     * @returns {{[p: string]: *}|*|boolean|string|string|*[]}
     */
    getInitialFieldValue({ name: e, "x-attrs": t, type: i, items: a, properties: l }) {
      const n = this.valueList[e], u = t == null ? void 0 : t.field_type;
      if (["number", "integer"].includes(i))
        return n || "";
      if (u && u.includes("chips") && i === "object")
        return n && Object.keys(n).length ? [].concat(n) : [];
      if (i === "array")
        return typeof n == "object" && n && n.length ? [].concat(n) : !t || !u || u && !u.includes("chips") ? [].concat(this.getInitialFieldValue(a)) : [];
      if (i === "object") {
        const s = {};
        return Object.keys(l).forEach((r) => {
          this.$set(s, r, this.getInitialFieldValue(l[r]));
        }), { ...s, ...n };
      }
      return i === "boolean" ? n || !1 : typeof n == "string" ? n : "";
    },
    /** REPEATABLE FIELDS */
    /**
     * triggered on user clicking multiply button
     * @param {Object} field - the openAPI information of the form field
     * @param {number} index - the index of the field where the multiply button was pressed
     */
    multiplyField(e, t) {
      const i = this.getInitialFieldValue(e.items);
      !t && t !== 0 ? this.valueListInt[e.name].push(i) : this.valueListInt[e.name].splice(t + 1, 0, i), this.multiplyParams = {
        index: !t && t !== 0 ? this.valueListInt[e.name].length - 1 : t + 1,
        name: e.name
      }, this.propagateValueListChanges();
    },
    /**
     * remove multiplied field again
     * @param {Object} field - the openAPI information of the form field
     * @param {number} index - the index of the field where the remove button was pressed
     */
    removeField(e, t) {
      const i = this.valueListInt[e.name];
      i && i.length > 1 ? i.splice(t, 1) : this.$set(i, t, this.getInitialFieldValue(e.items)), this.propagateValueListChanges(), this.$emit("input-complete", this.valueListInt);
    },
    /** VALIDATION */
    /**
     * Trigger public validate function for each form component
     * Note: Currently a validation function is only implemented for baseChipsBelow
     *
     * @public
     * @returns {boolean} - forms error state
     */
    validate() {
      const e = [];
      return this.$refs.baseFormField.forEach((i) => {
        if (Object.keys(i.$refs).length) {
          const a = Object.keys(i.$refs)[0];
          if (i.$refs[a].validate !== void 0) {
            const l = i.$refs[a].validate();
            l && e.push(l);
          }
        }
      }), !!e.length;
    },
    /** HELPER FUNCTIONS FOR INDIVIDUAL FIELDS */
    /**
     * get all the component properties per field that are necessary for the BaseFormFieldCreator
     *  component
     * @param {Object} element - the openAPI field definition information
     * @param {number} index - element row index
     * @param {number} groupIndex - index of element within a row
     * @param {number?} [valueIndex=1] - index of element if field is repeatable
     * @returns {{fieldGroupParams: ({readonly labelPropertyName: string, readonly identifierPropertyName: string, readonly validationTexts: Object, readonly renderHeaderAs: string, readonly fieldProps: Object, readonly clearable: boolean, readonly showErrorIcon: boolean, readonly dropDownLists: Object, readonly fieldIsLoading: string, readonly fieldsWithTabs: *[], readonly formStyle: Object, readonly formId: string, readonly availableLocales: *[], readonly language: string, readonly valueList: Object, readonly formFieldJson: Object}|null), showErrorIcon: boolean, labelPropertyName: string, clearable: boolean, validationTexts: (*|Object), dropDownList: *, fieldKey: string, autocompleteLoading: boolean, sortText: (string|string), language: string, label: (*|string), fieldValue: *, showLabel: boolean, identifierPropertyName: string, availableLocales: *[], field, secondaryDropdown: *, fieldProps: (any|{})}}
     */
    formFieldComponentProps(e, t, i, a = -1) {
      const { name: l } = e;
      let n = this.fieldProps[l] ? JSON.parse(JSON.stringify(this.fieldProps[l])) : {};
      const u = a >= 0;
      if (u) {
        const r = Object.entries(n).filter(([o]) => _.includes(o));
        if (r.length) {
          const o = r.reduce((m, [f, d]) => Object.keys(d).includes(a.toString()) ? {
            ...m,
            [f]: d[a.toString()]
          } : (delete n[f], m), {});
          n = {
            ...n,
            ...o
          };
        }
      }
      const s = u ? `${t}_${i}_${a}` : `${t}_${i}`;
      return {
        field: e,
        label: n && n.label ? n.label : this.getFieldName(e),
        fieldProps: n,
        showLabel: !this.allowMultiply(e) || !this.multiplyButtonsInline(e) || a === 0,
        dropDownList: this.dropDownLists[l],
        secondaryDropdown: this.dropDownLists[`${l}_secondary`],
        language: this.language,
        availableLocales: this.availableLocales,
        sortText: this.getI18nTerm("form.sort") || "Sort",
        fieldKey: `${l}_${s}_${this.formId}`,
        fieldValue: u ? this.valueListInt[l][a] : this.valueListInt[l],
        autocompleteLoading: this.fieldIsLoading === l,
        // add component props to form fields creator props if list contains a field_type 'group'
        fieldGroupParams: this.cleanedAndSortedFormFieldList.some((r) => r["x-attrs"] && r["x-attrs"].field_type === "group") ? this.$props : null,
        clearable: this.clearable,
        showErrorIcon: this.showErrorIcon,
        validationTexts: n.validationTexts || this.validationTexts,
        identifierPropertyName: this.identifierPropertyName,
        labelPropertyName: this.labelPropertyName,
        assistiveText: n.assistiveText || this.assistiveText
      };
    },
    /**
     * check if field can be multiplied
     * @param {Object} el - the openAPI field definition information
     * @returns {boolean}
     */
    allowMultiply(e) {
      return e.type === "array" && (!e["x-attrs"] || !e["x-attrs"].field_type || e["x-attrs"] && !["chips", "chips-below"].includes(e["x-attrs"].field_type));
    },
    /**
     * check if field should display multiply buttons inline (all but 'group' and 'multiline')
     * @param {Object} el - the openAPI field definition information
     * @returns {boolean}
     */
    multiplyButtonsInline(e) {
      return !["group", "multiline"].includes(e["x-attrs"].field_type);
    },
    /**
     * check if field is a date field with switch buttons above - this means it needs
     *  more margin on top
     * @param {Object} fieldXAttrs - the openAPI field information 'x-attrs'
     * @returns {boolean}
     */
    fieldIsDateSwitch(e) {
      var t, i;
      return ((t = e == null ? void 0 : e.field_type) == null ? void 0 : t.includes("date")) && ((i = e == null ? void 0 : e.date_format) == null ? void 0 : i.includes("_"));
    },
    /**
     * get a field name to display
     * @param {Object} el - the openAPI field definition information
     * @returns {string}
     */
    getFieldName(e) {
      return e.title || this.getI18nTerm(`form.${e.name}` || e.name);
    },
    /**
     * determine if field has content to see if multiply buttons should be shown
     * @param {string} fieldName - the field key / property name
     * @param {number} index - index in the repeated field
     * @returns {boolean}
     */
    checkFieldContent(e, t = -1) {
      return this.hasValues(t < 0 ? this.valueListInt[e][t] : this.valueListInt[e]);
    },
    /**
     * loop through all field values depending on the type of value
     * @param {*} fieldValues - the values assigned to a form field
     * @returns {boolean}
     */
    hasValues(e) {
      let t = !1;
      return e && typeof e == "object" ? e.length >= 0 ? e.forEach((i) => {
        t = this.hasValues(i) || t;
      }) : Object.keys(e).forEach((a) => {
        t = this.hasValues(e[a]) || t;
      }) : t = e === 0 || !!e || t, t;
    }
  }
};
var g = function() {
  var t = this, i = t._self._c;
  return i("div", { staticClass: "base-form", style: t.formStyle }, [t.formHeader ? i(t.renderHeaderAs, { tag: "component", staticClass: "base-form__header" }, [t._v(" " + t._s(t.formHeader) + " ")]) : t._e(), i("div", { staticClass: "base-form__body" }, t._l(t.formFieldListInt, function(a, l) {
    return i("div", { key: `form-row-${t.formId}-${l}`, class: ["base-form__form-row", `base-form__form-row--${a.type}`] }, [t._l(a.data, function(n, u) {
      return [t.allowMultiply(n) ? t.allowMultiply(n) ? i("div", { key: `${n.name}_${u}_${t.formId}_wrapper`, class: [
        "base-form__input-field",
        `base-form__input-field--${a.type}`,
        { "base-form__input-field--date-switch-spacing": t.fieldIsDateSwitch(n["x-attrs"]) }
      ] }, t._l(t.valueListInt[n.name], function(s, r) {
        return i("div", { key: `${n.name}_${u}_${r}_${t.formId}_wrapper`, ref: n.name, refInFor: !0, class: [{ "base-form__repeatable-field": t.multiplyButtonsInline(n) }] }, [i("BaseFormFieldCreator", t._b({ key: `${n.name}_${u}_${r}_${t.formId}`, ref: "baseFormField", refInFor: !0, class: [
          "base-form__input-component",
          { "base-form__input-component--margin-bottom": !t.multiplyButtonsInline(n) }
        ], on: { "field-value-changed": function(o) {
          return t.setFieldValue(
            o,
            n.name,
            r
          );
        }, "fetch-autocomplete": t.fetchAutocomplete, "input-complete": function(o) {
          return t.onInputComplete(
            o,
            n.name,
            r
          );
        } }, scopedSlots: t._u([{ key: "label-addition", fn: function({ fieldName: o, groupNames: m }) {
          return [t._t("label-addition", null, { fieldName: o, groupNames: m, index: r })];
        } }, { key: "pre-input-field", fn: function({ fieldName: o, groupNames: m }) {
          return [t._t("pre-input-field", null, { fieldName: o, groupNames: m, index: r })];
        } }, { key: "input-field-addition-before", fn: function({ fieldName: o, groupNames: m }) {
          return [t._t("input-field-addition-before", null, { fieldName: o, groupNames: m, index: r })];
        } }, { key: "input-field-inline-before", fn: function({ fieldName: o, groupNames: m }) {
          return [a["x-attrs"] && a["x-attrs"].text_before ? i("span", { staticClass: "base-form__input-field__text-before" }, [t._v(" " + t._s(a["x-attrs"].text_before) + " ")]) : t._e(), t._t("input-field-inline-before", null, { fieldName: o, groupNames: m, index: r })];
        } }, { key: "input-field-addition-after", fn: function({ fieldName: o, groupNames: m }) {
          return [a["x-attrs"] && a["x-attrs"].text_after ? i("span", { staticClass: "base-form__input-field__text-after" }, [t._v(" " + t._s(a["x-attrs"].text_after) + " ")]) : t._e(), t._t("input-field-addition-after", null, { fieldName: o, groupNames: m, index: r })];
        } }, { key: "post-input-field", fn: function({ fieldName: o, groupNames: m }) {
          return [t._t("post-input-field", null, { fieldName: o, groupNames: m, index: r })];
        } }, { key: "error-icon", fn: function() {
          return [t._t("error-icon")];
        }, proxy: !0 }, { key: "remove-icon", fn: function() {
          return [t._t("remove-icon")];
        }, proxy: !0 }, { key: "below-input", fn: function({ fieldName: o, groupNames: m }) {
          return [t._t("below-input", null, { fieldName: o, groupNames: m, index: r })];
        } }, { key: "drop-down-entry", fn: function({ option: o, fieldName: m, groupNames: f }) {
          return [t._t("drop-down-entry", null, { fieldName: m, groupNames: f, option: o })];
        } }], null, !0) }, "BaseFormFieldCreator", t.formFieldComponentProps(n, u, l, r), !1)), t.multiplyButtonsInline(n) ? [i("div", { ref: "multiplyButtons", refInFor: !0, staticClass: "base-form__inline-buttons" }, [t.valueListInt[n.name].length > 1 || t.checkFieldContent(n.name, 0) ? i("BaseButton", { staticClass: "base-form__inline-button", attrs: { "icon-title": t.valueListInt[n.name].length === 1 ? t.getI18nTerm("form.clearField") || "Clear" : t.getI18nTerm("form.removeField", -1, { fieldType: t.getFieldName(a) }), "has-background-color": !1, text: "", "button-style": "single", icon: "remove", "icon-size": "large" }, on: { clicked: function(o) {
          return t.removeField(n, r);
        } } }) : t._e(), i("BaseButton", { staticClass: "base-form__inline-button", attrs: { "icon-title": r !== t.valueListInt[n.name].length - 1 ? t.getI18nTerm("form.addGroupBelow", -1, {
          fieldType: t.getFieldName(n)
        }) : t.getI18nTerm("form.addGroup", -1, {
          fieldType: t.getFieldName(n)
        }), "has-background-color": !1, text: "", "button-style": "single", icon: "plus", "icon-size": "large" }, on: { clicked: function(o) {
          return t.multiplyField(n, r);
        } } })], 1)] : t._e(), i("div", { staticClass: "base-form__multiply-buttons" }, [!t.multiplyButtonsInline(n) && (t.valueListInt[n.name].length > 1 || t.checkFieldContent(n.name, 0)) ? i("BaseButton", { class: ["base-form__multiply-button", "base-form__multiply-button--remove"], attrs: { text: t.valueListInt[n.name].length === 1 ? t.getI18nTerm("form.clearField") || "Clear" : t.getI18nTerm("form.removeField", -1, { fieldType: t.getFieldName(n) }), "has-background-color": !1, "icon-position": "right", icon: "remove" }, on: { clicked: function(o) {
          return t.removeField(n, r);
        } } }) : t._e(), t.multiplyButtonsInline(n) ? t._e() : i("BaseButton", { staticClass: "base-form__multiply-button", attrs: { text: t.getI18nTerm("form.addGroup", -1, {
          fieldType: t.getFieldName(n)
        }), "has-background-color": !1, "icon-position": "right", icon: "plus" }, on: { clicked: function(o) {
          return t.multiplyField(n, r);
        } } })], 1)], 2);
      }), 0) : t._e() : i("BaseFormFieldCreator", t._b({ key: `${n.name}_${l}_${u}_${t.formId}`, ref: "baseFormField", refInFor: !0, class: [
        "base-form__input-field",
        `base-form__input-field--${a.type}`,
        { "base-form__input-field--top-margin": n.type === "boolean" },
        { "base-form__input-field--date-switch-spacing": t.fieldIsDateSwitch(n["x-attrs"]) }
      ], on: { "field-value-changed": function(s) {
        return t.setFieldValue(s, n.name);
      }, "fetch-autocomplete": t.fetchAutocomplete, "input-complete": function(s) {
        return t.onInputComplete(s, n.name);
      } }, scopedSlots: t._u([{ key: "label-addition", fn: function({ fieldName: s, groupNames: r }) {
        return [t._t("label-addition", null, { fieldName: s, groupNames: r })];
      } }, { key: "pre-input-field", fn: function({ fieldName: s, groupNames: r }) {
        return [t._t("pre-input-field", null, { fieldName: s, groupNames: r })];
      } }, { key: "input-field-addition-before", fn: function({ fieldName: s, groupNames: r }) {
        return [t._t("input-field-addition-before", null, { fieldName: s, groupNames: r })];
      } }, { key: "input-field-inline-before", fn: function({ fieldName: s, groupNames: r }) {
        return [t._t("input-field-inline-before", null, { fieldName: s, groupNames: r }), a["x-attrs"] && a["x-attrs"].text_before ? i("span", { staticClass: "base-form__input-field__text-before" }, [t._v(" " + t._s(a["x-attrs"].text_before) + " ")]) : t._e()];
      } }, { key: "input-field-addition-after", fn: function({ fieldName: s, groupNames: r }) {
        return [a["x-attrs"] && a["x-attrs"].text_after ? i("span", { staticClass: "base-form__input-field__text-after" }, [t._v(" " + t._s(a["x-attrs"].text_after) + " ")]) : t._e(), t._t("input-field-addition-after", null, { fieldName: s, groupNames: r })];
      } }, { key: "post-input-field", fn: function({ fieldName: s, groupNames: r }) {
        return [t._t("post-input-field", null, { fieldName: s, groupNames: r })];
      } }, { key: "error-icon", fn: function() {
        return [t._t("error-icon")];
      }, proxy: !0 }, { key: "remove-icon", fn: function() {
        return [t._t("remove-icon")];
      }, proxy: !0 }, { key: "below-input", fn: function({ fieldName: s, groupNames: r }) {
        return [t._t("below-input", null, { fieldName: s, groupNames: r })];
      } }, { key: "drop-down-entry", fn: function({ option: s, fieldName: r, groupNames: o }) {
        return [t._t("drop-down-entry", null, { fieldName: r, groupNames: o, option: s })];
      } }], null, !0) }, "BaseFormFieldCreator", t.formFieldComponentProps(n, u, l), !1))];
    })], 2);
  }), 0)], 1);
}, b = [], F = /* @__PURE__ */ h(
  y,
  g,
  b,
  !1,
  null,
  "3d6211f9",
  null,
  null
);
const k = F.exports;
export {
  k as default
};
//# sourceMappingURL=BaseForm.vue.es.js.map
