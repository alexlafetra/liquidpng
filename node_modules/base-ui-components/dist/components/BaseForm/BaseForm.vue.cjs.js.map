{"version":3,"file":"BaseForm.vue.cjs.js","sources":["../../../src/components/BaseForm/BaseForm.vue"],"sourcesContent":["<template>\n  <div\n    class=\"base-form\"\n    :style=\"formStyle\">\n    <!-- OPTIONAL HEADER -->\n    <component\n      :is=\"renderHeaderAs\"\n      v-if=\"formHeader\"\n      class=\"base-form__header\">\n      {{ formHeader }}\n    </component>\n    <!-- FORM -->\n    <div\n      class=\"base-form__body\">\n      <!-- A FORM ROW -->\n      <div\n        v-for=\"(element, rowIndex) in formFieldListInt\"\n        :key=\"`form-row-${formId}-${rowIndex}`\"\n        :class=\"['base-form__form-row', `base-form__form-row--${element.type}`]\">\n        <!-- A SINGLE PROPERTY IN THE FORM FIELDS DEFINITION -->\n        <template v-for=\"(field, index) in element.data\">\n          <!-- FOR A SINGLE FORM FIELD - RENDER BASEFORMFIELDCREATOR COMPONENT -->\n          <BaseFormFieldCreator\n            v-if=\"!allowMultiply(field)\"\n            ref=\"baseFormField\"\n            :key=\"`${field.name}_${rowIndex}_${index}_${formId}`\"\n            v-bind=\"formFieldComponentProps(field, index, rowIndex)\"\n            :class=\"[\n              'base-form__input-field',\n              `base-form__input-field--${element.type}`,\n              { 'base-form__input-field--top-margin': field.type === 'boolean' },\n              { 'base-form__input-field--date-switch-spacing': fieldIsDateSwitch(field['x-attrs'])},\n            ]\"\n            @field-value-changed=\"setFieldValue($event, field.name)\"\n            @fetch-autocomplete=\"fetchAutocomplete\"\n            @input-complete=\"onInputComplete($event, field.name)\">\n            <template #label-addition=\"{ fieldName, groupNames }\">\n              <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                name=\"label-addition\"\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\" />\n            </template>\n            <template #pre-input-field=\"{ fieldName, groupNames }\">\n              <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                name=\"pre-input-field\"\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\" />\n            </template>\n            <template\n              #input-field-addition-before=\"{ fieldName, groupNames }\">\n              <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                name=\"input-field-addition-before\"\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\" />\n            </template>\n            <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n              <!-- @slot to add elements directly inline before the input (contrary to `input-field-addition-before` this does not wrap. for an example see [BaseInput](BaseInput)\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                name=\"input-field-inline-before\"\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\" />\n              <span\n                v-if=\"element['x-attrs'] && element['x-attrs'].text_before\"\n                class=\"base-form__input-field__text-before\">\n                {{ element['x-attrs'].text_before }}\n              </span>\n            </template>\n            <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n              <span\n                v-if=\"element['x-attrs'] && element['x-attrs'].text_after\"\n                class=\"base-form__input-field__text-after\">\n                {{ element['x-attrs'].text_after }}\n              </span>\n              <!-- @slot for adding elements after input\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                name=\"input-field-addition-after\"\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\" />\n            </template>\n            <template #post-input-field=\"{ fieldName, groupNames }\">\n              <!-- @slot for adding elements at the end covering the whole height\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                name=\"post-input-field\"\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\" />\n            </template>\n            <template #error-icon>\n              <!-- @slot use a custom icon instead of standard error/warning icon -->\n              <slot name=\"error-icon\" />\n            </template>\n            <template #remove-icon>\n              <!-- @slot use a custom icon instead of standard remove icon -->\n              <slot name=\"remove-icon\" />\n            </template>\n            <template #below-input=\"{ fieldName, groupNames }\">\n              <!-- @slot below-input slot added to e.g. add drop down\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                name=\"below-input\"\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\" />\n            </template>\n            <template #drop-down-entry=\"{ option, fieldName, groupNames }\">\n              <!-- @slot customize the form field drop down options\n                @binding {object} option - the option object\n                @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n              <slot\n                :field-name=\"fieldName\"\n                :group-names=\"groupNames\"\n                :option=\"option\"\n                name=\"drop-down-entry\" />\n            </template>\n          </BaseFormFieldCreator>\n\n          <!-- FOR REPEATABLE FIELDS - ALLOW FOR MULTIPLE VALUES PER FIELD -->\n          <div\n            v-else-if=\"allowMultiply(field)\"\n            :key=\"`${field.name}_${index}_${formId}_wrapper`\"\n            :class=\"['base-form__input-field',\n                     `base-form__input-field--${element.type}`,\n                     { 'base-form__input-field--date-switch-spacing': fieldIsDateSwitch(field['x-attrs'])}]\">\n            <!-- wrapper around form field group and remove button -->\n            <div\n              v-for=\"(value, valueIndex) in valueListInt[field.name]\"\n              :ref=\"field.name\"\n              :key=\"`${field.name}_${index}_${valueIndex}_${formId}_wrapper`\"\n              :class=\"[{ 'base-form__repeatable-field': multiplyButtonsInline(field) }]\">\n              <BaseFormFieldCreator\n                :key=\"`${field.name}_${index}_${valueIndex}_${formId}`\"\n                ref=\"baseFormField\"\n                v-bind=\"formFieldComponentProps(field, index, rowIndex, valueIndex)\"\n                :class=\"['base-form__input-component',\n                         { 'base-form__input-component--margin-bottom': !multiplyButtonsInline(field) }]\"\n                @field-value-changed=\"setFieldValue(\n                  $event,\n                  field.name,\n                  valueIndex)\"\n                @fetch-autocomplete=\"fetchAutocomplete\"\n                @input-complete=\"onInputComplete(\n                  $event,\n                  field.name,\n                  valueIndex)\">\n                <template #label-addition=\"{ fieldName, groupNames }\">\n                  <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n                    @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                    @binding {number} index - the array index of field values\n                    @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    name=\"label-addition\"\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :index=\"valueIndex\" />\n                </template>\n                <template #pre-input-field=\"{ fieldName, groupNames }\">\n                  <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n                  @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                  @binding {number} index - the array index of field values\n                  @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    name=\"pre-input-field\"\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :index=\"valueIndex\" />\n                </template>\n                <template\n                  #input-field-addition-before=\"{ fieldName, groupNames }\">\n                  <!-- @slot Slot to allow for additional elements in the input field \\<div\\>\n                    (before \\<input\\>)\n                  @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                  @binding {number} index - the array index of field values\n                  @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    name=\"input-field-addition-before\"\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :index=\"valueIndex\" />\n                </template>\n                <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n                  <span\n                    v-if=\"element['x-attrs'] && element['x-attrs'].text_before\"\n                    class=\"base-form__input-field__text-before\">\n                    {{ element['x-attrs'].text_before }}\n                  </span>\n                  <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap. for an example see [BaseInput](BaseInput)\n                  @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                  @binding {number} index - the array index of field values\n                  @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    name=\"input-field-inline-before\"\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :index=\"valueIndex\" />\n                </template>\n                <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n                  <span\n                    v-if=\"element['x-attrs'] && element['x-attrs'].text_after\"\n                    class=\"base-form__input-field__text-after\">\n                    {{ element['x-attrs'].text_after }}\n                  </span>\n                  <!-- @slot for adding elements after input\n                  @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                  @binding {number} index - the array index of field values\n                  @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    name=\"input-field-addition-after\"\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :index=\"valueIndex\" />\n                </template>\n                <template #post-input-field=\"{ fieldName, groupNames }\">\n                  <!-- @slot for adding elements at the end covering the whole height\n                  @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                  @binding {number} index - the array index of field values\n                  @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    name=\"post-input-field\"\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :index=\"valueIndex\" />\n                </template>\n                <template #error-icon>\n                  <!-- @slot use a custom icon instead of standard error/warning icon -->\n                  <slot name=\"error-icon\" />\n                </template>\n                <template #remove-icon>\n                  <!-- @slot use a custom icon instead of standard remove icon -->\n                  <slot name=\"remove-icon\" />\n                </template>\n                <template #below-input=\"{ fieldName, groupNames }\">\n                  <!-- @slot below-input slot added to e.g. add drop down\n                  @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                  @binding {number} index - the array index of field values\n                  @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    name=\"below-input\"\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :index=\"valueIndex\" />\n                </template>\n                <template #drop-down-entry=\"{ option, fieldName, groupNames }\">\n                  <!-- @slot customize the form field drop down options\n                    @binding {object} option - the option object\n                    @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n                    @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n                  <slot\n                    :field-name=\"fieldName\"\n                    :group-names=\"groupNames\"\n                    :option=\"option\"\n                    name=\"drop-down-entry\" />\n                </template>\n              </BaseFormFieldCreator>\n\n              <!-- INLINE MULTIPLY FOR TEXT AND DATE FIELDS -->\n              <template\n                v-if=\"multiplyButtonsInline(field)\">\n                <div\n                  ref=\"multiplyButtons\"\n                  class=\"base-form__inline-buttons\">\n                  <BaseButton\n                    v-if=\"valueListInt[field.name].length > 1\n                      || checkFieldContent(field.name, 0)\"\n                    :icon-title=\"valueListInt[field.name].length === 1\n                      ? getI18nTerm('form.clearField') || 'Clear'\n                      : getI18nTerm('form.removeField', -1, { fieldType: getFieldName(element) })\"\n                    :has-background-color=\"false\"\n                    text=\"\"\n                    button-style=\"single\"\n                    icon=\"remove\"\n                    icon-size=\"large\"\n                    class=\"base-form__inline-button\"\n                    @clicked=\"removeField(field, valueIndex)\" />\n                  <BaseButton\n                    :icon-title=\"valueIndex !== (valueListInt[field.name].length - 1)\n                      ? getI18nTerm('form.addGroupBelow', -1, {\n                        fieldType: getFieldName(field),\n                      }) : getI18nTerm('form.addGroup', -1, {\n                        fieldType: getFieldName(field),\n                      })\"\n                    :has-background-color=\"false\"\n                    text=\"\"\n                    button-style=\"single\"\n                    icon=\"plus\"\n                    icon-size=\"large\"\n                    class=\"base-form__inline-button\"\n                    @clicked=\"multiplyField(field, valueIndex)\" />\n                </div>\n              </template>\n\n              <!-- MULTIPLY FOR MULTILINE FIELDS AND FIELD GROUPS -->\n              <div class=\"base-form__multiply-buttons\">\n                <!-- if there is field content show a 'remove all content' button -->\n                <BaseButton\n                  v-if=\"!multiplyButtonsInline(field) && (valueListInt[field.name].length > 1\n                    || checkFieldContent(field.name, 0))\"\n                  :text=\"valueListInt[field.name].length === 1\n                    ? getI18nTerm('form.clearField') || 'Clear'\n                    : getI18nTerm('form.removeField', -1, { fieldType: getFieldName(field) })\"\n                  :has-background-color=\"false\"\n                  icon-position=\"right\"\n                  icon=\"remove\"\n                  :class=\"['base-form__multiply-button', 'base-form__multiply-button--remove']\"\n                  @clicked=\"removeField(field, valueIndex)\" />\n                <!-- multiply button -->\n                <BaseButton\n                  v-if=\"!multiplyButtonsInline(field)\"\n                  :text=\"getI18nTerm('form.addGroup', -1, {\n                    fieldType: getFieldName(field),\n                  })\"\n                  :has-background-color=\"false\"\n                  icon-position=\"right\"\n                  icon=\"plus\"\n                  class=\"base-form__multiply-button\"\n                  @clicked=\"multiplyField(field, valueIndex)\" />\n              </div>\n            </div>\n          </div>\n        </template>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport BaseFormFieldCreator from '@/components/BaseFormFieldCreator/BaseFormFieldCreator';\nimport i18n from '@/mixins/i18n';\n\n/**\n * Component creating a form according to a provided [openAPI](https://www.openapis.org/) standard\n */\n\n// list all the fieldProps here that can be set individually for each repeatable field\nconst INDIVIDUAL_REPEATABLE_FIELDPROPS = [\n  'errorMessage',\n  'invalid',\n  'isActive',\n  'isLoading',\n  'linkedListOption',\n  'activeTab',\n  'validationTexts',\n];\n\nexport default {\n  name: 'BaseForm',\n  components: {\n    BaseButton: () => import('@/components/BaseButton/BaseButton').then(m => m.default || m),\n    BaseIcon: () => import('@/components/BaseIcon/BaseIcon').then(m => m.default || m),\n    BaseFormFieldCreator,\n  },\n  mixins: [i18n],\n  props: {\n    /**\n     * the json object containing all the field information incl. `x-attrs` custom field\n     * for placeholder, field type, etc. (for further documentation and configuration options see\n     * further down below [slots](BaseForm.html#slots))\n     */\n    formFieldJson: {\n      type: Object,\n      required: true,\n    },\n    /**\n     * the values for each field if any already present\n     */\n    valueList: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * set current language\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * provide information about all available languages\n     */\n    availableLocales: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * an id for field groups to still have unique field ids\n     */\n    formId: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define additional style for the form\n     * should be an object e.g. `{ 'padding-top': 0 }`\n     */\n    formStyle: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define fields (specify field name!) for which tabs should be shown\n     */\n    fieldsWithTabs: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * enter the field name of a field that is currently fetching autocomplete\n     * results\n     */\n    fieldIsLoading: {\n      type: String,\n      default: '',\n    },\n    /**\n     * provide an object that contains the options list for all\n     * fields with autocomplete / chips input\n     * for field type `group` provide a nested object with field names\n     * as properties and an array for each field to ensure the correct options are assigned\n     * even if field names within different groups are identical\n     */\n    dropDownLists: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define if error icon should be shown.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * provide an object with settings and properties for each field. This takes an object\n     * with the field name as properties with the props nested.\n     * `{ [fieldName1]: { required: false, ... }, [fieldName2]: { ... } }`\n     *\n     * find the possible variables at the respective input components:\n     * [BaseInput](BaseInput)\n     * [BaseAutocompleteInput](BaseAutocompleteInput)\n     * [BaseMultilineTextInput](BaseMultilineTextInput)\n     * [BaseChipsInput](BaseChipsInput)\n     * [BaseChipsBelow](BaseChipsBelow)\n     * [BaseDateInput](BaseDateInput)\n     * [BaseToggle](BaseToggle)\n     *\n     * **special case repeatable fields**: the following field props can be set individually\n     * per repeated field:\n     *  `errorMessage`, `invalid`, `isActive`, `isLoading`,\n     *  `linkedListOption`, `activeTab`\n     *  the field property value should be set as object specifying the field index as key:\n     *  `{ [fieldIndex]: [value to be set] }` (e.g. `{ required: { 0: false }}`)\n     */\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n      validator: val => Object.keys(val).length === 0 || Object.values(val)\n        .every(fieldProps => Object.keys(fieldProps)),\n    },\n    /**\n     * in case the field `form_group_title` was added to the `x-attrs` field, this is\n     * is rendered as a header above the form and here the HTML tag may be defined.\n     */\n    renderHeaderAs: {\n      type: String,\n      default: 'div',\n    },\n    /**\n     * define validation texts to be displayed below form field if input is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    validationTexts: {\n      type: Object,\n      default: () => ({\n        text: {\n          min: 'Value must be greater than or equal to {value}.',\n          max: 'Value must be less than or equal to {value}.',\n          minLength: 'Text must be at least {value} character(s) long.',\n          maxLength: 'Text cannot be longer than {value} characters.',\n        },\n        chips: {\n          required: 'Select an option.',\n        },\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['text'].every(prop => Object.keys(val).includes(prop))\n        && ['min', 'max', 'minLength', 'maxLength']\n          .every(prop => Object.keys(val.text).includes(prop)),\n    },\n    /**\n     * specify the object property that should be used as identifier.\n     * used for chips input as well as dropdowns.\n     */\n    identifierPropertyName: {\n      type: String,\n      default: 'source',\n    },\n    /**\n     * specify the object property that should be used as value to be displayed.\n     * used for chips input as well as dropdowns.\n     */\n    labelPropertyName: {\n      type: String,\n      default: 'label',\n    },\n    /**\n     * this prop gives the option to add assistive text for screen readers\n     * properties:\n     *\n     * Options for inputs type `autocomplete`, `chips`, `chips-below`:\n     * **loaderActive**: text that is announced when options are being fetched (prop\n     *  `isLoading` is set `true`)\n     *\n     * Options for inputs type `chips`:\n     * **optionToRemoveSelected**: text read when option is marked active for removal (by using\n     *  backspace in empty input field). string {label} could be added to be replaced\n     *  by the actual chip label (value in [`labelPropertyName`])\n     *\n     * Options for inputs type `chips`, `chips-below`:\n     * **resultsRetrieved**: text that is announced when results were retrieved (drop down\n     *  list changed)\n     * **optionAdded**: text read when option was added to the selected list. string {label}\n     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])\n     * **optionRemoved**: text read when option was removed from the selected list. string {label}\n     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])\n     */\n    assistiveText: {\n      type: Object,\n      default: () => ({\n        loaderActive: 'loading.',\n        resultsRetrieved: '{number} options in drop down.',\n        optionAdded: 'option {label} added to selected list.',\n        optionToRemoveSelected: 'option {label} from selected list marked for removal. Press delete or backspace to remove.',\n        optionRemoved: 'option {label} removed.',\n      }),\n    },\n  },\n  data() {\n    return {\n      /**\n       * variable to be able to focus to the field after multiply\n       * @type {?Object}\n       * @property {number} index - the index of the new field in the array\n       * @property {string} name - the name of the field\n       */\n      multiplyParams: null,\n      /**\n       * remember the field for which autocomplete is fetching\n       * @type {string}\n       */\n      fetchingAutocompleteFor: '',\n      /**\n       * internal representation of valueList (containing values for all input fields)\n       * @type {Object}\n       * @property {?string|?Array|?Object} [the name of the input field]\n       */\n      valueListInt: {},\n    };\n  },\n  computed: {\n    /**\n     * the form fields provided in the prop `formFieldJson` as filtered (remove unneeded and hidden fields)\n     * and sorted list with the field key added to the object as `name` property.\n     * @returns {(*&{name: *})[]}\n     */\n    cleanedAndSortedFormFieldList() {\n      return Object.entries(this.formFieldJson)\n        // filter out hidden properties and $ref property from JSON\n        .filter(([, value]) => !value.$ref && !value['x-attrs']?.hidden)\n        // map all fields to include the field key as property `name`\n        .map(([key, value]) => ({ name: key, ...value }))\n        // sort the fields according to their x-attribute (order)\n        .sort((a, b) => (a['x-attrs']?.order > b['x-attrs']?.order ? 1 : -1));\n    },\n    /**\n     * internal form field list, sorted and with additional name property to save\n     * the name of the input field in a variable, also filtered from fields that\n     * should not be shown\n     *\n     * @returns {Object}\n     * @property {string} name - the name of the input field\n     * @property {*} [*] all other properties contained in the swagger\n     */\n    formFieldListInt() {\n      // now get the list in the desired structure of grouping fields with identical field_format\n      // together in the way: [{ type: [field_format], data: [fieldList] }]\n      // where fieldList is an array with all fields that consecutively have the same field format\n      return this.cleanedAndSortedFormFieldList.reduce((prev, curr) => {\n        // save the field_format in a variable\n        const { field_format: fieldFormat, order, field_type: fieldType } = curr['x-attrs'];\n        const lastArrayElementIndex = prev.length - 1;\n        // check if fields should be grouped (only for 'half' and 'third')\n        if (fieldFormat && fieldType !== 'group'\n          && ['half', 'third'].includes(fieldFormat)\n          && prev[lastArrayElementIndex]\n          // and if the last element of the list already has the same format as the current one\n          // and thus an entry for that field format already exists\n          && prev[lastArrayElementIndex]?.type === fieldFormat\n          // also make sure that there are not more than 2 or 3 elements in a row array respectively\n          && ((fieldFormat === 'half' && prev[lastArrayElementIndex].data.length < 2)\n            || (fieldFormat === 'third' && prev[lastArrayElementIndex].data.length < 3))\n          // lastly check if order of elements is sequential so in it is possible to leave a field empty by\n          // skipping a number\n          && prev[lastArrayElementIndex].data.at(-1)['x-attrs'].order + 1 >= order) {\n          // if yes - push the current element to the already existing array\n          prev[lastArrayElementIndex].data.push(curr);\n          // else create a new array entry with the new format for that group (or single field)\n        } else {\n          prev.push({\n            // field type group should always be full\n            type: fieldFormat && curr['x-attrs']?.field_type !== 'group'\n              ? fieldFormat : 'full',\n            data: [curr],\n          });\n        }\n        // return the updated array\n        return prev;\n      }, []);\n    },\n    /**\n     * get the title string for the form header if one was set in the OpenAPI definition\n     * @returns {string}\n     */\n    formHeader() {\n      // find a field with the x-attr form_group_title (formFieldListInt is already sorted\n      // by order x-attr so the title of the field with the lowest order will automatically\n      // be chosen\n      const groupTitleField = this.cleanedAndSortedFormFieldList\n        .find(field => field['x-attrs'] && field['x-attrs'].form_group_title);\n      // return the title string for the header to set if one was found\n      return groupTitleField ? groupTitleField['x-attrs'].form_group_title : '';\n    },\n  },\n  watch: {\n    /**\n     * watch the prop to see if it has changed from outside\n     */\n    valueList: {\n      handler(val) {\n        const changedValues = Object.keys(this.valueListInt)\n          .some(key => JSON.stringify(this.valueListInt[key]) !== JSON.stringify(val[key]));\n        if (changedValues) {\n          this.initializeValueObject();\n        }\n      },\n      deep: true,\n    },\n    /**\n     * if the form fields definition was changed from outside - reinitialize the internal value list\n     */\n    formFieldJson: {\n      handler() {\n        // if new field specifications were set - also reset the properties of the value object\n        this.valueListInt = {};\n        // initialize value object with new properties\n        this.initializeValueObject();\n      },\n      immediate: true,\n    },\n  },\n  updated() {\n    if (this.multiplyParams && this.multiplyParams.name) {\n      const elements = this.$refs[this.multiplyParams.name];\n      if (elements.length) {\n        // this seems like a stupid hack however had to do this because if 'getElementsByTagName'\n        // was evaluated immediately it came back empty for 'textarea' since for some reason\n        // this was not in the DOM tree yet... (no problems for input fields / subforms tho)\n        setTimeout((params) => {\n          const inputs = elements[params.index].getElementsByTagName('textarea').length\n            ? elements[params.index].getElementsByTagName('textarea')\n            : elements[params.index].getElementsByTagName('input');\n          if (inputs.length) {\n            inputs[0].focus();\n          }\n        }, 50, this.multiplyParams);\n      }\n      this.multiplyParams = null;\n    }\n  },\n  mounted() {\n    // inform parent that form was mounted\n    this.$nextTick(() => {\n      this.$emit('form-mounted');\n    });\n  },\n  methods: {\n    /** FORM INPUT HANDLING */\n\n    fetchAutocomplete(params) {\n      this.fetchingAutocompleteFor = params.name;\n      /**\n       * triggered if field has an autocomplete functionality\n       * (chips-input, autocomplete-input, chips-below-input)\n       *\n       * @event fetch-autocomplete\n       *\n       * @property {string} value - the string to autocomplete\n       * @property {string} name - the name of the field\n       * @property {string} source - the url to request the data from\n       * @property {?string} equivalent - string specified for related fields. e.g. for contributor roles equivalent is `contributor`\n       * @property {?string[]} parentFields - in case the autocomplete event originates from a subform the subform id's (field property names) are specififed in this array (most nested property last)\n       */\n      this.$emit('fetch-autocomplete', params);\n    },\n    /**\n     * function triggered when an input field input was completed (e.g. an option selected in chips input or\n     *  an enter key triggered in BaseInput or after a date was validated)\n     *\n     * @param {string|number|Object|Array} value - the updated value\n     * @param {string} fieldName - the name of the field in question\n     * @param {number} index - if field is repeatable - the index in the valueList array\n     */\n    onInputComplete(value, fieldName, index = -1) {\n      // update the valueListInt\n      this.setFieldValue(value, fieldName, index);\n      /**\n       * event emitted once an input was completed (e.g. an option selected in chips input or\n       *  an enter key triggered in BaseInput or after a date was validated)\n       *  @event input-complete\n       *  @property {string, number, Object, Array} - the updated value\n       */\n      this.$emit('input-complete', this.valueListInt);\n    },\n    /**\n     * triggered if value in form field changed\n     * @param {*} value - the altered field value\n     * @param {string} fieldName - the property name of the altered field\n     * @param {number} index - the field index if field is repeatable\n     */\n    setFieldValue(value, fieldName, index = -1) {\n      if (index >= 0) {\n        this.$set(this.valueListInt[fieldName], index, JSON.parse(JSON.stringify(value)));\n      } else {\n        this.$set(this.valueListInt, fieldName, value ? JSON.parse(JSON.stringify(value)) : value);\n      }\n      this.propagateValueListChanges();\n    },\n    /**\n     * emit the value list changes (only triggered by repeatable field manipulation)\n     */\n    propagateValueListChanges() {\n      /**\n       * event triggered when the values of a field were altered or a form\n       * field was added or removed\n       *\n       * @event values-changed\n       * @param {Object[]} - the changed value list\n       * @param {Object} - the field information of the changed field\n       */\n      this.$emit('values-changed', this.valueListInt);\n    },\n\n    /** FIELD VALUE INITIALIZATION */\n\n    /**\n     * go through all fields relevant for display and assign an appropriate value\n     */\n    initializeValueObject() {\n      this.cleanedAndSortedFormFieldList.forEach((field) => {\n        this.$set(\n          this.valueListInt,\n          field.name,\n          this.getInitialFieldValue(field),\n        );\n      });\n    },\n    /**\n     * function to determine the appropriate value for a field\n     * @param {Object} field - the openAPI definition of the field\n     * @returns {{[p: string]: *}|*|boolean|string|string|*[]}\n     */\n    getInitialFieldValue({ name, 'x-attrs': xAttrs, type, items, properties }) {\n      // get the current field value\n      const value = this.valueList[name];\n      // get the OpenAPI x-attrs (that we use for form config) field type\n      const xAttrsFieldType = xAttrs?.field_type;\n      // valid types in OpenAPI definition are 'number' and 'integer'\n      if (['number', 'integer'].includes(type)) {\n        return value || '';\n      }\n      // check special case single-choice chips (is chips but is saved as\n      // (multilang) object on backend)\n      if (xAttrsFieldType && xAttrsFieldType.includes('chips')\n        && type === 'object') {\n        if (value && Object.keys(value).length) {\n          return [].concat(value);\n        }\n        return [];\n      }\n      // check if field is array\n      if (type === 'array') {\n        // check if values are already present and set those if yes\n        if (typeof value === 'object' && value && value.length) {\n          return [].concat(value);\n        }\n        if (!xAttrs || !xAttrsFieldType\n          || (xAttrsFieldType && !xAttrsFieldType.includes('chips'))) {\n          return [].concat(this.getInitialFieldValue(items));\n        }\n        // else return empty array\n        return [];\n        // check if field is object\n      } if (type === 'object') {\n        const initObj = {};\n        // for each property in the object also get initial values\n        Object.keys(properties).forEach((key) => {\n          this.$set(initObj, key, this.getInitialFieldValue(properties[key]));\n        });\n        return ({ ...initObj, ...value });\n      }\n\n      // check if field is boolean\n      if (type === 'boolean') {\n        return value || false;\n      }\n      // if it is not an array or object simply return value from list or empty string\n      return (typeof value === 'string' ? value : '');\n    },\n\n    /** REPEATABLE FIELDS */\n\n    /**\n     * triggered on user clicking multiply button\n     * @param {Object} field - the openAPI information of the form field\n     * @param {number} index - the index of the field where the multiply button was pressed\n     */\n    multiplyField(field, index) {\n      // get the initialized new field values\n      const newFieldValues = this.getInitialFieldValue(field.items);\n      // check if function call is coming from an input field where field can only be\n      // inserted at last position\n      if (!index && index !== 0) {\n        // add field at the end of array\n        this.valueListInt[field.name].push(newFieldValues);\n        // else its coming from an inline repeatable field\n      } else {\n        // insert at the correct level\n        this.valueListInt[field.name].splice(index + 1, 0, newFieldValues);\n      }\n      this.multiplyParams = {\n        index: !index && index !== 0\n          ? this.valueListInt[field.name].length - 1 : index + 1,\n        name: field.name,\n      };\n      // inform parent of changes\n      this.propagateValueListChanges();\n    },\n    /**\n     * remove multiplied field again\n     * @param {Object} field - the openAPI information of the form field\n     * @param {number} index - the index of the field where the remove button was pressed\n     */\n    removeField(field, index) {\n      const fieldGroupValues = this.valueListInt[field.name];\n      // only splice off group if more than one field visible\n      if (fieldGroupValues && fieldGroupValues.length > 1) {\n        fieldGroupValues.splice(index, 1);\n        // else just clear the fields\n      } else {\n        this.$set(fieldGroupValues, index, this.getInitialFieldValue(field.items));\n      }\n      // inform parent of changes\n      this.propagateValueListChanges();\n      this.$emit('input-complete', this.valueListInt);\n    },\n\n    /** VALIDATION */\n\n    /**\n     * Trigger public validate function for each form component\n     * Note: Currently a validation function is only implemented for baseChipsBelow\n     *\n     * @public\n     * @returns {boolean} - forms error state\n     */\n    validate() {\n      const errors = [];\n      // get form elements to iterate through\n      const formFields = this.$refs.baseFormField;\n      // iterate through all form fields, trigger components validation function and\n      // set error state if needed\n      formFields.forEach((field) => {\n        if (Object.keys(field.$refs).length) {\n          // get first ref name\n          const refName = Object.keys(field.$refs)[0];\n          // check if component has a validate function\n          if (field.$refs[refName].validate !== undefined) {\n            // validate component\n            const hasErrors = field.$refs[refName].validate();\n            // set error state if needed\n            if (hasErrors) { errors.push(hasErrors); }\n          }\n        }\n      });\n      // return error state\n      return !!errors.length;\n    },\n\n    /** HELPER FUNCTIONS FOR INDIVIDUAL FIELDS */\n\n    /**\n     * get all the component properties per field that are necessary for the BaseFormFieldCreator\n     *  component\n     * @param {Object} element - the openAPI field definition information\n     * @param {number} index - element row index\n     * @param {number} groupIndex - index of element within a row\n     * @param {number?} [valueIndex=1] - index of element if field is repeatable\n     * @returns {{fieldGroupParams: ({readonly labelPropertyName: string, readonly identifierPropertyName: string, readonly validationTexts: Object, readonly renderHeaderAs: string, readonly fieldProps: Object, readonly clearable: boolean, readonly showErrorIcon: boolean, readonly dropDownLists: Object, readonly fieldIsLoading: string, readonly fieldsWithTabs: *[], readonly formStyle: Object, readonly formId: string, readonly availableLocales: *[], readonly language: string, readonly valueList: Object, readonly formFieldJson: Object}|null), showErrorIcon: boolean, labelPropertyName: string, clearable: boolean, validationTexts: (*|Object), dropDownList: *, fieldKey: string, autocompleteLoading: boolean, sortText: (string|string), language: string, label: (*|string), fieldValue: *, showLabel: boolean, identifierPropertyName: string, availableLocales: *[], field, secondaryDropdown: *, fieldProps: (any|{})}}\n     */\n    formFieldComponentProps(element, index, groupIndex, valueIndex = -1) {\n      // get the element.name for easier access\n      const { name } = element;\n      // get all fieldProps of that field if set, otherwise set empty array\n      // important to create an independent copy because properties eventually get deleted\n      // later on\n      let singleFieldProps = this.fieldProps[name]\n        ? JSON.parse(JSON.stringify(this.fieldProps[name])) : {};\n      // store in variable if field is repeatable\n      const fieldRepeatable = valueIndex >= 0;\n      // check if field is repeatable\n      if (fieldRepeatable) {\n        // if yes get the field Props that are actually settable for each field individually\n        // and present in the fieldProps object\n        const existingIndividualFieldProps = Object.entries(singleFieldProps)\n          .filter(([key]) => INDIVIDUAL_REPEATABLE_FIELDPROPS.includes(key));\n        // now check if any individually settable field props were found for the field\n        if (existingIndividualFieldProps.length) {\n          // now get an object that only contains the fieldProps of repeatable fields where the\n          // index is present in the value object\n          // otherwise delete the value object from the fieldProps completely (since usually not\n          // compatible with actual fieldProp type and values not usable\n          const repeatableFieldProps = existingIndividualFieldProps.reduce((prev, [key, value]) => {\n            // check if the input field index exists as a key in the value object\n            if (Object.keys(value).includes(valueIndex.toString())) {\n              // if yes - add it to the object with the appropriate value\n              return {\n                ...prev,\n                [key]: value[valueIndex.toString()],\n              };\n            }\n            // else delete the fieldProp from the fieldProps object completely\n            delete singleFieldProps[key];\n            // and just return the unmodified object\n            return prev;\n          }, {});\n          // finally actually combine the original fieldProps object with the properties settable\n          // per repeated field\n          singleFieldProps = {\n            ...singleFieldProps,\n            ...repeatableFieldProps,\n\n          };\n        }\n      }\n      // create a unique string for identifier(key) purposes out of field index\n      // and (if field is repeatable) value index\n      const comboIndex = fieldRepeatable ? `${index}_${groupIndex}_${valueIndex}` : `${index}_${groupIndex}`;\n\n      return {\n        field: element,\n        label: singleFieldProps && singleFieldProps.label\n          ? singleFieldProps.label : this.getFieldName(element),\n        fieldProps: singleFieldProps,\n        showLabel: !this.allowMultiply(element)\n          || !this.multiplyButtonsInline(element) || valueIndex === 0,\n        dropDownList: this.dropDownLists[name],\n        secondaryDropdown: this.dropDownLists[`${name}_secondary`],\n        language: this.language,\n        availableLocales: this.availableLocales,\n        sortText: this.getI18nTerm('form.sort') || 'Sort',\n        fieldKey: `${name}_${comboIndex}_${this.formId}`,\n        fieldValue: fieldRepeatable ? this.valueListInt[name][valueIndex]\n          : this.valueListInt[name],\n        autocompleteLoading: this.fieldIsLoading === name,\n        // add component props to form fields creator props if list contains a field_type 'group'\n        fieldGroupParams: this.cleanedAndSortedFormFieldList\n          .some(field => field['x-attrs'] && field['x-attrs'].field_type === 'group')\n          ? this.$props : null,\n        clearable: this.clearable,\n        showErrorIcon: this.showErrorIcon,\n        validationTexts: singleFieldProps.validationTexts || this.validationTexts,\n        identifierPropertyName: this.identifierPropertyName,\n        labelPropertyName: this.labelPropertyName,\n        assistiveText: singleFieldProps.assistiveText || this.assistiveText,\n      };\n    },\n    /**\n     * check if field can be multiplied\n     * @param {Object} el - the openAPI field definition information\n     * @returns {boolean}\n     */\n    allowMultiply(el) {\n      // field can be multiplied if it is an array and not a chips or chips-below\n      // field\n      return el.type === 'array' && (!el['x-attrs'] || !el['x-attrs'].field_type || (el['x-attrs']\n        && !['chips', 'chips-below'].includes(el['x-attrs'].field_type)));\n    },\n    /**\n     * check if field should display multiply buttons inline (all but 'group' and 'multiline')\n     * @param {Object} el - the openAPI field definition information\n     * @returns {boolean}\n     */\n    multiplyButtonsInline(el) {\n      return !['group', 'multiline'].includes(el['x-attrs'].field_type);\n    },\n    /**\n     * check if field is a date field with switch buttons above - this means it needs\n     *  more margin on top\n     * @param {Object} fieldXAttrs - the openAPI field information 'x-attrs'\n     * @returns {boolean}\n     */\n    fieldIsDateSwitch(fieldXAttrs) {\n      // check if field is date and is switchable (= date_format is date_year or date_month_year)\n      return fieldXAttrs?.field_type?.includes('date') && fieldXAttrs?.date_format?.includes('_');\n    },\n    /**\n     * get a field name to display\n     * @param {Object} el - the openAPI field definition information\n     * @returns {string}\n     */\n    getFieldName(el) {\n      // use the openAPI definition title or see if there is a i18n translation key with the field key\n      return el.title || this.getI18nTerm(`form.${el.name}` || el.name);\n    },\n    /**\n     * determine if field has content to see if multiply buttons should be shown\n     * @param {string} fieldName - the field key / property name\n     * @param {number} index - index in the repeated field\n     * @returns {boolean}\n     */\n    checkFieldContent(fieldName, index = -1) {\n      return this.hasValues(index < 0\n        ? this.valueListInt[fieldName][index] : this.valueListInt[fieldName]);\n    },\n    /**\n     * loop through all field values depending on the type of value\n     * @param {*} fieldValues - the values assigned to a form field\n     * @returns {boolean}\n     */\n    hasValues(fieldValues) {\n      let hasContent = false;\n      if (fieldValues && typeof fieldValues === 'object') {\n        if (fieldValues.length >= 0) {\n          fieldValues.forEach((values) => {\n            hasContent = this.hasValues(values) || hasContent;\n          });\n        } else {\n          const objectKeys = Object.keys(fieldValues);\n          objectKeys\n            .forEach((key) => {\n              hasContent = this.hasValues(fieldValues[key]) || hasContent;\n            });\n        }\n      } else {\n        hasContent = fieldValues === 0 || !!fieldValues || hasContent;\n      }\n      return hasContent;\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import \"../../styles/variables\";\n\n  .base-form {\n    position: relative;\n\n    .base-form__header {\n      position: relative;\n      margin: $spacing-small $spacing;\n      color: $font-color-second;\n    }\n\n    .base-form__body {\n      background-color: white;\n      display: flex;\n      flex-direction: column;\n      gap: $spacing;\n      padding: $spacing;\n\n      @media screen and (max-width: $mobile) {\n        padding: $spacing $spacing-small $spacing;\n        gap: $spacing-small;\n      }\n\n      .base-form__form-row {\n        display: flex;\n        flex-direction: row;\n        gap: $spacing;\n        width: 100%;\n        // this is flex-start to keep nice alignment if error message is shown!\n        align-items: flex-start;\n\n        &.base-form__form-row--full {\n          flex-direction: column;\n        }\n\n        // from 870px switch all fields to full width\n        @media screen and (max-width: 870px) {\n          &.base-form__form-row--half, &.base-form__form-row--third {\n            flex-direction: column;\n          }\n        }\n\n        // on mobile reduce the gap between single fields\n        @media screen and (max-width: $mobile) {\n          gap: $spacing-small;\n        }\n\n        .base-form__input-field {\n          flex: 0 1 100%;\n          width: 100%;\n          display: flex;\n          flex-direction: column;\n          gap: $spacing;\n\n          &.base-form__input-field--date-switch-spacing {\n            gap: 0;\n          }\n\n          @media screen and (max-width: 870px) {\n            &.base-form__input-field--date-switch-spacing {\n              margin-top: $spacing-small-half;\n            }\n          }\n\n          @media screen and (max-width: $mobile) {\n            gap: $spacing-small;\n            &.base-form__input-field--date-switch-spacing {\n              margin-top: calc(#{$spacing-small} + #{$spacing-small-half});\n              gap: $spacing-small;\n            }\n          }\n\n          &.base-form__input-field--half {\n            // needed to add the 0.01rem for edge...\n            flex: 0 1 calc(50% - #{$spacing-small} - 0.01rem);\n            max-width: calc(50% - #{$spacing-small} - 0.01rem);\n\n            @media screen and (max-width: 870px) {\n              flex: 0 0 100%;\n              max-width: 100%;\n            }\n          }\n\n          &.base-form__input-field--third {\n            // needed to add the 0.01rem for edge...\n            flex: 0 1 calc(33% - #{$spacing-small} - 0.01rem);\n            max-width: calc(33% - #{$spacing-small} - 0.01rem);\n\n            @media screen and (max-width: 870px) {\n              flex: 0 0 100%;\n              max-width: 100%;\n            }\n          }\n\n          &.base-form__input-field--top-margin {\n            margin-top: $line-height + $spacing-small;\n\n            // since field switches to only one field per row - remove top margin\n            @media screen and (max-width: 870px) {\n              margin-top: 0;\n            }\n          }\n\n          .base-form__repeatable-field {\n            display: flex;\n            align-items: flex-end;\n            transform: none;\n            // this gap needs to be here for the flex box to not go beyond boarder\n            gap: $spacing;\n\n            .base-form__inline-buttons {\n              flex: 0 0 auto;\n              display: flex;\n              align-items: center;\n              color: $font-color-second;\n              // align buttons with the form\n              margin: 0 0 0 (-#{$spacing-small});\n\n              .base-form__inline-button {\n                flex: 0 0 auto;\n                // reduce the button spacing\n                padding: 0 $spacing-small;\n              }\n            }\n          }\n\n          &.base-form__input-field--date-switch-spacing {\n            .base-form__repeatable-field:not(:first-child) {\n              margin-top: calc(#{$spacing-small} + #{$spacing-small-half});\n            }\n          }\n\n          .base-form__input-component {\n            flex: 1 1 auto;\n\n            &.base-form__input-component--margin-bottom {\n              margin-bottom: $spacing-small;\n\n              @media screen and (max-width: $mobile) {\n                margin-bottom: calc(#{$spacing-small} + #{$spacing-small-half});\n              }\n            }\n          }\n\n          .base-form__multiply-buttons {\n            display: flex;\n            flex-direction: column;\n            align-items: flex-start;\n            margin-left: -($spacing);\n\n            @media screen and (max-width: $mobile) {\n              flex-direction: row;\n              flex-wrap: wrap;\n              margin-top: -($spacing-small);\n            }\n\n            .base-form__multiply-button {\n              color: $font-color-second;\n            }\n          }\n\n          .base-form__input-field__text-before {\n            margin-right: $spacing-small;\n          }\n\n          .base-form__input-field__text-after {\n            margin-left: $spacing-small;\n          }\n        }\n      }\n    }\n  }\n</style>\n\n<style lang=\"scss\">\n  @import \"../../styles/variables.scss\";\n\n  .base-form__input-field--third {\n    .base-form-field-creator__date-field-wrapper {\n      flex-direction: column;\n    }\n  }\n\n  @media screen and (min-width: $mobile) {\n    .base-form__input-field {\n      .base-drop-down-list__container {\n        max-width: calc(100% - #{$spacing} * 2);\n      }\n    }\n  }\n</style>\n"],"names":["INDIVIDUAL_REPEATABLE_FIELDPROPS","_sfc_main","m","BaseFormFieldCreator","i18n","val","fieldProps","prop","value","_a","key","a","b","_b","prev","curr","fieldFormat","order","fieldType","lastArrayElementIndex","groupTitleField","field","elements","params","inputs","fieldName","index","name","xAttrs","type","items","properties","xAttrsFieldType","initObj","newFieldValues","fieldGroupValues","errors","refName","hasErrors","element","groupIndex","valueIndex","singleFieldProps","fieldRepeatable","existingIndividualFieldProps","repeatableFieldProps","comboIndex","el","fieldXAttrs","fieldValues","hasContent","values"],"mappings":"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"}