{"version":3,"file":"BaseAdvancedSearch.vue.cjs.js","sources":["../../../src/components/BaseAdvancedSearch/BaseAdvancedSearch.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"searchContainer\"\n    class=\"base-advanced-search\">\n    <!-- FILTER ROW LIST (MODE 'LIST') -->\n    <template v-if=\"mode === 'list' && appliedFiltersInt && appliedFiltersInt.length\">\n      <BaseAdvancedSearchRow\n        v-for=\"(filter, index) in appliedFiltersInt\"\n        :key=\"'filter-' + index\"\n        :mode=\"mode\"\n        :search-row-id=\"`${rowId}-${filter[identifierPropertyName.filter]}-${index}`\"\n        :is-main-search=\"false\"\n        :autocomplete-results=\"filtersAutocompleteResults[index]\"\n        :filter-list=\"displayedFilters\"\n        :applied-filter=\"filter\"\n        :is-loading=\"filtersLoadingState[index]\"\n        :default-filter=\"defaultFilter\"\n        :placeholder=\"placeholder.filterRow || placeholder\"\n        :autocomplete-property-names=\"autocompletePropertyNames\"\n        :label-property-name=\"labelPropertyName\"\n        :identifier-property-name=\"identifierPropertyName\"\n        :drop-down-info-texts=\"dropDownInfoTexts\"\n        :advanced-search-text=\"advancedSearchText\"\n        :assistive-text=\"{\n          addFilter: assistiveText.addFilter,\n          removeFilter: assistiveText.removeFilter,\n          selectFilterLabel: assistiveText.selectFilterLabel,\n          searchLabel: assistiveText.searchLabel,\n          selectedOption: assistiveText.selectedOption,\n          loaderActive: assistiveText.autocompleteLoaderActive,\n          autocompleteResultsRetrieved: assistiveText.autocompleteResultsRetrieved,\n          autocompleteNoResults: assistiveText.autocompleteNoResults,\n          autocompleteInitial: assistiveText.autocompleteInitial,\n          categoryAnnouncement: assistiveText.categoryAnnouncement,\n          optionsAnnouncement: assistiveText.optionsAnnouncement,\n        }\"\n        :date-field-delay=\"dateFieldDelay\"\n        :language=\"language\"\n        :highlight-autocomplete-match=\"highlightAutocompleteMatch\"\n        :highlight-autocomplete-tags=\"highlightAutocompleteTags\"\n        class=\"base-advanced-search__filter-row\"\n        @remove-filter=\"removeFilter($event, index)\"\n        @update:applied-filter=\"updateFilter($event, index)\"\n        @fetch-autocomplete-results=\"fetchAutocomplete($event, index)\">\n        <template #autocomplete-option=\"{ option: autocompleteOption, collectionId }\">\n          <!-- @slot to allow for modification of the autocomplete option\n            @binding {Object} option - the option object as specified in the [autocompletePropertyNames.data] array\n            @binding {string} collection-id the currently active collection as provided in [autocompletePropertyNames.id] -->\n          <slot\n            name=\"autocomplete-option\"\n            :option=\"autocompleteOption\"\n            :collection-id=\"collectionId\" />\n        </template>\n      </BaseAdvancedSearchRow>\n    </template>\n\n    <!-- MAIN FILTER -->\n    <BaseAdvancedSearchRow\n      ref=\"mainSearch\"\n      :search-row-id=\"`main-${rowId}`\"\n      :mode=\"mode\"\n      :applied-filter.sync=\"mainFilter\"\n      :filter-list=\"displayedFilters\"\n      :form-filter-list=\"formFilterList\"\n      :default-filter=\"defaultFilter\"\n      :autocomplete-results=\"filtersAutocompleteResults[mainFilterIndex]\"\n      :is-loading=\"filtersLoadingState[mainFilterIndex]\"\n      :placeholder=\"placeholder.main || placeholder\"\n      :autocomplete-property-names=\"autocompletePropertyNames\"\n      :label-property-name=\"labelPropertyName\"\n      :identifier-property-name=\"identifierPropertyName\"\n      :drop-down-info-texts=\"dropDownInfoTexts\"\n      :advanced-search-text=\"advancedSearchText\"\n      :assistive-text=\"{\n        addFilter: assistiveText.addFilter,\n        removeFilter: assistiveText.removeFilter,\n        selectFilterLabel: assistiveText.selectFilterLabel,\n        searchLabel: assistiveText.searchLabel,\n        selectedOption: assistiveText.selectedOption,\n        loaderActive: assistiveText.autocompleteLoaderActive,\n        autocompleteResultsRetrieved: assistiveText.autocompleteResultsRetrieved,\n        autocompleteNoResults: assistiveText.autocompleteNoResults,\n        autocompleteInitial: assistiveText.autocompleteInitial,\n        categoryAnnouncement: assistiveText.categoryAnnouncement,\n        optionsAnnouncement: assistiveText.optionsAnnouncement,\n        results: assistiveText.results,\n      }\"\n      :date-field-delay=\"dateFieldDelay\"\n      :language=\"language\"\n      :highlight-autocomplete-match=\"highlightAutocompleteMatch\"\n      :highlight-autocomplete-tags=\"highlightAutocompleteTags\"\n      v-on=\"$listeners\"\n      @add-filter-row=\"addFilterRow\"\n      @fetch-autocomplete-results=\"fetchAutocomplete($event, mainFilterIndex)\"\n      @option-selected=\"fillOptionToForm\">\n      <!-- SHOW ADVANCED SEARCH FORM BUTTON (MODE 'FORM') -->\n      <template #after>\n        <BaseButton\n          v-if=\"mode === 'form'\"\n          :text=\"showAdvancedSearchButtonText ? advancedSearchText.advancedButtonLabel : ''\"\n          :aria-expanded=\"`${formOpen}`\"\n          :aria-controls=\"`${rowId}-form`\"\n          :description=\"advancedButtonDescription\"\n          button-style=\"row\"\n          icon=\"drop-down\"\n          icon-size=\"small\"\n          icon-position=\"right\"\n          :class=\"['base-advanced-search__expand-button',\n                   { 'base-button-icon-rotate-180': formOpen }]\"\n          @click.native.prevent.stop=\"openAdvancedSearch\"\n          @keydown.native.enter.space.prevent.stop=\"openAdvancedSearch\"\n          @focusin.native.stop />\n      </template>\n      <!-- ADVANCED SEARCH FORM (MODE 'FORM') -->\n      <template #below>\n        <BaseForm\n          v-if=\"mode === 'form' && formOpen\"\n          :id=\"`${rowId}-form`\"\n          v-bind=\"amendedFormProps\"\n          :form-field-json=\"formFilterList\"\n          :value-list=\"formFilterValuesInt\"\n          :label-property-name=\"labelPropertyName.formInputs\"\n          :identifier-property-name=\"identifierPropertyName.formInputs\"\n          :class=\"['base-advanced-search__search-form',\n                   { 'base-advanced-search__search-form--hidden': !formMounted}]\"\n          @input-complete=\"updateFormFilters\"\n          @fetch-autocomplete=\"fetchFormAutocomplete\"\n          @form-mounted=\"formIsMounted\">\n          <template #label-addition=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-label-addition\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #pre-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-pre-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template\n            #input-field-addition-before=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-input-field-addition-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-input-field-inline-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-input-field-addition-after\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #post-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-post-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots). -->\n            <slot name=\"form-error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots). -->\n            <slot name=\"form-remove-icon\" />\n          </template>\n          <template #below-input=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-below-input\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #drop-down-entry=\"{ option, fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n              @binding {object} option - the option object\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\"\n              :option=\"option\"\n              name=\"form-drop-down-entry\">\n              <template\n                v-if=\"mode === 'form'\n                  // check if value is boolean and was set true\n                  && ((typeof renderFormChipsLabelAsHtml === 'boolean' && renderFormChipsLabelAsHtml)\n                    // or if it is an array and\n                    || (typeof renderFormChipsLabelAsHtml === 'object'\n                      // a) includes the field name\n                      && (renderFormChipsLabelAsHtml.includes(fieldName)\n                        // or b) this is nested field in a form group and the array\n                        // contains a (nested) object with the group names and an array with the field name\n                        || (groupNames?.length && renderFormChipsLabelAsHtml\n                          .some((arrayEntry) => typeof arrayEntry === 'object'\n                            && extractNestedPropertyValue(groupNames.join('.'), arrayEntry)\n                              .includes(fieldName))))))\">\n                <span\n                  v-insert-text-as-html=\"{\n                    value: option[labelPropertyName.formInputs],\n                    interpretTextAsHtml: true,\n                  }\" />\n              </template>\n            </slot>\n          </template>\n        </BaseForm>\n        <div\n          v-else-if=\"mode === 'form' && !formOpen && collapsedFiltersArray.length\">\n          <BaseCollapsedFilterRow\n            :filters.sync=\"collapsedFiltersArray\"\n            :date-time-text=\"advancedSearchText.collapsedDateTime\"\n            :interpret-label-as-html=\"renderFormChipsLabelAsHtml\"\n            :assistive-text=\"{\n              removeFiltersLabel: assistiveText.removeAllFiltersLabel,\n              filterRemovedNotification: assistiveText.removeFilterValueNotification,\n              appliedFiltersLabel: assistiveText.collapsedAppliedFiltersLabel,\n              booleanFilterLabel: assistiveText.collapsedBooleanFilterValue,\n              optionToRemoveSelected: assistiveText.collapsedOptionToRemoveSelected,\n            }\"\n            @remove-all=\"removeAllFilters\" />\n        </div>\n      </template>\n      <template #autocomplete-option=\"{ option: autocompleteOption, collectionId }\">\n        <!-- @slot to allow for modification of the autocomplete option\n          @binding {Object} option - the option object as specified in the [autocompletePropertyNames.data] array\n          @binding {string} collection-id the currently active collection as provided in [autocompletePropertyNames.id] -->\n        <slot\n          name=\"autocomplete-option\"\n          :option=\"autocompleteOption\"\n          :collection-id=\"collectionId\">\n          <!-- also automate the display of html for all fields specified directly in the component -->\n          <template\n            v-if=\"mode === 'form'\n              && ((typeof renderFormChipsLabelAsHtml === 'boolean' && renderFormChipsLabelAsHtml)\n                || (typeof renderFormChipsLabelAsHtml === 'object'\n                  && renderFormChipsLabelAsHtml.includes(collectionId)))\">\n            <span\n              v-insert-text-as-html=\"{\n                value: autocompleteOption[labelPropertyName.autocompleteOption],\n                interpretTextAsHtml: true,\n              }\" />\n          </template>\n        </slot>\n      </template>\n    </BaseAdvancedSearchRow>\n    <span\n      v-if=\"assistiveTextNotification\"\n      aria-live=\"assertive\"\n      class=\"assistive-text\">\n      {{ assistiveTextNotification }}\n    </span>\n  </div>\n</template>\n\n<script>\nimport { defineAsyncComponent, ref } from 'vue';\nimport { createId, debounce, extractNestedPropertyValue, hasData, sort } from '@/utils/utils';\nimport InsertTextAsHtml from '@/directives/InsertTextAsHtml';\nimport BaseAdvancedSearchRow from '@/components/BaseAdvancedSearch/BaseAdvancedSearchRow';\nimport { useAnnouncer } from '@/composables/useAnnouncer';\n\n/**\n * @typedef Filter\n * @property {string?} label|* - property 'label' indicating the label or an equivalent\n *  custom property defined in prop labelPropertyName.filter\n * @property {string} id|* - property 'id' used as unique identifier or an equivalent\n *  custom property defined in prop identifierPropertyName.filter\n * @property {string} type - a filter type defining the type of search element shown\n *  @values text, chips, chipssingle, date, daterange\n * @property {boolean?} [hidden] - exclude filters that have this attribute true from display\n * @property {boolean?} [freetext_allowed] - property specifc for type: chips determining\n *  if options are autocompleted (true) or used from the options property (false)\n * @property {Object[]?} [options] - the options used for chips filter types with\n *  freetext_allowed false\n * @property {Object[]|string[]|string|Object?} [filter_values] - the values a filter contains - only\n *  relevant for applied filters, not for filters coming from backend presented in the drop down\n * @property {string[]} [subsets] - if a filter of `type` 'text' or 'chips' with `freetext_allowed`\n *      (thus triggering autocomplete) has subordinate filters for which the autosuggest results\n *      should also be shown - add these filter ids here\n */\n\nexport default {\n  name: 'BaseAdvancedSearch',\n  components: {\n    BaseAdvancedSearchRow,\n    BaseCollapsedFilterRow: defineAsyncComponent(() => import('@/components/BaseAdvancedSearch/BaseCollapsedFilterRow').then(m => m.default || m)),\n    BaseForm: defineAsyncComponent(() => import('@/components/BaseForm/BaseForm').then(m => m.default || m)),\n    BaseButton: defineAsyncComponent(() => import('@/components/BaseButton/BaseButton').then(m => m.default || m)),\n  },\n  directives: {\n    insertTextAsHtml: InsertTextAsHtml,\n  },\n  props: {\n    /**\n     * define the appearance and functionality of the component here.\n     * **`list`**: search offers advanced search with 'filters' to select from drop down, each filter is added\n     *    as a separate row.\n     * **`form`**: advanced search is displayed as a form below only one single search row. Offers a condensed view\n     *    of the form within a single scrollable row below main row.\n     */\n    mode: {\n      type: String,\n      default: 'list',\n      validator: val => ['list', 'form'].includes(val),\n    },\n    /**\n     * this variable is just used in mode `list`, for mode `form` leave it empty and use variable `formFilterList`\n     *  to provide a list of filters instead.\n     * provide a list of available filters, needs to be an array of objects with the following properties:\n     *\n     *    **label** `string` - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `labelPropertyName.filter`.\n     *    **id** `string` - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `identifierPropertyName.filter`.\n     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.\n     *    **hidden** `boolean` - filters with this attribute true will be filtered from\n     *      displayed filter list.\n     *    **freetext_allowed** `boolean` - determines if predetermined options from `options`\n     *      property are used or autocomplete is used.\n     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled\n     *      vocabulary options.\n     *     **subsets** `string[]` - if a filter of `type` 'text' or 'chips' with\n     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which\n     *      the autosuggest results should also be shown - add the filter identifiers here\n     */\n    filterList: {\n      type: Array,\n      default: () => ([]),\n      validator: val => !val.length\n        // make sure a filter type is present and type is other than chips or freetext is\n        // allowed - otherwise it needs to have an options property\n        || (val.every(v => !!v.type\n          && (!['chips', 'chipssingle'].includes(v.type) || v.freetext_allowed || !!v.options))),\n    },\n    /**\n     * this variable is just used in mode `list`, for mode `form` leave it empty and use property `formFilterValues`\n     *  to provide values per filter instead.\n     * possibility to set applied filters from outside, for necessary object properties\n     * see `filterList` (except `options` - this property is not necessary for applied filters)\n     */\n    appliedFilters: {\n      type: Array,\n      default: () => ([]),\n      // don't check for options on applied filters - not necessary\n      validator: val => !val.length || val.every(v => v.type),\n    },\n    /**\n     * in mode `list` specify a default value for a filter that is set when none of the\n     * available filters is selected, should have the following properties:\n     *\n     *    **label** `string` - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `labelPropertyName.filter`.\n     *    **id** `string` - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `identifierPropertyName.filter`.\n     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.\n     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled\n     *      vocabulary options.\n     *    **filter_values** `Object[], string[], Object` - the values selected - object for date\n     *    or array of objects or strings for type `text`, type `chips` and `chipssingle`,\n     *\n     *    defaultFilter does not need the property `subsets` since results for all filters are\n     *    shown per default\n     *\n     *  this property is not relevant in mode `form`\n     */\n    defaultFilter: {\n      type: Object,\n      default: () => ({\n        label: 'Fulltext',\n        id: 'default',\n        type: 'text',\n        options: [],\n        filter_values: [],\n      }),\n      validator: val => val === null || (val.type\n        && (!['chips', 'chipssingle'].includes(val.type) || val.options)),\n    },\n    /**\n     * this variable is just used in mode `form`, for mode `list` leave it empty and use property `filterList`\n     *  to provide a list of filters instead.\n     * for mode 'form' provide a specification for the form fields in the form of [OpenAPi\n     *  schema object](https://swagger.io/specification/#schema-object).\n     *  see also [BaseForm](BaseForm) `form-field-json` prop - currently all field types except\n     *    `multiline` and `chips-below` and for date/time fields only single date, date range and date time fields\n     *    are supported. Also field groups are supported but maximum nesting level is 1.\n     */\n    formFilterList: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * this variable is just used in mode `form`, for mode `list` leave it empty and use property `appliedFilters`\n     *  to provide values per filter instead.\n     * provide values for the fields specified in `formFilterList`. Main filter can be filled by adding a `default` property.\n     */\n    formFilterValues: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * pass props for [BaseForm](BaseForm) directly via this prop, for example `autocompleteResults`,\n     *  `isLoading` or `fieldProps` (except `valueList` and `formFieldJson` which are passed separately\n     *   since they are also utilized (and modified) in this component).\n     */\n    formProps: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * provide the component with the fetched autocomplete results\n     * (drop down options).\n     * this needs to be an object array with the properties specified in\n     * `autocompletePropertyNames`.\n     */\n    autocompleteResults: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * specify a language (ISO 639-1) (used for label if label is language specific object\n     * e.g. `{ de: 'xxx', en: 'yyy' }`) or for date display conversion in mode 'form'.\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * set the row loader from outside per row index\n     */\n    isLoadingIndex: {\n      type: Number,\n      default: -1,\n    },\n    /**\n     * specify informational texts for the component - this needs to be an object with the following\n     * properties (if you don't want to display any text leave an empty string):\n     *\n     *     **title**: text shown as first line on the drop-down in filters area for mode `list`.\n     *     **subtext**: text shown as second line on the drop-down in filters area for mode `list`.\n     *     **availableOptions**: text shown with chips options for controlled vocabulary\n     *     search` for mode `list`.\n     *     **collapsedDateTime**: for mode `form`: set the text for the collapsed filter row which is\n     *      displayed for date or time values of ranges when only one field is filled. (e.g. `until 12.12.2023`)\n     *     **advancedButtonLabel**: button text displayed for Advanced Search Toggle button for mode `form`.\n     *\n     *  The values of this object might be plain text or a key for an i18n file.\n     */\n    advancedSearchText: {\n      type: Object,\n      default: () => ({\n        title: 'Advanced Search',\n        subtext: 'Select a filter',\n        availableOptions: 'Available options',\n        collapsedDateTime: {\n          from: 'from',\n          until: 'until',\n          range: 'to',\n        },\n        advancedButtonLabel: 'Advanced Search',\n      }),\n    },\n    /**\n     * specify informational texts for the drop-down - this needs to be an object with the following\n     * properties:\n     *\n     *     **autocompleteNoOptions**: info text shown when autocomplete search does not yield\n     *        any results.\n     *     **autocompleteOngoing**: info text displayed while autocomplete search is ongoing\n     *        (and no previous results are displayed).\n     *     **autocompleteInitial**: info text shown when user first opens the search\n     *        component.\n     *     **chipsNoOptions**: info text shown when no options for controlled vocabulary search\n     *        are available (anymore).\n     *     **chipsMaxOptions**: text displayed if more than max number of options that can be\n     *        displayed are available (configure via prop `maxNumberControlledOptions`).\n     *     **chipsNoMatch**: text displayed if string in input does not match any options.\n     *     **chipsOngoing**: info text shown when controlled vocabulary chips are being\n     *        fetched.\n     *\n     *  The values of this object might be plain text or a key for an i18n file\n     * This prop can be ignored when the `no-options` slot is used.\n     */\n    dropDownInfoTexts: {\n      type: Object,\n      default: () => ({\n        autocompleteNoOptions: 'No matching options found',\n        autocompleteOngoing: 'Autocomplete is being fetched...',\n        autocompleteInitial: 'Please start typing or select a filter to see options',\n        chipsNoOptions: 'No more options available',\n        chipsMaxOptions: 'Please start typing to see options',\n        chipsNoMatch: 'No matching options were found',\n        chipsOngoing: 'Options are being loaded...',\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['autocompleteNoOptions', 'autocompleteOngoing', 'autocompleteInitial',\n        'chipsNoOptions', 'chipsOngoing', 'chipsMaxOptions', 'chipsNoMatch']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * add a placeholder for the search input, either a string used for every row or\n     * add separate values for main filter row and already added filters\n     * properties:\n     *     **filterRow**: for already added filter rows.\n     *     **main**: for the primary search input field.\n     *\n     *  each of these specific placeholders can again be a string or an object with different\n     *  placeholders for each search type (`text`, `chips`, `date`)\n     */\n    placeholder: {\n      type: [Object, String],\n      default: () => ({\n        filterRow: 'Add values to your filter',\n        main: 'Search and Discover',\n      }),\n      validator: val => typeof val === 'string' || ['filterRow', 'main']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * specify the object property that can be used for identification of filters,\n     * autocomplete options and controlled vocabulary options.\n     *   Could be a string (used for all the mentioned objects) or an object with the following\n     *   properties:\n     *     **filter**: identifier property name in filter objects.\n     *     **autocompleteOption**: identifier property name in autocomplete option objects.\n     *     **controlledVocabularyOption**: identifier property name in controlled\n     *     vocabulary option objects.\n     *     **formInputs**: for mode 'form' in case the form contains chips or autocomplete input fields,\n     *      the object properties for label and identifier need to be set here (in case they are different\n     *      from the input components default (e.g. see [BaseChipsInput](BaseChipsInput) `identifierPropertyName`))\n     *      if `identifierPropertyName` is also set via `fieldProps` the latter is the preferred value.\n     *  Caveat: Please note that the property `idInternal` is used for internal handlings and the property\n     *    might be overwritten\n     */\n    identifierPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'id',\n        autocompleteOption: 'id',\n        controlledVocabularyOption: 'id',\n        formInputs: 'source',\n      }),\n    },\n    /**\n     * specify the object property that should be used for label display of filters,\n     * autocomplete options and controlled vocabulary options.\n     *   Could be a string (used for all the mentioned objects) or an object with the following\n     *   properties:\n     *     **filter**: label property name in filter objects.\n     *     **autocompleteOption**: label property name in autocomplete option objects.\n     *     **controlledVocabularyOption**: label property name in controlled\n     *     vocabulary option objects.\n     *     **formInputs**: for mode 'form' in case the form contains chips or autocomplete input fields,\n     *      the object properties for label and identifier need to be set here (in case they are different\n     *      from the input components default (e.g. see [BaseChipsInput](BaseChipsInput) `labelPropertyName`))\n     *      if `labelPropertyName` is also set via `fieldProps` the latter is the preferred value.\n     *    Caveat: Please note that the property `labelInternal` is used for internal handlings and the property\n     *    might be overwritten\n     */\n    labelPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'label',\n        autocompleteOption: 'title',\n        controlledVocabularyOption: 'label',\n        formInputs: 'label',\n      }),\n    },\n    /**\n     * autocomplete results need a label, and id and a data property that contains all the actual\n     * autocomplete results for that specific category\n     * TODO: make category optional\n     */\n    autocompletePropertyNames: {\n      type: Object,\n      default: () => ({\n        label: 'label',\n        id: 'id',\n        data: 'data',\n      }),\n      // check if all the necessary attributes are included in the provided object\n      validator: val => ['id', 'label', 'data'].every(key => Object.keys(val).includes(key)),\n    },\n    /**\n     * this prop gives the option to add assistive text for screen readers for\n     *  the BaseSearch component.\n     * properties:\n     * **addFilter**: text/label used for add filter icon for mode `list`.\n     * **removeFilter**: text/label used for remove filter icon for mode `list`.\n     * **selectFilterLabel**: label (not visible) used for filter chips input field for mode `list`.\n     * **searchLabel**: label (not visible) used for search input field.\n     * **selectedOption**: text read when a selected option is focused (currently only\n     *  working for type chips with autocomplete (=freetext_allowed))\n     * **loaderActive**: text that is announced when autocomplete results are being fetched (prop\n     *  `isLoading` is set `true`)\n     * **autocompleteResultsRetrieved**: text announced when autocomplete results are returned.\n     *  use {optionsNumber} and {collectionsNumber} in the string to announce the number of\n     *  total options and collections found respectively.\n     * **autocompleteNoResults**: Text announced when no results were found with a given\n     *  search string.\n     * **autocompleteInitial**: Text announced when no search string was provided for\n     *  autocomplete.\n     * **categoryAnnouncement**: Text announced when a new category is entered in the\n     *  autocomplete drop down options list with keyboard navigation. string '{label}' will\n     *  be replaced by the actual specified category label\n     * **optionsAnnouncement**: announced together with category when in category selection\n     *  mode (after using arrowLeft key on autocomplete input) - to give the user a feeling\n     *  how many options were found for the announced category. string '{number}' will be\n     *  replaced by the number of entries in that category.\n     * **autocompleteOptionFilledToForm**: text announced when an option was selected from the autocomplete\n     *  dropdown, and it is filled into the respective form field. (only for mode `form`)\n     * **advancedButtonDescription**: button description for Advanced Search Toggle button for mode `form`.\n     *      For accessibility purposes. You may add the string {state} which will be replaced with the respective\n     *      'open' and 'close' value specified in `formState` (see below). Only relevant for mode `form`.\n     * **formState**: an object with properties `open` (text that is read when form is closed and button\n     *      functionality is to open the form) and `close` (text that is read when form is open and button\n     *      functionality is to close the form). Only relevant for mode `form`.\n     * **removeAllFiltersLabel**: label for the remove icon in the collapsed filter row.\n     *     Only relevant for mode `form`. For accessibility purposes\n     * **removeFilterValueNotification**: notification that is read by screen readers when a filter\n     *      value was removed. Add the string {value} to read the filter value that was removed and\n     *      {label} to read the label of the filter from which the value was removed. Only relevant for mode `form`.\n     * **collapsedFilterRowRemovedNotification**: notification read when the last filter was removed from\n     *      the collapsed filter row. Or remove row was clicked. Only relevant for mode `form`.\n     * **collapsedAppliedFiltersLabel**: description for the filters in the collapsed filter row.\n     *      Only relevant for mode `form`. For accessibility purposes.\n     * **collapsedBooleanFilterValue**: Set text that should be read for a boolean filter value. You may add\n     *      the string {label} which will be replaced by the filter label.\n     *      Only relevant for mode `form`. For accessibility purposes.\n     * **collapsedOptionToRemoveSelected**: text read when an option is focused (and thus selected), should\n     *  announce to the screen reader user that option can now be removed via Backspace or Delete.\n     * **results**: provide text that should be announced when the search has\n     *  yielded results (or not).\n     *\n     * Caveat: `results` has a watcher attached to trigger the\n     *    announcement so make sure the property values are reset after filling them\n     *    by using update:assistive-text or resetting it manually (after a timeout)\n     */\n    assistiveText: {\n      type: Object,\n      default: () => ({\n        addFilter: 'Add filter',\n        removeFilter: 'Remove filter',\n        selectFilterLabel: 'Select filter',\n        searchLabel: 'Search for Entries',\n        selectedOption: '',\n        autocompleteLoaderActive: 'loading options.',\n        autocompleteResultsRetrieved: '{optionsNumber} options found in {collectionsNumber} categories.',\n        autocompleteNoResults: 'No results found.',\n        autocompleteInitial: 'Please start typing to see suggestions.',\n        categoryAnnouncement: 'category {label}.',\n        optionsAnnouncement: '{number} options.',\n        autocompleteOptionFilledToForm: 'option {optionLabel} filled to field {fieldLabel}.',\n        advancedButtonDescription: 'Click to {state} advanced search form.',\n        formState: {\n          open: 'open',\n          close: 'close',\n        },\n        removeAllFiltersLabel: 'Remove all filters.',\n        removeFilterValueNotification: 'Filter value {value} was removed from filter {label}.',\n        collapsedFilterRowRemovedNotification: 'All search filters were reset.',\n        collapsedAppliedFiltersLabel: 'Currently applied Filters',\n        collapsedBooleanFilterValue: 'Filter {label} was set',\n        collapsedOptionToRemoveSelected: 'Press delete or backspace to remove.',\n        results: '',\n      }),\n    },\n    /**\n     * if desired the box shadow around the search rows can be deactivated here\n     */\n    applyBoxShadow: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * use this prop to set a delay in ms before date input calendar is displayed\n     */\n    dateFieldDelay: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * prop only relevant for mode `form`\n     * set advanced search (form) visibility from outside\n     * this can also be used to not show the advanced search after initial loading\n     */\n    advancedFormOpen: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * set this flag to `true` to highlight autocomplete option characters that match\n     *  the current search input string\n     */\n    highlightAutocompleteMatch: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `highlightAutocompleteMatch` is set `true`\n     *  provide tag names to style the matched characters\n     *  (without '<' and '>', e.g. ['b'] for <b>)\n     */\n    highlightAutocompleteTags: {\n      type: Array,\n      default: () => ([]),\n    },\n    /**\n     * mode `form`: if necessary selected chip text can  be rendered as v-html directive\n     *  either set this prop `true` or `false`\n     *\n     * this will only be applied to chips with an identifier property and of course\n     *   can only apply to form field field_type `chips`\n     *\n     * if only chips of certain form fields should be rendered as html use prop\n     *  `formProps.fieldProps.interpretChipsLabelAsHtml` or if certain fields should\n     *  be excluded set this prop to `true` and set `formProps.fieldProps.interpretChipsLabelAsHtml`\n     *  for that field `false`\n     */\n    interpretFormChipsLabelAsHtml: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  emits: ['search', 'fetch-autocomplete', 'fetch-form-autocomplete', 'update:applied-filters', 'update:form-filter-values', 'update:advanced-form-open'],\n  setup() {\n    /**\n     * set up a reference to the element to be able to attach the announcements element\n     * @type {Ref<UnwrapRef<null|HTMLElement>>}\n     */\n    const searchContainer = ref(null);\n    /**\n     * insert an HTML element with aria-live assertive that will announce the\n     * search result\n     * @type {Ref<UnwrapRef<string>>}\n     */\n    const { announcement } = useAnnouncer(searchContainer);\n    return {\n      searchContainer,\n      announcement,\n    };\n  },\n  data() {\n    return {\n      /**\n       * internal variable to handle applied filters also when set from outside\n       * @type {Filter[]}\n       */\n      appliedFiltersInt: [],\n      /**\n       * the filter used in the main search field - not added to applied filters yet\n       * @type {Filter}\n       */\n      mainFilter: null,\n      /**\n       * store the autocomplete results for each filter in this variable to have\n       * it available even when other filter was used in the meantime\n       * @type {Object[]}\n       */\n      filtersAutocompleteResults: [],\n      /**\n       * a variable storing the info for which filter autocomplete results were\n       * requested\n       * @type {number}\n       */\n      autocompleteIndex: -1,\n      originalMainFilter: null,\n      /**\n       * variable to control showing of advanced search form in mode 'form'\n       * @type {boolean}\n       */\n      formOpen: true,\n      /**\n       * internal representation of formFilterValues in order to be able to modify\n       * @type {Object}\n       */\n      formFilterValuesInt: {},\n      /**\n       * store filter values to see if filter values changed before triggering search\n       * @type {Object}\n       */\n      originalFilterValues: null,\n      /**\n       * render BaseForm with delay to reduce flickering and flinching\n       * @type {boolean}\n       */\n      formMounted: false,\n      /**\n       * resize observer for specific element (instead of window)\n       * (only mode `form`)\n       */\n      resizeObserver: null,\n      /**\n       * button text should only be shown if enough space is available\n       * (only mode `form`)\n       */\n      showAdvancedSearchButtonText: true,\n      /**\n       * variable to contain assistive text to inform user of actions\n       * @type {string}\n       */\n      assistiveTextNotification: '',\n    };\n  },\n  computed: {\n    amendedFormProps() {\n      // if the prop is false - don't bother any further and just return\n      // the formProps as is\n      if (!this.interpretFormChipsLabelAsHtml) {\n        return this.formProps;\n      }\n      // else get the fieldProps out of formProps\n      const fieldProps = this.formProps.fieldProps || {};\n      // now iterate over the fields and add (or overwrite) the `interpretChipsLabelAsHtml`\n      // prop\n      const updatedFormFieldProps = this.renderFormChipsLabelAsHtml.reduce((prev, renderProp) => ({\n        ...prev,\n        ...this.addNewPropertyValueToNestedObject(\n          renderProp,\n          fieldProps || {},\n          'interpretChipsLabelAsHtml',\n          true,\n          // individually set fields should always have priority\n          // over `interpretFormChipsLabelAsHtml`\n          false,\n        ),\n      }), {});\n\n      return {\n        // add all other specified form props\n        ...this.formProps,\n        // and the modified fieldprops\n        fieldProps: {\n          // also don't lose the field props of non-chips fields or not\n          // modified ones\n          ...fieldProps,\n          // and add the modified ones\n          ...updatedFormFieldProps,\n        },\n      };\n    },\n    /**\n     * store the loading state of every filter\n     *\n     * @returns {boolean[]}\n     */\n    filtersLoadingState() {\n      return [\n        ...this.appliedFiltersInt\n          .map((filter, index) => (this.autocompleteIndex === index)),\n        // add one at the end for main search field (not added to applied filters array yet)\n        this.autocompleteIndex === this.appliedFiltersInt.length,\n      ];\n    },\n    /**\n     * the actually displayed filter categories (visible in the filter drop down for mode 'list')\n     * @returns {Filter[]}\n     */\n    displayedFilters() {\n      // filter filters with property hidden true\n      const displayed = [...this.filterList].filter(f => !f.hidden);\n      // sort them\n      return sort(displayed, this.labelPropertyName.filter);\n    },\n    /**\n     * main filter is always added to the emitted filter array last to maintain same order\n     *  to what is rendered (main filter lowest) so we need to get the last filter index\n     * @returns {number}\n     */\n    mainFilterIndex() {\n      const lastFilterIndex = this.appliedFilters.length - 1;\n      return lastFilterIndex > 0 ? lastFilterIndex : 0;\n    },\n    /**\n     * transform values to collapsed form and back\n     */\n    collapsedFiltersArray: {\n      /**\n       * use formFieldValuesInt to create the correct structure for BaseCollapsedFilterRow\n       * @returns {{\n         *  filter_values: { values: Object[], fieldType: string, fieldId: string },\n         *  label: string,\n         *  id: string,\n       *  }[]}\n       */\n      get() {\n        return Object.entries(this.formFilterValuesInt)\n          // only use filters that have values\n          .filter(([, value]) => hasData(value))\n          // sort the values in the order of the form so the collapsed display has the same order\n          .sort(([key1], [key2]) => {\n            if (this.formFilterList[key1] && this.formFilterList[key2]\n                && this.formFilterList[key1]['x-attrs'].order > this.formFilterList[key2]['x-attrs'].order) {\n              return 1;\n            }\n            return -1;\n          })\n          // map data to collapsed filter array structure\n          .map(([key, value]) => {\n            // get the OpenAPI json field information for the field in question\n            const formFilterData = this.formFilterList[key];\n            // check here if field is repeatable\n            const isRepeatableField = formFilterData.type === 'array' && !formFilterData['x-attrs'].field_type.includes('chips');\n            // if value list is not already an array (because it is a repeatable field) make it an array\n            const valueList = isRepeatableField ? value : [value];\n            return valueList.map((repeatableEntry, index) => ({\n              // label that will be displayed on top of each collapsed filter\n              labelInternal: formFilterData.title,\n              // add a special id that allows to identify repeatable fields (applied in reverse mapping\n              // ~line 555)\n              idInternal: `${key}${isRepeatableField ? `-group-${index}` : ''}`,\n              // the actual filter values and filter information for each field (important for field groups)\n              filter_values: this.getCollapsedFilterValue(repeatableEntry, formFilterData, key),\n            }));\n          })\n          .flat();\n      },\n      /**\n       * maps changes that were made to collapsed filters back to formFilterValuesInt\n       * @param {{ filter_values: Object[]|Object[[]], label: string, id: string, type: string|string[] }[]} val - changed collapsed filter values\n       */\n      set(val) {\n        // loop through every collapsed filter array value and create a form filter values compatible\n        // object structure out of it again\n        this.formFilterValuesInt = val.reduce((prev, filter) => {\n          // necessary because of field groups to remove index (added in line 538) from id\n          // get actual field id and indicator if field was repeatable field\n          const [, filterId, groupMatch] = filter.idInternal.match(/(.*?)(-group-\\d*)?$/);\n          // get the form field data for the id\n          const filterData = this.formFilterList[filterId];\n          // get the correctly mapped filter values\n          const filterValues = this.setFormFilterValues(filter.filter_values, filterData);\n          // if field is repeatable - check if there are already values field into the object property\n          // if yes store them in a value to be able to concat or use an empty array\n          const previousValues = groupMatch && prev && prev[filterId] ? prev[filterId] : [];\n          return {\n            ...prev,\n            // if field is repeatable join the previous values with the new values otherwise just\n            // set currently retrieved values\n            [filterId]: groupMatch ? previousValues.concat(filterValues) : filterValues,\n          };\n        }, {});\n        // trigger search after filters changed\n        this.search();\n      },\n    },\n    renderFormChipsLabelAsHtml() {\n      // first get all form field props\n      const { fieldProps } = this.formProps;\n      // if no fieldProps were specified just use the prop value\n      if (!fieldProps) return this.interpretFormChipsLabelAsHtml;\n      // else we need to check if prop `renderChipsLabelAsHtml` was specified for\n      // a chips input field - done via recursive (because of subforms) function\n      const fieldsToSetTrue = this.filterHtmlRenderFields(this.formFilterList);\n\n      // check if values were set for individual fields, otherwise fall back\n      // to the prop value\n      return fieldsToSetTrue.length ? fieldsToSetTrue : this.interpretFormChipsLabelAsHtml;\n    },\n    /**\n     * create an internal row id for unique identification of added filter rows\n     *\n     * @returns {string}\n     */\n    rowId() {\n      return createId();\n    },\n    /**\n     * advanced button description for mode `form`\n     * @returns {string}\n     */\n    advancedButtonDescription() {\n      // if value was not set for any reason just return an empty string\n      if (!this.assistiveText.advancedButtonDescription) return '';\n      return this.assistiveText.advancedButtonDescription\n        .replace('{state}', this.assistiveText.formState[this.formOpen ? 'close' : 'open']);\n    },\n  },\n  watch: {\n    /**\n     * watch prop autocompleteResults to assign it to the correct filter row\n     */\n    autocompleteResults(val) {\n      // check if autocomplete is active for any field ( > -1 )\n      if (this.autocompleteIndex >= 0) {\n        // if yes set the results on the filter row active\n        this.$set(this.filtersAutocompleteResults, this.autocompleteIndex, [...val]);\n        this.autocompleteIndex = -1;\n      }\n    },\n    /**\n     * have appliedFilters in sync with parent to be able to set them from outside\n     */\n    appliedFiltersInt: {\n      handler(val) {\n        // check if val is actually different from prop value\n        if (JSON.stringify(val) !== JSON.stringify(this.appliedFilters.slice(1))) {\n          // if yes - inform parent\n          this.$emit('update:applied-filters', [...val, this.mainFilter]);\n        }\n      },\n      deep: true,\n    },\n    /**\n     * have appliedFilters in sync with parent to be able to set them from outside\n     */\n    appliedFilters: {\n      handler(val) {\n        // check if value is different from internal value\n        if (val\n          && JSON.stringify(val.slice(0, -1)) !== JSON.stringify(this.appliedFiltersInt)) {\n          // if yes - update internal value\n          [, ...this.appliedFiltersInt] = JSON.parse(JSON\n            .stringify([val, ...val.slice(0, -1)]));\n        }\n        // also check if main filter is different separately!\n        if (val && val.length >= 1\n          && JSON.stringify(this.mainFilter) !== JSON.stringify(val[this.mainFilterIndex])) {\n          [this.mainFilter] = JSON.parse(JSON.stringify(val.slice(-1)));\n        } else if (!val || val < 1) {\n          this.mainFilter = { ...this.defaultFilter };\n        }\n      },\n      immediate: true,\n    },\n    /**\n     * watch main filter since changes are not directly handled via update:applied-filters\n     * event and trigger search if anything changed\n     * @param {Filter} val - the updated main filter\n     */\n    mainFilter(val) {\n      // make sure mainFilter exists and has property filter_values\n      if (val && val.filter_values) {\n        // store values to compare in variables\n        const mainFilterHasData = hasData(val.filter_values);\n        // for original filter also check right here if property filter_values actually\n        // exists\n        const originalMainFilterHasData = !!this.originalMainFilter\n          && !!this.originalMainFilter.filter_values\n          && hasData(this.originalMainFilter.filter_values);\n        // now check a) if originalMainFilter exists already and\n        // b) filter itself has switched (and there are actually data to search for)\n        // c) original data and current data diverge (only one of them does not have data)\n        // d) or both have data but data are different from each other\n        if (this.originalMainFilter\n          && ((mainFilterHasData && this.originalMainFilter[this.identifierPropertyName.filter]\n            !== val[this.identifierPropertyName.filter])\n          || mainFilterHasData !== originalMainFilterHasData\n          || (mainFilterHasData && originalMainFilterHasData\n          && (JSON.stringify(this.originalMainFilter.filter_values\n              !== JSON.stringify(val.filter_values)))))) {\n          // if so - update original data\n          this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n          // and trigger search\n          this.search(true);\n        }\n      }\n      /**\n       * inform parent of changes in applied filters - event emitted for mode `list`\n       *\n       * @event update:applied-filters\n       * @param {Filter[]} - the list of updated applied filters\n       */\n      this.$emit('update:applied-filters', [...this.appliedFiltersInt, val]);\n      // also emit updated form filter values at this point\n      this.$emit('update:form-filter-values', { ...this.formFilterValuesInt, default: this.mainFilter.filter_values });\n    },\n    /**\n     * have formFilterValues in sync with parent to be able to set them from outside\n     */\n    formFilterValuesInt: {\n      handler(val) {\n        // get filters without default first to ensure comparability\n        const filtersWithoutDefault = { ...this.formFilterValues };\n        this.$delete(filtersWithoutDefault, 'default');\n        // check if val is actually different from prop value\n        if (JSON.stringify(val) !== JSON.stringify(filtersWithoutDefault)) {\n          // if yes - inform parent\n          /**\n           * inform parent of form filter value changes - event emitted for mode `form`\n           * @event update:form-filter-values\n           * @param {Object} - a form filter values object with a property for each filter field - main filter values\n           *  are available under the default property\n           *\n           */\n          this.$emit('update:form-filter-values', { ...val, default: this.mainFilter.filter_values });\n        }\n      },\n      deep: true,\n    },\n    /**\n     * have formFilterValues in sync with parent to be able to set them from outside\n     */\n    formFilterValues: {\n      handler(val) {\n        if (this.mode === 'form') {\n          // check if value is different from internal value\n          if (val\n            && JSON.stringify(val) !== JSON.stringify({\n              ...this.formFilterValuesInt,\n              default: this.mainFilter.filter_values,\n            })) {\n            // remove the default key from the form filter values that should fill form\n            const { default: _, ...filterValuesNoMain } = val;\n            // update internal values\n            this.formFilterValuesInt = JSON.parse(JSON.stringify(filterValuesNoMain));\n            // set default property to mainFilter.filter_values\n            this.$set(this.mainFilter, 'filter_values', val.default || ['']);\n            // trigger search with updated values\n            this.search();\n          }\n        }\n      },\n      immediate: true,\n    },\n    advancedFormOpen: {\n      handler(val) {\n        this.formOpen = val;\n      },\n      immediate: true,\n    },\n    formOpen(val) {\n      /**\n       * in mode `form` when 'advanced search' button was clicked\n       * @event update:advanced-form-open\n       * @type {boolean}\n       */\n      this.$emit('update:advanced-form-open', val);\n    },\n    /**\n     * function to automatically reset the assistiveTextNotification\n     * after using it\n     * @param {string} val\n     */\n    assistiveTextNotification(val) {\n      // setting the value will trigger the screenreader\n      if (val) {\n        setTimeout(() => {\n          // after that text can be removed again\n          this.assistiveTextNotification = '';\n        }, 300);\n      }\n    },\n  },\n  created() {\n    // check if mainFilter was already set (e.g. from outside)\n    if (!this.mainFilter) {\n      // if not set default filter\n      this.mainFilter = JSON.parse(JSON.stringify(this.defaultFilter));\n    }\n    // copy these filter values to later be able to determine if filters changed before\n    // triggering search\n    this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n  },\n  mounted() {\n    // only add observer for mode `form`\n    if (this.mode === 'form') {\n      // to listen to element with instead of window width create an observer!\n      this.initObserver();\n    }\n  },\n  beforeDestroy() {\n    if (this.resizeObserver) this.resizeObserver.unobserve(this.$refs.searchContainer);\n  },\n  methods: {\n    extractNestedPropertyValue,\n    /**\n     * GENERAL FUNCTIONALITIES\n     */\n\n    /**\n     * initialize resize observer to steer advanced search button appearance\n     */\n    initObserver() {\n      const resizeObserver = new ResizeObserver(debounce(50, ([container]) => {\n        this.showAdvancedSearchButtonText = container.contentRect.width >= 460;\n      }));\n      resizeObserver.observe(this.$refs.searchContainer);\n      this.resizeObserver = resizeObserver;\n    },\n    /**\n     * @param {string} input - the search string to autocomplete\n     * @param {Filter} filter - the filter the autocomplete was triggered for\n     * @param {number} index - the index of the filter\n     */\n    fetchAutocomplete({ input, filter }, index) {\n      if (input) {\n        // if input string present set autocomplete variable to correct filter row\n        this.autocompleteIndex = index;\n      } else {\n        // else reset the autocomplete results\n        this.$set(this.filtersAutocompleteResults, index, []);\n      }\n      // stil emit fetch-autocomplete no matter if input string present or not to give\n      // parent opportunity to also update\n      /**\n       * inform parent to fetch autocomplete data for the provided filter\n       *\n       * @event fetch-autocomplete\n       * @type {Object} - object with the following properties:\n       * @property {string} searchString - the string to autocomplete\n       * @property {Filter} filter - the filter object\n       * @property {number} index - the filter index of all filters (main and applied)\n       */\n      this.$emit('fetch-autocomplete', { searchString: input, filter, index });\n    },\n    /**\n     * search function\n     * @param {boolean} alwaysTrigger - set true if search should be triggered irrespective of\n     *  appliedFiltersInt changes (needed for changes in mainFilter which is checked in the\n     *  mainFilter watcher already)\n     */\n    search(alwaysTrigger = false) {\n      // get the correct filter values list according to component mode\n      const modeFilterList = this.mode === 'form' ? this.formFilterList : this.filterList;\n      // define variable to store modified filters list to be emitted\n      let searchFilterList = [];\n      if (this.mode === 'form') {\n        searchFilterList = Object.entries(this.formFilterValuesInt)\n          // also only keep the filters that have filter values\n          .filter(([, filterValues]) => hasData(filterValues))\n          .map(([filterKey, filterValues]) => ({\n            [this.identifierPropertyName.filter]: filterKey,\n            type: modeFilterList[filterKey]?.['x-attrs']?.field_type ?? 'text',\n            // only keep filter values that actually have values (relevant for groups!)\n            filter_values: typeof filterValues === 'object' && filterValues.length\n            && !modeFilterList[filterKey]?.type.includes('chips')\n              ? filterValues.filter(filterValue => hasData(filterValue)) : filterValues,\n          }));\n      } else {\n        searchFilterList = this.appliedFiltersInt\n          // and only keep the properties relevant for search\n          // eslint-disable-next-line camelcase\n          .map(filter => ({\n            [this.identifierPropertyName.filter]: filter[this.identifierPropertyName.filter],\n            type: filter.type,\n            filter_values: filter.filter_values,\n          }));\n      }\n      // if there are changes in filters or main filter trigger search (=if alwaysTrigger was\n      // set true in mainFilter watcher)\n      if (alwaysTrigger || JSON.stringify(this.originalFilterValues) !== JSON\n        .stringify(searchFilterList)) {\n        // update the original value\n        this.originalFilterValues = JSON.parse(JSON.stringify(searchFilterList));\n        // also minimize main filter\n        const minMainFilter = {\n          [this.identifierPropertyName.filter]: this.mainFilter[this.identifierPropertyName.filter],\n          type: this.mainFilter.type,\n          filter_values: this.mainFilter.filter_values,\n        };\n        /**\n         * inform parent that search should be triggered\n         *\n         * @event search\n         * @param {Filter[]} - the updated list of applied filters - last filter in the list is always the main\n         *  filter (relevant especially for mode `form`)\n         */\n        this.$emit('search', [...searchFilterList, minMainFilter]);\n      }\n    },\n    /**\n     * MODE 'LIST' FUNCTIONALITIES\n     */\n\n    /**\n     * function to add a filter row after '+' icon was triggered\n     */\n    addFilterRow({ filter, input }) {\n      // first handle remaining input and add it to filter values if necessary\n      // therefore have separate variable and assign the original values first (in case no\n      // modifications are necessary)\n      let newFilterValues = filter.type.includes('date') ? filter.filter_values\n        : [...filter.filter_values];\n      // have variable for search trigger in case additional values are added and should trigger\n      // search\n      let triggerSearch = false;\n      // now check if type is text and the current value saved in filter does not equal text input\n      if (filter.type === 'text' && input.trim() && (!filter.filter_values || !filter.filter_values.length\n        || this.mainFilter.filter_values[0] !== input.trim())) {\n        // in that case assign new value and set search trigger true\n        newFilterValues = [input];\n        triggerSearch = true;\n        // else if type is freetext chips add the value at the end of the array\n      } else if (filter.type === 'chips' && filter.freetext_allowed && input.trim()) {\n        newFilterValues = [\n          ...filter.filter_values,\n          {\n            [this.labelPropertyName.autocompleteOption]: input,\n          },\n        ];\n        // also here triger search after\n        triggerSearch = true;\n      }\n      // now finally add filter to internal filter list\n      this.appliedFiltersInt.push({\n        ...filter,\n        filter_values: newFilterValues,\n      });\n      // and reset the main filter\n      this.mainFilter = {\n        ...this.defaultFilter,\n        filter_values: null,\n      };\n      // and store the main filter to compare to later\n      this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n      // now check if search should be triggered\n      if (triggerSearch) {\n        this.search();\n      }\n      // now focus new added row search input but wait until it is rendered\n      this.$nextTick(() => {\n        // get the correct field from all input fields of that element\n        const newSearchInputField = Array.from(this.$refs.mainSearch.$el\n          .getElementsByTagName('input'))\n          .find(element => element.id.includes('search-input'));\n        newSearchInputField.focus();\n      });\n    },\n    /**\n     * remove filter after 'x' was triggered\n     * @param {Filter} filter - the filter to remove\n     * @param {number} index - the index of the filter\n     */\n    removeFilter(filter, index) {\n      this.appliedFiltersInt.splice(index, 1);\n      // trigger search to update search results\n      this.search();\n    },\n    /**\n     * for mode 'list'\n     * function called when a filter object within a filter row changes\n     * @param {Filter} filter - the filter that was altered\n     * @param {number} index - the index of the filter\n     */\n    updateFilter(filter, index) {\n      this.$set(this.appliedFiltersInt, index, JSON.parse(JSON.stringify(filter)));\n      // trigger search to update search results\n      this.search();\n    },\n\n    /**\n     * MODE 'FORM' FUNCTIONALITIES\n     */\n\n    /**\n     * function called when an option was selected from main search autocomplete OR on\n     *  search input TAB keydown\n     *\n     * @param {Object} entry - the selected option\n     * @param {string} collectionId - the option category selected - this needs to match a\n     *  formFilter id\n     */\n    fillOptionToForm({ entry, collectionId }) {\n      // check if mode is form and if collection id is present\n      // (otherwise value is default filter string input)\n      if (this.mode === 'form' && collectionId\n        // and if option is already included in the selected options to prevent double key problems\n        && !this.formFilterValuesInt[collectionId]\n          ?.map(selectedOption => selectedOption[this.identifierPropertyName.formInputs])\n          .includes(entry[this.identifierPropertyName.autocompleteOption])) {\n        // get the filter field information if there is any\n        const fieldInformation = this.formFilterList[collectionId];\n        // check if there is actual field information --> default filter is not part of\n        // swagger list! so all but default filter will go here!\n        if (fieldInformation) {\n          const fieldXAttrs = fieldInformation['x-attrs'];\n          // check the type of field that the value should be added to (we assume the only possibilities\n          // are chips or text - other types are currently NOT implemented and would need to be added here!)\n          if (fieldXAttrs.field_type === 'chips') {\n            // in order to be able to set the correct properties for the chip display in the input field\n            // we might need to map the label and id properties of the autocomplete option to the label and\n            // id properties of the input field - since an individual option for a field might have been\n            // set via fieldProps - we need to check for that first\n            const fieldProps = this.formProps.fieldProps?.[collectionId] || {};\n            // check if label prop was set otherwise use the default form input one\n            const labelProp = fieldProps.labelPropertyName\n              || this.labelPropertyName.formInputs;\n            // check if id prop was set otherwise use the default form input one\n            const idProp = fieldProps.identifierPropertyName\n              || this.identifierPropertyName.formInputs;\n            // map the information from the search autocomplete to the chips form field\n            // required values\n            const chipsFormFieldValue = {\n              // map search autocomplete result to chips form field required values\n              [labelProp]: entry[this.labelPropertyName.autocompleteOption],\n              [idProp]: entry[this.identifierPropertyName.autocompleteOption],\n              // HOWEVER - in order to enable customization of the properties used in the front\n              // end - e.g. to add discriminatory terms html we also leave the rest of the\n              // object properties and actually give them PRIORITY over the newly created ones!\n              // (so e.g. if the property `displayLabel` was already added to the autocomplete option\n              // with the appropriate tags and styling then this will not be overwritten by\n              // entry[this.labelPropertyName.autocompleteOption] but be retained\n              ...entry,\n            };\n            // for multi chips - add value to array\n            if (fieldInformation.type === 'array') {\n              // check if property exists already in formFilterValuesInt\n              if (this.formFilterValuesInt[collectionId]) {\n                this.formFilterValuesInt[collectionId].push(chipsFormFieldValue);\n              } else {\n                this.$set(this.formFilterValuesInt, collectionId, [chipsFormFieldValue]);\n              }\n              // for single chips - replace value\n            } else if (fieldInformation.type === 'object') {\n              this.$set(this.formFilterValuesInt, collectionId, chipsFormFieldValue);\n            }\n          } else if (!fieldXAttrs || fieldXAttrs.field_type === 'text') {\n            this.$set(\n              this.formFilterValuesInt,\n              collectionId,\n              entry[this.labelPropertyName.autocompleteOption] ?? entry,\n            );\n          }\n          // main filter filter values should remain empty\n          this.mainFilter.filter_values = [];\n          // announce to screen reader user that field was added to advanced search form\n          // if the appropriate text was set\n          if (this.assistiveText.autocompleteOptionFilledToForm) {\n            // get option label from entry param\n            const optionLabel = entry[this.labelPropertyName.autocompleteOption];\n            // and field label from fieldInformation\n            const fieldLabel = fieldInformation.title;\n            // assemble announcement\n            this.announcement = this.assistiveText.autocompleteOptionFilledToForm\n              .replace('{optionLabel}', optionLabel)\n              .replace('{fieldLabel}', fieldLabel);\n          }\n\n          // this does not trigger an update event from BaseForm so search needs to be triggered manually here\n          this.search();\n        } else {\n          // if it is main filter set the value to main filter instead\n          this.$set(\n            this.mainFilter,\n            'filter_values',\n            [entry],\n          );\n          // and also update original filter with newly set data\n          this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n          // this does not trigger an update event from BaseForm so search needs to be triggered manually here\n          // since main filter is not evaluated in filter comparison set alwaysTrigger true\n          this.search(true);\n        }\n      }\n    },\n    /**\n     * function called from form if one of the form fields needs autocomplete\n     *\n     * @param {Object} params - see event for object properties sent to parent\n     */\n    fetchFormAutocomplete(params) {\n      /**\n       * event emitted when a form drop down (e.g. chips input field) needs autocomplete\n       *\n       * @event fetch-form-autocomplete\n       *\n       * @property {string} value - the string to autocomplete\n       * @property {string} name - the name of the field\n       * @property {string} source - the url to request the data from\n       * @property {?string} equivalent - string specified for related fields. e.g. for contributor roles equivalent is `contributor`\n       * @property {?string[]} parentFields - in case the autocomplete event originates from a subform the subform id's (field property names) are specified in this array (most nested property last)\n       */\n      this.$emit('fetch-form-autocomplete', params);\n    },\n    /**\n     * for mode 'form'\n     * update the form filters when an event is received from form that values have changed\n     * @param {Object} newFilterValueList - the new filter values object\n     */\n    updateFormFilters(newFilterValueList) {\n      this.formFilterValuesInt = JSON.parse(JSON.stringify(newFilterValueList));\n      this.search();\n    },\n    /**\n     * function called by BaseCollapsedFilter row if 'x' was clicked to remove all filters\n     */\n    removeAllFilters() {\n      // reset form filter values\n      this.formFilterValuesInt = {};\n      this.assistiveTextNotification = this.assistiveText.collapsedFilterRowRemovedNotification || '';\n      // trigger search without filters\n      this.search();\n    },\n    /**\n     * reduce the flickering and flinching from base form fields rendering by\n     *  only making the element visible after component mount and additionally\n     *  apply a timeout\n     */\n    formIsMounted() {\n      setTimeout(() => {\n        this.formMounted = true;\n      }, 200);\n    },\n    /**\n     * function triggered when 'advanced search' button is clicked in 'form' mode\n     */\n    openAdvancedSearch() {\n      // close the main search autocomplete drop down since this is not in user focus\n      // anymore\n      this.$refs.mainSearch.isActive = false;\n      // toggle form\n      this.formOpen = !this.formOpen;\n    },\n    /**\n     * function to retrieve the filter values in reduced form the way CollapsedFilterRow needs them\n     * @param {any} values - the form field values\n     * @param {Object} fieldData - the OpenAPI json field information\n     * @param {string} fieldId - the id of the field to transform\n     * @param {string[]} parentFields - if field is a field group we also need the parent field name(s)\n     *  (in theory there could be many but BaseAdvancedSearch is currently only supporting one nesting level)\n     * @returns {[string, unknown]|[{label: string}]|string|{label: *}[]|boolean[]|[{label: (string|string)}]|*}\n     */\n    getCollapsedFilterValue(values, fieldData, fieldId, parentFields = []) {\n      const fieldType = fieldData['x-attrs'].field_type;\n      if (fieldType === 'integer' || fieldType === 'float' || typeof values === 'number') {\n        return {\n          values: [{\n            labelInternal: values.toString(),\n          }],\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'boolean' || typeof values === 'boolean') {\n        return {\n          values: [{\n            labelInternal: values,\n          }],\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'text' || fieldType === 'autocomplete' || typeof values === 'string') {\n        let formattedLabel = values;\n        if (fieldType === 'date' && values) {\n          // if type is date we need to parse the storage date to display values also considering\n          // possible minus\n          formattedLabel = this.formatToDisplayDate(values);\n        }\n        return {\n          values: [{\n            // if fieldType is date convert to de date locale for display\n            labelInternal: formattedLabel,\n          }],\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'chips') {\n        // check if general property names were overwritten for the specific field\n        const fieldProps = extractNestedPropertyValue(\n          parentFields.length ? [fieldId].concat(parentFields).join('.') : fieldId,\n          this.formProps.fieldProps,\n        );\n        const labelProp = fieldProps?.labelPropertyName\n          || this.labelPropertyName.formInputs;\n        const idProp = fieldProps?.identifierPropertyName\n          || this.identifierPropertyName.formInputs;\n        return {\n          values: values.map((chipValue) => {\n            // do not delete additional properties the chip might have\n            const additionalProperties = typeof chipValue === 'object' ? chipValue : {};\n            return ({\n              labelInternal: chipValue[labelProp] ?? chipValue,\n              idInternal: chipValue[idProp] || '',\n              ...additionalProperties,\n            });\n          }),\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'group') {\n        return {\n          values: Object.entries(values)\n            .reduce((prev, [fieldKey, fieldValue]) => {\n              // add an array for each field in the group\n              prev.push(this.getCollapsedFilterValue(\n                fieldValue,\n                // depending if group is repeatable or not get to properties attribute\n                fieldData.items ? fieldData.items.properties[fieldKey] : fieldData.properties[fieldKey],\n                fieldKey,\n                [fieldKey].concat(parentFields),\n              ));\n              return prev;\n            }, []),\n          fieldType,\n          fieldId,\n        };\n      }\n      // any date or time range field\n      if (fieldType === 'date' && typeof values !== 'string') {\n        return {\n          values: Object.values(values)\n            .map(chipValue => ({\n              // convert to de date locale for display\n              labelInternal: chipValue ? this.formatToDisplayDate(chipValue) : '',\n            })),\n          fieldId,\n          // BaseCollapsedRow needs information if date is type daterange, timerange or datetime\n          // so alter to 'date' and 'time' for daterange and timerange respectively and 'datetime'\n          // for datetime.\n          fieldType: Object.keys(values).reduce((prev, key) => {\n            const currentType = key.split('_')[0];\n            return currentType !== prev ? prev + currentType : prev;\n          }, ''),\n        };\n      }\n      // NOT COVERED: multiline and chips below\n      return values;\n    },\n    formatToDisplayDate(storageDate) {\n      const { groups: { minus, year, month, day } = {} } = storageDate\n        .match(/((?<minus>-)?(?<year>\\d{4})-?(?<month>\\d{2})?-?(?<day>\\d{2})?)/) || {};\n      return year ? `${day ? `${day}.` : ''}${month ? `${month}.` : ''}${minus || ''}${year}` : '';\n    },\n    formatToStorageDate(storageDate) {\n      const { groups: { minus, year, month, day } = {} } = storageDate\n        .match(/(?<day>\\d{2})?\\.?(?<month>\\d{2})?\\.?(?<minus>-)?(?<year>\\d{4})/) || {};\n      return year ? `${minus || ''}${year}${month ? `-${month}` : ''}${day ? `-${day}` : ''}` : '';\n    },\n    /**\n     * function to transform collapsed values to form field values (necessary if something changed\n     * in collapsed values, e.g. a filter value was removed)\n     * @param {{ values: Object[], fieldId: string, fieldType: string }} collapsedValues - the updated collapsed\n     *  values coming from collapsed filter row\n     * @param {Object} filterData - the relevant OpenAPI form field information\n     * @param {string[]} parentFields - if field is a field group we also need the parent field name(s)\n     *  (in theory there could be many but BaseAdvancedSearch is currently only supporting one nesting level)\n     * @returns {any} - value returned depending on the filter type\n     */\n    setFormFilterValues(collapsedValues, filterData, parentFields = []) {\n      // get the relevant information out of collapsed values\n      const { values, fieldType, fieldId } = collapsedValues;\n      // case string\n      if (filterData.type === 'string') {\n        // special case date that needs to transform display to storage date format again\n        if (fieldType === 'date') {\n          return this.formatToStorageDate(values[0].labelInternal);\n        }\n        return values[0].labelInternal;\n      }\n      // case boolean value\n      if (filterData.type === 'boolean') {\n        return values[0].labelInternal;\n      }\n      // case number value\n      if (filterData.type === 'integer' || filterData.type === 'float') {\n        return Number(values[0].labelInternal);\n        // date could be string if it is just a single date or an object in all other cases\n      }\n      // case date field (not string)\n      if ((fieldType.includes('date') || fieldType.includes('time')) && filterData.type === 'object') {\n        const objectProperties = Object.keys(filterData.properties);\n        return values.reduce((valueObject, value, index) => ({\n          ...valueObject,\n          [objectProperties[index]]: this.formatToStorageDate(value.labelInternal),\n        }), {});\n      }\n      // case chips input field\n      if (fieldType.includes('chips')) {\n        // we need to take into consideration that custom label and identifier property names\n        // might have been set for a specific form field - so we need to check `formProps.fieldProps`\n        // (or the corresponding nested field for type 'group') for that field first and use these\n        // values if present\n        const fieldProps = extractNestedPropertyValue(\n          parentFields.length ? [fieldId].concat(parentFields).join('.') : fieldId,\n          this.formProps.fieldProps,\n        );\n        const labelProp = fieldProps?.labelPropertyName\n          || this.labelPropertyName.formInputs;\n        const idProp = fieldProps?.identifierPropertyName\n          || this.identifierPropertyName.formInputs;\n        return values.filter(filterValue => !!filterValue.labelInternal)\n          .map((filterValue) => {\n            // in order to keep any additional properties the chips entry might have, clone\n            // the object and remove internally added variables again\n            const additionalProperties = JSON.parse(JSON.stringify(filterValue));\n            this.$delete(additionalProperties, 'labelInternal');\n            this.$delete(additionalProperties, 'idInternal');\n            return ({\n              // and add it to the values that are returned\n              ...additionalProperties,\n              // apart from the labelProperty and the identifierProperty\n              [labelProp]: filterValue.labelInternal,\n              [idProp]: filterValue.idInternal,\n            });\n          });\n      }\n      // case repeatable fields where every repeated field or field group is a separate filter entry\n      if (!fieldType.includes('chips') && filterData.type === 'array') {\n        return this.setFormFilterValues(\n          collapsedValues,\n          filterData.items,\n        );\n      }\n      // case field groups\n      if (fieldType === 'group'\n        && filterData.type === 'object') {\n        return values\n          .filter(value => hasData(value.values))\n          .reduce((o, k) => ({\n            ...o,\n            [k.fieldId]: this.setFormFilterValues(\n              k,\n              filterData.properties[k.fieldId],\n              [k.fieldId].concat(parentFields),\n            ),\n          }), {});\n      }\n      return null;\n    },\n    filterHtmlRenderFields(formFieldInfo, parentFields = []) {\n      // get the field props needed later\n      const { fieldProps } = this.formProps;\n      // iterate over all form fields given in formFieldInfo\n      return Object.entries(formFieldInfo)\n        .reduce((prev, [key, values]) => {\n          // get the field type from the x attributes\n          const { field_type: fieldType } = values['x-attrs'] ? values['x-attrs'] : {};\n          // check if form fields are nested (subform)\n          if (fieldType === 'group') {\n            // and recursively iterate over these fields as well\n            const subFields = this.filterHtmlRenderFields(\n              values.properties || values.items.properties,\n              [key].concat(parentFields),\n            );\n            // if fields with `interpretChipsLabelAsHtml` `true` are found\n            // add them in the form { [key]: ['subField1', 'SubField2'] }\n            return subFields.length ? prev.concat({\n              [key]: subFields,\n            }) : prev;\n          }\n          // only add fields that are type chips\n          if (fieldType === 'chips') {\n            // get the fieldProps set for that specific field - if it is a nested field we\n            // need to extract them with the function below - else we can use fieldProps directly\n            const keyProps = ((parentFields.length\n              ? extractNestedPropertyValue(parentFields.join('.'), fieldProps) : fieldProps) || {})[key];\n            // now check if field key should be added to the list - 2 possibilities to add:\n            // a) prop `interpretFormChipsLabelAsHtml` is `false` - and the fieldProp for that specific\n            //  field is set\n            // b) prop `interpretFormChipsLabelAsHtml` was set `true` to cover all fields and\n            //  specifically exclude this one\n            if ((!this.interpretFormChipsLabelAsHtml && keyProps?.interpretChipsLabelAsHtml)\n              || (this.interpretFormChipsLabelAsHtml && (!keyProps\n                || !Object.keys(keyProps).includes('interpretChipsLabelAsHtml') || keyProps.interpretChipsLabelAsHtml))) {\n              return prev.concat(key);\n            }\n          }\n          // if any of the conditions fail just return the list unaltered\n          return prev;\n        }, []);\n    },\n    /**\n     * a function to add a new property to a nested object\n     *\n     * @param {string|Object} renderProp - this is either a string - then an object\n     *  with `previousFieldProps` and this property will be created, or an object in\n     *  the style of { [parentProperty]: ['childProp1', 'childProp2'] } - this object\n     *  can also be nested deeper - 'childProp2' could instead also be an object in the\n     *  style above again\n     * @param {Object} fieldProps - an object for all fields including `renderProp` that contains\n     *  other properties `renderProp` or [renderProp.key] should receive\n     *  so: { [renderProp]: { renderPropProperties } }\n     * @param {string} propertyName - the name of the property to be added or overwritten\n     * @param {*} propertyValue - the value of the property to be added or overwritten\n     * @param {boolean} [overwritePreviousValues=true] - define if a preexisting value for\n     *  `propertyName` should be overwritten\n     * @returns {{[p: string]: *}|{}} - returns an object in the style\n     *  { [renderProp|renderProp.key]: { ...previousFieldProps, [propertyName]: propertyValue }}\n     *  or a deeper nested version thereof\n     */\n    addNewPropertyValueToNestedObject(\n      renderProp,\n      fieldProps,\n      propertyName,\n      propertyValue,\n      overwritePreviousValues = false,\n    ) {\n      // check if renderProp is a string\n      if (typeof renderProp === 'string') {\n        const previousFieldProps = fieldProps[renderProp] || {};\n        return {\n          [renderProp]: {\n            // if previous values should be overwritten - place the add the previous\n            // object properties first\n            ...(overwritePreviousValues ? previousFieldProps : {}),\n            [propertyName]: propertyValue,\n            // otherwise add them after the new property\n            ...(!overwritePreviousValues ? previousFieldProps : {}),\n          },\n        };\n      }\n      if (typeof renderProp === 'object') {\n        return Object.entries(renderProp).reduce((prev, [renderPropKey, renderPropValues]) => ({\n          ...prev,\n          // add an object in the form of [formGroupPropertyName]: {},\n          [renderPropKey]: {\n            // add all the field props that have been defined for that form group fields\n            // previously\n            ...fieldProps[renderPropKey],\n            // then overwrite form group fields that are defined in the renderProp array\n            ...renderPropValues.reduce((prevObject, field) => ({\n              ...prevObject,\n              // add property to fieldProps of this field\n              ...this.addNewPropertyValueToNestedObject(\n                field,\n                fieldProps[renderPropKey] || {},\n                propertyName,\n                propertyValue,\n              ),\n            }), {}),\n          },\n        }), {});\n      }\n      return {};\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../../styles/variables\";\n\n.base-advanced-search {\n  .base-advanced-search__filter-row {\n    margin-bottom: $spacing;\n  }\n\n  .base-advanced-search__expand-button {\n    border-left: $separation-line;\n    margin-left: $spacing-small;\n    padding-right: $spacing-small;\n  }\n\n  .base-advanced-search__search-form {\n    border-top: $separation-line;\n\n    &.base-advanced-search__search-form--hidden {\n      display: none;\n    }\n  }\n}\n\n</style>\n"],"names":["_sfc_main","BaseAdvancedSearchRow","defineAsyncComponent","m","InsertTextAsHtml","val","v","prop","key","searchContainer","ref","announcement","useAnnouncer","fieldProps","updatedFormFieldProps","prev","renderProp","filter","index","displayed","f","sort","lastFilterIndex","value","hasData","key1","key2","formFilterData","isRepeatableField","repeatableEntry","filterId","groupMatch","filterData","filterValues","previousValues","fieldsToSetTrue","createId","mainFilterHasData","originalMainFilterHasData","filtersWithoutDefault","_","filterValuesNoMain","extractNestedPropertyValue","resizeObserver","debounce","container","input","alwaysTrigger","modeFilterList","searchFilterList","filterKey","_b","_a","_c","filterValue","minMainFilter","newFilterValues","triggerSearch","element","entry","collectionId","selectedOption","fieldInformation","fieldXAttrs","labelProp","idProp","chipsFormFieldValue","optionLabel","fieldLabel","params","newFilterValueList","values","fieldData","fieldId","parentFields","fieldType","formattedLabel","chipValue","additionalProperties","fieldKey","fieldValue","currentType","storageDate","minus","year","month","day","collapsedValues","objectProperties","valueObject","k","formFieldInfo","subFields","keyProps","propertyName","propertyValue","overwritePreviousValues","previousFieldProps","renderPropKey","renderPropValues","prevObject","field"],"mappings":"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"}