{"version":3,"file":"BaseCollapsedFilterRow.vue.cjs.js","sources":["../../../src/components/BaseAdvancedSearch/BaseCollapsedFilterRow.vue"],"sourcesContent":["<template>\n  <div\n    class=\"base-collapsed-filter-row\">\n    <!-- Container to add fade out effect -->\n    <div\n      ref=\"filterListContainer\"\n      :class=\"['base-collapsed-filter-row__filter-list-container',\n               {\n                 'base-collapsed-filter-row__filter-list-container__fade-right':\n                   filterFade.right,\n               },\n               {\n                 'base-collapsed-filter-row__filter-list-container__fade-left':\n                   filterFade.left,\n               }]\">\n      <!-- the actual list of filters -->\n      <ul\n        ref=\"filterList\"\n        :aria-description=\"assistiveText.appliedFiltersLabel\"\n        :class=\"[\n          'base-collapsed-filter-row__filter-list',\n          { 'base-collapsed-filter-row__filter-list__scrollable': filterListScrollable },\n          { 'base-collapsed-filter-row__filter-list__scrolling': isScrolling }\n        ]\"\n        @mousedown=\"mouseDownHandler\"\n        @touchstart=\"mouseDownHandler\">\n        <li\n          v-for=\"(filter, filterIndex) in filtersInt\"\n          :key=\"filter.idInternal\"\n          :aria-describedby=\"`${filter.idInternal}-label`\"\n          role=\"listitem\"\n          tabindex=\"0\"\n          :class=\"['base-collapsed-filter-row__filter',\n                   { 'base-collapsed-filter-row__filter__boolean': filter.filter_values\n                     .fieldType === 'boolean' }]\">\n          <template v-if=\"filter.filter_values && filterValuesHaveData(filter.filter_values.values)\">\n            <div\n              :id=\"`${filter.idInternal}-label`\"\n              class=\"base-collapsed-filter-row__filter-label\">\n              {{ filter.labelInternal }}\n            </div>\n            <!-- the chips for each filter -->\n            <ul\n              class=\"base-collapsed-filter-row__chips-list\">\n              <!-- iterate through the filter values list -->\n              <template\n                v-for=\"(value, valueIndex) in filter.filter_values?.values\">\n                <!-- check if filter.fieldType is an array to determine if it belongs to a field group -->\n                <template v-if=\"filter.filter_values.fieldType === 'group'\">\n                  <!-- if yes - also iterate through those values -->\n                  <template v-for=\"(groupValue, groupIndex) in value.values\">\n                    <BaseCollapsedFilterItem\n                      v-if=\"groupValue.labelInternal\"\n                      :key=\"groupValue.idInternal\n                        || `${groupValue.labelInternal}-${valueIndex}-${groupIndex}`\"\n                      :value=\"groupValue\"\n                      :type=\"value.fieldType\"\n                      :range-indicator=\"getRangeIndicator(value, groupIndex)\"\n                      :scrollable=\"filterListScrollable\"\n                      :is-scrolling=\"isScrolling\"\n                      :date-time-text=\"dateTimeText\"\n                      :interpret-label-as-html=\"(typeof interpretLabelAsHtml === 'boolean'\n                        && interpretLabelAsHtml) || (typeof interpretLabelAsHtml === 'object'\n                        && calcSubFormChipHtmlRender(filter.idInternal, value.fieldId))\"\n                      :assistive-text=\"{\n                        booleanFilterLabel: assistiveText.booleanFilterLabel\n                          ? assistiveText.booleanFilterLabel\n                            .replace('{label}', filter.labelInternal) : groupValue.labelInternal.toString(),\n                        optionToRemoveSelected: assistiveText.optionToRemoveSelected,\n                      }\"\n                      @remove-chip=\"removeChip(filterIndex, valueIndex, groupIndex)\" />\n                  </template>\n                </template>\n                <template v-else>\n                  <BaseCollapsedFilterItem\n                    v-if=\"value.labelInternal\"\n                    :key=\"value.idInternal || `${value.labelInternal}-${valueIndex}`\"\n                    :value=\"value\"\n                    :type=\"filter.filter_values.fieldType\"\n                    :range-indicator=\"getRangeIndicator(filter.filter_values, valueIndex)\"\n                    :scrollable=\"filterListScrollable\"\n                    :is-scrolling=\"isScrolling\"\n                    :date-time-text=\"dateTimeText\"\n                    :interpret-label-as-html=\"(typeof interpretLabelAsHtml === 'boolean'\n                      && interpretLabelAsHtml) || (typeof interpretLabelAsHtml === 'object'\n                      && interpretLabelAsHtml.includes(filter.idInternal))\"\n                    :assistive-text=\"{\n                      booleanFilterLabel: assistiveText.booleanFilterLabel\n                        ? assistiveText.booleanFilterLabel\n                          .replace('{label}', filter.labelInternal) : value.labelInternal.toString(),\n                      optionToRemoveSelected: assistiveText.optionToRemoveSelected,\n                    }\"\n                    @remove-chip=\"removeChip(filterIndex, valueIndex)\" />\n                </template>\n              </template>\n            </ul>\n          </template>\n        </li>\n      </ul>\n    </div>\n    <span\n      v-if=\"chipRemovedAssistiveText\"\n      aria-live=\"assertive\"\n      class=\"assistive-text\">\n      {{ chipRemovedAssistiveText }}\n    </span>\n\n    <!-- remove all filters button -->\n    <button\n      :title=\"assistiveText.removeFiltersLabel\"\n      class=\"base-collapsed-filter-row__remove\"\n      @click=\"removeFilters\">\n      <BaseIcon\n        name=\"remove\"\n        class=\"base-collapsed-filter-row__remove-icon\" />\n    </button>\n  </div>\n</template>\n\n<script>\nimport BaseIcon from '@/components/BaseIcon/BaseIcon';\nimport BaseCollapsedFilterItem from '@/components/BaseAdvancedSearch/BaseCollapsedFilterItem';\nimport { hasData } from '@/utils/utils';\n\n/**\n * component for BaseAdvancedSearch 'form' mode to display form filter values efficiently\n */\nexport default {\n  name: 'BaseCollapsedFilterRow',\n  components: {\n    BaseCollapsedFilterItem,\n    BaseIcon,\n  },\n  props: {\n    /**\n     * provide a list of filters in array form, every array object that needs the following properties:\n     *  **idInternal** `string` - a filter identifier\n     *  **labelInternal** `string` - a label shown for the filter\n     *  **filter_values** `{\n     *    values: { labelInternal: string|boolean, idInternal: string? }[]|{ values: {}, fieldId: string, fieldType: string }[]\n     *    fieldId: string,\n     *    fieldType: string,\n     *   }[]` - the values that were selected for the filter (set by BaseAdvancedSearch internally), this is again\n     *    an array of objects with the properties\n     *      `values` - either containing the actual values to display (with `labelInternal` and `idInternal` (optional) properties)\n     *      OR in case of field groups to have nested another object array with `fieldType`, `fieldId` and `values` properties\n     *      again (see below for description)\n     *    `fieldId`: the property of the form field in question\n     *    `fieldType`: the type of the field in question\n     */\n    filters: {\n      type: Array,\n      default: () => ([]),\n      validator: (val) => {\n        // define all required props here\n        const requiredProps = ['idInternal', 'labelInternal', 'filter_values'];\n        const requiredFilterValueProps = ['values', 'fieldType', 'fieldId'];\n        // iterate through the filter array - return true if NO prop is missing\n        return !val.some((filter) => {\n          // get the properties the filter has\n          const filterProps = Object.keys(filter);\n          const filterValueProps = Object.keys(filter.filter_values);\n          // check if any of those is missing\n          let propMissing = requiredProps.some(prop => !filterProps.includes(prop));\n          // only continue checking if all props were found so far\n          if (!propMissing) {\n            propMissing = requiredFilterValueProps.some(prop => !filterValueProps.includes(prop));\n            // only continue checking if all props were found so far\n            if (!propMissing) {\n              // now also check if all filter.filter_values have a label to display\n              propMissing = filter.filter_values.values.some((filterValue) => {\n                // check for special case field groups where filter_values has nested arrays - so\n                // if filterValue has a length it is a nested array\n                if (filterValue?.values?.length >= 0) {\n                  const groupFilterValueProps = Object.keys(filterValue);\n                  // if yes check for each array if it has content and if yes, if it has the labelInternal property\n                  return filterValue.values.length !== 0\n                    && requiredFilterValueProps.some(prop => !groupFilterValueProps.includes(prop))\n                    && filterValue.values\n                      // also account here for special case boolean which does not need a labelInternal\n                      .some(nestedFilterValue => !Object.keys(nestedFilterValue).includes('labelInternal'));\n                }\n                // else check for each filterValue if labelInternal property is there\n                return !Object.keys(filterValue).includes('labelInternal');\n              });\n            }\n          }\n          // return boolean value if prop is missing\n          return propMissing;\n        });\n      },\n    },\n    /**\n     * set the text displayed for date or time values of ranges where only one field is\n     * filled.\n     */\n    dateTimeText: {\n      type: Object,\n      default: () => ({\n        from: 'from',\n        until: 'until',\n        range: 'to',\n      }),\n      validator: val => !['from', 'until', 'range'].some(property => !Object.keys(val).includes(property)),\n    },\n    /**\n     * if necessary selected chip text can be rendered as v-html directive\n     * can be `true` (all fields will have html rendering enabled) `false` or a list\n     *  of field names for which rendering should be enabled, for nested fields\n     *  specify an object with a list of child field names.\n     *  e.g. :interpretLabelAsHtml=\"['field1', { [field2]: ['childField1'] }]\"\n     */\n    interpretLabelAsHtml: {\n      type: [Boolean, Array],\n      default: false,\n    },\n    /**\n     * **removeFiltersLabel**: add a descriptive label used for the remove all\n     *  filters icon in collapsed row\n     * **filterRemovedNotification**: notification that is read by screenreaders when a filter\n     *  value was removed. Add the string {value} to read the filter value that was removed and\n     *  {label} to read the label of the filter from which the value was removed.\n     * **appliedFiltersLabel**: description for the filters in the collapsed filter row.\n     * **booleanFilterLabel**: Set text that should be read for a boolan filter value. You may add\n     *      the string {label} which will be replaced by the filter label.\n     * **optionToRemoveSelected**: text read when an option is focused (and thus selected), should\n     *  announce to the screen reader user that option can now be removed via Backspace or Delete.\n     */\n    assistiveText: {\n      type: Object,\n      default: () => ({\n        removeFiltersLabel: 'Remove all filters.',\n        filterRemovedNotification: 'Filter value {value} was removed from filter {label}.',\n        appliedFiltersLabel: 'Currently applied Filters',\n        booleanFilterLabel: 'Filter {label} was set',\n        optionToRemoveSelected: 'Press delete or backspace to remove.',\n      }),\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal representation of filters list, for a list of object properties see\n       *  prop `filters`\n       * @type Object[]\n       */\n      filtersInt: [],\n      /**\n       * variable to steer filter mobile display fade outs\n       * also if element is scrollable is determined from this variable (see computed\n       * prop filterListScrollable)\n       * @type {Object}\n       * @property {boolean} filterFade.left - left fade out\n       * @property {boolean} filterFade.right - right fade out\n       */\n      filterFade: {\n        left: false,\n        right: true,\n      },\n      /**\n       * store the element scroll and mouse cursor position, needed for drag scrolling\n       * @type {Object}\n       * @property {number} top - element scrollTop value\n       * @property {number} left - element scrollLeft value\n       * @property {number} x - cursor x position\n       * @property {number} y - cursor y position\n       */\n      pos: { top: 0, left: 0, x: 0, y: 0 },\n      /**\n       * store the scroll drag element\n       * @type {?HTMLElement}\n       */\n      scrollContainer: null,\n      /**\n       * set cursor styling according to current scroll state\n       * use variable instead of setting css class directly so child component\n       *  BaseCollapsedFilter item can also be steered easily\n       */\n      isScrolling: false,\n      /**\n       * Resize Observer to trigger fade out calculations\n       * @type {?ResizeObserver}\n       */\n      resizeObserver: null,\n      /**\n       * assistive text set when a chip was removed to be read\n       * by screenreader\n       * @type {string}\n       */\n      chipRemovedAssistiveText: '',\n    };\n  },\n  computed: {\n    /**\n     * determine from fade out calculations if element is scrollable\n     * @returns {boolean}\n     */\n    filterListScrollable() {\n      return this.filterFade.right || this.filterFade.left;\n    },\n  },\n  watch: {\n    /**\n     * keep filters in sync with parent component and vice versa\n     */\n    filters: {\n      handler(val) {\n        if (JSON.stringify(val) !== JSON.stringify(this.filtersInt)) {\n          this.filtersInt = JSON.parse(JSON.stringify(val));\n        }\n      },\n      immediate: true,\n    },\n    /**\n     * keep filters in sync with parent component and vice versa\n     */\n    filtersInt: {\n      handler(val) {\n        if (JSON.stringify(val) !== JSON.stringify(this.filters)) {\n          this.$emit('update:filters', [...val]);\n        }\n        this.$nextTick(() => this.calcFadeOut());\n      },\n      deep: true,\n    },\n  },\n  mounted() {\n    // check if filter list exists (which it should since element only displayed\n    // if filter values are present)\n    if (this.$refs.filterList) {\n      // store the filter list element (which is the scroll container)\n      this.scrollContainer = this.$refs.filterList;\n    }\n    // add a resize observer for the fade out and scroll functionalities\n    this.initResizeObserver();\n  },\n  beforeDestroy() {\n    // remove resize observer from element\n    if (this.resizeObserver) this.resizeObserver.unobserve(this.$refs.filterList);\n  },\n  methods: {\n    /**\n     * if 'remove all' icon was triggered just emit event to parent to take care of this\n     */\n    removeFilters() {\n      /**\n       * event emitted on remove icon click to remove all filters\n       * @event remove-all\n       */\n      this.$emit('remove-all');\n    },\n    /**\n     * function to remove one specific value from a filter in the filters list\n     * @param {number} filterIndex - the index of the filter\n     * @param {number} valueIndex - the index of the specific value\n     * @param {number?} groupIndex - in case filter is from form group, this is the index of the field\n     *  within the group\n     */\n    removeChip(filterIndex, valueIndex, groupIndex) {\n      const { fieldType, values } = this.filtersInt[filterIndex].filter_values;\n      const filterLabel = this.filtersInt[filterIndex].labelInternal;\n      // get the filter value label and assume it is not a group\n      const filterValue = fieldType === 'group' ? values[valueIndex].values[groupIndex].labelInternal\n        : values[valueIndex].labelInternal;\n      // first check special case group\n      if (fieldType === 'group') {\n        // get all the concatenated values within the group\n        const concatValuesArray = values.reduce((prev, { values: groupFilterValues }) => prev\n          .concat(groupFilterValues.filter(val => hasData(val))), []);\n        // check if more than 1 value is left in the whole row\n        if (concatValuesArray.length < 2 && this.filtersInt.length < 2) {\n          this.removeFilters();\n          // now check if more than one value is left for the group\n        } else if (concatValuesArray.length > 1) {\n          // check for special case date and time fields\n          if (values[valueIndex].fieldType.includes('date') || values[valueIndex].fieldType.includes('time')) {\n            // for date arrays just remove the labelInternal so the order of the date_from and date_to does not\n            // get mixed up by removing the complete value\n            this.filtersInt[filterIndex].filter_values.values[valueIndex].values[groupIndex].labelInternal = '';\n          } else {\n            // if its not a date just splice the value out of the array\n            this.filtersInt[filterIndex].filter_values.values[valueIndex].values.splice(groupIndex, 1);\n          }\n          // else this means there is only 1 value in the group left and the whole filter group can be\n          // spliced away\n        } else {\n          // if no - just splice the complete filter group away\n          this.filtersInt.splice(filterIndex, 1);\n        }\n        // check if this is the last (or only) filter value currently selected\n      } else if (this.filtersInt.length === 1 && values.length === 1) {\n        // if yes - remove the complete row\n        this.removeFilters();\n        // else check if this is the only value for a specific filter\n      } else if (values.length === 1) {\n        // if yes - remove the complete filter\n        this.filtersInt.splice(filterIndex, 1);\n        // special case date object\n      } else if (fieldType.includes('date') || fieldType.includes('time')) {\n        if (values.filter(value => hasData(value)).length < 2) {\n          // if yes - remove the complete filter\n          this.filtersInt.splice(filterIndex, 1);\n        } else {\n          this.filtersInt[filterIndex].filter_values.values[valueIndex].labelInternal = '';\n        }\n      } else {\n        this.filtersInt[filterIndex].filter_values.values.splice(valueIndex, 1);\n      }\n      // set the assistive text so it is read by screenreader\n      this.chipRemovedAssistiveText = this.assistiveText.filterRemovedNotification\n        .replace('{label}', filterLabel)\n        .replace('{value}', filterValue);\n      // and remove it again afterward\n      setTimeout(() => {\n        this.chipRemovedAssistiveText = '';\n      }, 300);\n    },\n\n    /** SCROLL RELATED FUNCTIONALITIES */\n\n    /**\n     * set up resize observer for filterList to be able to adjust filter fade out\n     * and scroll functionality\n     */\n    initResizeObserver() {\n      const tempResizeObserver = new ResizeObserver(this.calcFadeOut);\n      tempResizeObserver.observe(this.$refs.filterList);\n      this.resizeObserver = tempResizeObserver;\n    },\n    /**\n     * function triggered by mouse down on filter list, triggering scroll functionality\n     * @param {MouseEvent} event - the mouse down event\n     */\n    mouseDownHandler(event) {\n      // check if filterList is actually scrollable\n      if (this.filterListScrollable) {\n        // save the current element scroll state and mouse position\n        this.pos = {\n          // The current scroll\n          left: this.scrollContainer.scrollLeft,\n          top: this.scrollContainer.scrollTop,\n          // Get the current mouse position\n          x: event.clientX ?? (event.touches ? event.touches[0]?.clientX : 0),\n          y: event.clientY ?? (event.touches ? event.touches[0]?.clientY : 0),\n        };\n        // add event listeners for mousemove and mouseup to be able to trigger scroll\n        // for touch devices add touch event listeners\n        if (event.type === 'touchstart') {\n          document.addEventListener('touchmove', this.mouseMoveHandler);\n          document.addEventListener('touchend', this.mouseUpHandler);\n        } else {\n          // else add mouse events\n          document.addEventListener('mousemove', this.mouseMoveHandler);\n          document.addEventListener('mouseup', this.mouseUpHandler);\n        }\n        // Change the cursor and prevent user from selecting the text\n        this.isScrolling = true;\n      }\n    },\n    /**\n     * function triggered by document mouse move after event listeners were added\n     * in mouse down filter list element event\n     * @param {MouseEvent} e\n     */\n    mouseMoveHandler(e) {\n      // get event position - touch event does not have clientX/clientY - fallback\n      // to touches position\n      const eventXPosition = e.clientX ?? (e.touches ? e.touches[0]?.clientX : 0);\n      const eventYPosition = e.clientY ?? (e.touches ? e.touches[0]?.clientY : 0);\n      // How far the mouse has been moved\n      const dx = eventXPosition - this.pos.x;\n      const dy = eventYPosition - this.pos.y;\n\n      // Scroll the element\n      this.scrollContainer.scrollTop = this.pos.top - dy;\n      this.scrollContainer.scrollLeft = this.pos.left - dx;\n      // check if fade out needs to be shown / has changed\n      this.calcFadeOut();\n    },\n    /**\n     * function triggered by document mouse up after event listeners were added\n     * in mouse down filter list element event\n     */\n    mouseUpHandler() {\n      // remove all the event listeners again\n      document.removeEventListener('mousemove', this.mouseMoveHandler);\n      document.removeEventListener('mouseup', this.mouseUpHandler);\n      document.removeEventListener('touchmove', this.mouseMoveHandler);\n      document.removeEventListener('touchend', this.mouseUpHandler);\n\n      // change the styling of the element back to normal\n      this.isScrolling = false;\n    },\n    /**\n     * function to calculate if filterList fade out should be shown on element left and/or right border\n     */\n    calcFadeOut() {\n      // get current element scroll position\n      const scrollPosition = Math.floor(this.scrollContainer.scrollLeft);\n      // get element max scroll position\n      const scrollMax = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;\n      // set filter fade variables\n      this.filterFade = {\n        // show fade out left as soon as scroll position is different from 0\n        left: scrollPosition !== 0,\n        // show fade out right as soon as scroll position is different from maximum position\n        // but only if element exceeds available space\n        right: scrollMax !== 0 && scrollPosition !== scrollMax,\n      };\n    },\n\n    /** OTHER METHODS */\n\n    /**\n     * determine if the provided filter values array has any label data in it\n     * (could be kept in the filter values list even if empty in order to be able\n     * to map again to the original formFieldValues)\n     * @param {Object[]} filterValues\n     * @returns {boolean}\n     */\n    filterValuesHaveData(filterValues) {\n      return hasData(filterValues);\n    },\n    getRangeIndicator(filterValues, index) {\n      // check if it is a filter with an array of exactly two values\n      if (filterValues.values.length === 2\n        && ['date', 'time'].includes(filterValues.fieldType)) {\n        if (!!filterValues.values[0].labelInternal\n          && !!filterValues.values[1].labelInternal && index === 1) {\n          return this.dateTimeText.range;\n        }\n        if (!filterValues.values[1].labelInternal && filterValues.values[0].labelInternal) {\n          return this.dateTimeText.from;\n        }\n        if (!filterValues.values[0].labelInternal && filterValues.values[1].labelInternal) {\n          return this.dateTimeText.until;\n        }\n      }\n      return '';\n    },\n    /**\n     * we need to check if `interpretLabelAsHtml` was set true for a subform field when\n     *  the prop was provided as [{ [parentField]: ['subfield1'] }]\n     * @param {string} filterId - the filter id as provided to this component (in the form\n     *  [fieldname]-group-[index])\n     * @param {string} valueId - the property name of the actual subformfield\n     * @returns {boolean}\n     */\n    calcSubFormChipHtmlRender(filterId, valueId) {\n      // get the correct filter property name from the id\n      // e.g. 'weekday-date-group-0' -> 'weekday-date'\n      const filterPropertyName = filterId.split('-').slice(0, 1).join('-');\n      // find the correct object in the `interpretLabelAsHtml` array\n      const subFormList = this.interpretLabelAsHtml\n        .find(id => typeof id === 'object' && Object.keys(id).includes(filterPropertyName));\n      // check if a value was found and if the field name is included in the list of that value\n      return !!subFormList && subFormList[filterPropertyName].includes(valueId);\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../../styles/variables\";\n\n.base-collapsed-filter-row {\n  position: relative;\n  height: $row-height-large;\n  align-items: center;\n  padding-left: $spacing;\n  border-top: $separation-line;\n  display: flex;\n  flex-direction: row;\n  overflow: hidden;\n\n  .base-collapsed-filter-row__filter-list-container {\n    position: relative;\n    flex: 1 1 auto;\n    overflow: hidden;\n\n    &.base-collapsed-filter-row__filter-list-container__fade-left::before {\n      content: '';\n      width: $fade-out-width;\n      height: 100%;\n      position: absolute;\n      top: 0;\n      background: linear-gradient(to right, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n      z-index: map-get($zindex, chips-fadeout);\n      pointer-events: none;\n    }\n\n    &.base-collapsed-filter-row__filter-list-container__fade-right::after {\n      content: '';\n      width: $fade-out-width;\n      height: 100%;\n      position: absolute;\n      top: 0;\n      right: 0;\n      background: linear-gradient(to right, rgba(255, 255, 255, 0), rgb(255, 255, 255));\n      z-index: map-get($zindex, chips-fadeout);\n      pointer-events: none;\n    }\n\n    .base-collapsed-filter-row__filter-list {\n      display: flex;\n      overflow-x: auto;\n      scrollbar-width: none; /* Firefox */\n      -ms-overflow-style: none;  /* Internet Explorer 10+ */\n\n      &::-webkit-scrollbar { /* WebKit */\n        width: 0;\n        height: 0;\n      }\n\n      &.base-collapsed-filter-row__filter-list__scrollable {\n        cursor: grab;\n      }\n\n      &.base-collapsed-filter-row__filter-list__scrolling {\n        cursor: grabbing;\n        user-select: none;\n      }\n\n      .base-collapsed-filter-row__filter {\n        display: flex;\n        flex-direction: column;\n        justify-content: flex-start;\n        flex: 0 0 auto;\n        overflow-y: hidden;\n\n        + .base-collapsed-filter-row__filter {\n          margin-left: $spacing;\n        }\n\n        &.base-collapsed-filter-row__filter__boolean {\n          flex: 0 1 auto;\n          min-width: 150px;\n          overflow: hidden;\n        }\n\n        .base-collapsed-filter-row__filter-label {\n          font-size: $font-size-small;\n          color: $font-color-second;\n          white-space: nowrap;\n          width: 100%;\n          overflow: hidden;\n          text-overflow: ellipsis;\n        }\n\n        .base-collapsed-filter-row__chips-list {\n          display: flex;\n          flex-direction: row;\n          white-space: nowrap;\n          align-items: center;\n          flex: 1 0 auto;\n          height: calc(#{$line-height} + #{$spacing-small});\n\n          .base-collapsed-filter-row__group-chip--spacing-right {\n            margin-right: $spacing-small;\n          }\n        }\n      }\n    }\n  }\n\n  .base-collapsed-filter-row__remove {\n    background: white;\n    display: flex;\n    flex: 0 0 auto;\n    padding: 0 $spacing;\n    height: 100%;\n    align-items: center;\n\n    &:hover, &:active, &:focus {\n      color: $app-color;\n    }\n\n    .base-collapsed-filter-row__remove-icon {\n      height: $icon-medium;\n      width: $icon-medium;\n      cursor: pointer;\n    }\n  }\n}\n</style>\n"],"names":["_sfc_main","BaseCollapsedFilterItem","BaseIcon","val","requiredProps","requiredFilterValueProps","filter","filterProps","filterValueProps","propMissing","prop","filterValue","_a","groupFilterValueProps","nestedFilterValue","property","filterIndex","valueIndex","groupIndex","fieldType","values","filterLabel","concatValuesArray","prev","groupFilterValues","hasData","value","tempResizeObserver","event","_b","e","eventXPosition","eventYPosition","dx","dy","scrollPosition","scrollMax","filterValues","index","filterId","valueId","filterPropertyName","subFormList","id"],"mappings":"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"}