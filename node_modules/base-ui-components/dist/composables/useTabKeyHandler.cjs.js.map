{"version":3,"file":"useTabKeyHandler.cjs.js","sources":["../../src/composables/useTabKeyHandler.js"],"sourcesContent":["import { computed, ref, watchEffect } from 'vue';\n\n/**\n * Handle tab key events to focus a list of focusable HTML elements\n * Note: Currently the composable makes troubles when imported from the base-ui-components library.\n * TODO: Find another way to initialize the EventListener than within the watchEffect method.\n *\n * @param {Object, String} target - container element where the focusableElements are located\n *                                  * can be either a Vue reference object or\n *                                  * a string representing a CSS selector\n * @param {string} focusableElements - comma separated list of HTML elements to focus\n * @param {boolean} disable - disable method and do nothing\n * @returns {{focusableHTMLTags: *, disableHandler: *}}\n */\n// eslint-disable-next-line import/prefer-default-export\nexport function useTabKeyHandler(target, focusableElements, disable = false) {\n  const focusableHTMLTags = ref(focusableElements);\n  const disableHandler = ref(disable);\n\n  /**\n   * determine the target HTML element\n   * @return {HTMLElement, undefined}\n   */\n  const targetElement = computed(() => {\n    if (typeof target === 'object' && target?.value) {\n      return target.value;\n    }\n    // if target is a string representing a CSS selector\n    if (typeof target === 'string' && document?.querySelector(target)) {\n      return document?.querySelector(target);\n    }\n    return undefined;\n  });\n\n  /**\n   * get focusable dom elements within a target container element\n   * @return array - list of focusable DOM elements\n   */\n  function getFocusableElements() {\n    // if targetElement is not defined, return an empty array\n    if (!targetElement.value) return [];\n    // define an empty list\n    const elements = Array.from(targetElement.value.querySelectorAll(focusableHTMLTags.value));\n    // return DOM visible focusable elements\n    return elements.filter(element => element.checkVisibility());\n  }\n\n  /**\n   * set focus to next/prev focusable DOM element\n   * @param {string} direction\n   */\n  function setFocus(direction = 'next') {\n    const elements = getFocusableElements();\n    if (!elements.length) return;\n\n    let currentFocus = null;\n    let nextFocus = null;\n    // find current focus\n    elements.forEach((element, index) => {\n      if (element.matches(':focus')) {\n        currentFocus = index;\n      }\n    });\n    // if the current focus is not one of the focusable items, use the first one\n    if (currentFocus === null) {\n      elements[0].focus();\n      return;\n    }\n    // set the next focus depending on the direction\n    if (direction === 'next') {\n      nextFocus = elements[currentFocus + 1] ? currentFocus + 1 : 0;\n    }\n    if (direction === 'prev') {\n      nextFocus = elements[currentFocus - 1]\n        ? currentFocus - 1 : elements.length - 1;\n    }\n    // finally, set focus\n    elements[nextFocus].focus();\n  }\n\n  /**\n   * intercept tab key event\n   * @param {Object} e - event\n   */\n  function tabKeyHandler(e) {\n    if (disableHandler.value) return;\n\n    if (e.shiftKey && e.key === 'Tab') {\n      e.preventDefault();\n      setFocus('prev');\n      return;\n    }\n\n    if (e.key === 'Tab') {\n      e.preventDefault();\n      setFocus('next');\n    }\n  }\n\n  watchEffect(() => {\n    /**\n     * Currently the composable makes troubles when imported from the base-ui-components library.\n     * Somehow the watchEffect method is called before the DOM is updated.\n     * TODO: find another way to initialize the eventListener\n     */\n    if (targetElement.value) {\n      targetElement.value.addEventListener('keydown', tabKeyHandler);\n    }\n  });\n\n  return {\n    focusableHTMLTags,\n    disableHandler,\n  };\n}\n"],"names":["useTabKeyHandler","target","focusableElements","disable","arguments","length","undefined","focusableHTMLTags","ref","disableHandler","targetElement","computed","_document","_typeof","value","document","querySelector","_document2","getFocusableElements","elements","Array","from","querySelectorAll","filter","element","checkVisibility","setFocus","direction","currentFocus","nextFocus","forEach","index","matches","focus","tabKeyHandler","e","shiftKey","key","preventDefault","watchEffect","addEventListener"],"mappings":"kJAeO,SAASA,EAAiBC,EAAQC,EAAoC,CAAA,IAAjBC,EAAOC,UAAAC,OAAA,GAAAD,UAAA,CAAA,IAAAE,OAAAF,UAAA,CAAA,EAAG,GAC9DG,EAAoBC,MAAIN,CAAiB,EACzCO,EAAiBD,MAAIL,CAAO,EAM5BO,EAAgBC,EAAAA,SAAS,UAAM,CAAA,IAAAC,EACnC,GAAIC,EAAOZ,CAAM,IAAK,UAAYA,IAAM,MAANA,IAAM,QAANA,EAAQa,MACxC,OAAOb,EAAOa,MAGhB,GAAI,OAAOb,GAAW,WAAQW,EAAIG,YAAQH,MAAAA,YAARA,EAAUI,cAAcf,CAAM,EAAG,CAAA,IAAAgB,EACjE,OAAAA,EAAOF,YAAQE,MAAAA,IAARA,OAAAA,OAAAA,EAAUD,cAAcf,CAAM,CACvC,CAEF,CAAC,EAMD,SAASiB,GAAuB,CAE9B,GAAI,CAACR,EAAcI,MAAO,MAAO,GAEjC,IAAMK,EAAWC,MAAMC,KAAKX,EAAcI,MAAMQ,iBAAiBf,EAAkBO,KAAK,CAAC,EAEzF,OAAOK,EAASI,OAAO,SAAAC,EAAO,CAAA,OAAIA,EAAQC,kBAAkB,CAC9D,CAMA,SAASC,GAA6B,CAAA,IAApBC,EAASvB,UAAAC,OAAA,GAAAD,UAAA,CAAA,IAAAE,OAAAF,UAAA,CAAA,EAAG,OACtBe,EAAWD,IACjB,GAAKC,EAASd,OAEd,KAAIuB,EAAe,KACfC,EAAY,KAQhB,GANAV,EAASW,QAAQ,SAACN,EAASO,EAAU,CAC/BP,EAAQQ,QAAQ,QAAQ,IAC1BJ,EAAeG,EAEnB,CAAC,EAEGH,IAAiB,KAAM,CACzBT,EAAS,CAAC,EAAEc,QACZ,MACF,CAEIN,IAAc,SAChBE,EAAYV,EAASS,EAAe,CAAC,EAAIA,EAAe,EAAI,GAE1DD,IAAc,SAChBE,EAAYV,EAASS,EAAe,CAAC,EACjCA,EAAe,EAAIT,EAASd,OAAS,GAG3Cc,EAASU,CAAS,EAAEI,QACtB,CAMA,SAASC,EAAcC,EAAG,CACxB,GAAI1B,CAAAA,EAAeK,MAEnB,IAAIqB,EAAEC,UAAYD,EAAEE,MAAQ,MAAO,CACjCF,EAAEG,eAAc,EAChBZ,EAAS,MAAM,EACf,MACF,CAEIS,EAAEE,MAAQ,QACZF,EAAEG,eAAc,EAChBZ,EAAS,MAAM,GAEnB,CAEAa,OAAAA,EAAAA,YAAY,UAAM,CAMZ7B,EAAcI,OAChBJ,EAAcI,MAAM0B,iBAAiB,UAAWN,CAAa,CAEjE,CAAC,EAEM,CACL3B,kBAAAA,EACAE,eAAAA,EAEJ"}