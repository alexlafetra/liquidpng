import d from "../BaseSearch/BaseSearch.vue.es.js";
import u from "../BaseIcon/BaseIcon.vue.es.js";
import p from "../BaseButton/BaseButton.vue.es.js";
import h from "../BaseChipsInputField/BaseChipsInputField.vue.es.js";
import f from "../BaseChip/BaseChip.vue.es.js";
import y from "../BaseDropDownList/BaseDropDownList.vue.es.js";
import { createId as m, sort as v, hasData as b } from "../../utils/utils.es.js";
import { ref as _ } from "vue";
import { useAnnouncer as g } from "../../composables/useAnnouncer.es.js";
import w from "../../mixins/navigateList.es.js";
import O from "../../mixins/i18n.es.js";
import "./BaseAdvancedSearchRow.vue.es2.js";
import "./BaseAdvancedSearchRow.vue.es3.js";
import I from "../../_virtual/_plugin-vue2_normalizer.es.js";
const N = {
  name: "BaseAdvancedSearchRow",
  components: {
    BaseButton: p,
    BaseDropDownList: y,
    BaseChip: f,
    BaseChipsInputField: h,
    BaseSearch: d,
    BaseIcon: u
  },
  mixins: [w, O],
  props: {
    /**
     * provide an id for each search row
     */
    searchRowId: {
      type: String,
      default: ""
    },
    /**
     *
     */
    mode: {
      type: String,
      default: "list",
      validator: (t) => ["list", "form"].includes(t)
    },
    /**
     * property to distinguish between one of multiple filter rows
     * and the main search field (where new filters are added) that has
     * a slightly different design and functionality
     */
    isMainSearch: {
      type: Boolean,
      default: !0
    },
    /**
     * list of available filters, needs to be an array of objects with the following properties:<br>
     *   <br>
     *    <b>label</b> {string} - the label of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      labelPropertyName.filter<br>
     *    <b>id</b> {string} - the identifier of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      identifierPropertyName.filter<br>
     *    <b>type</b> {('text'|'chips'|'chipssingle'|'date'|'daterange')} - the filter type<br>
     *    <b>freetext_allowed</b> {boolean} - determines if predetermined options from 'options'
     *      property are used or autocomplete is used
     *    <b>options</b> {Object[]} - for filter type 'chips' and 'chipssingle' the controlled
     *      vocabulary options
     *    <b>subsets</b> {string[]} - if a filter of `type` 'text' or 'chips' with
     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which
     *      the autosuggest results should also be shown - add these filter ids here
     */
    filterList: {
      type: Array,
      default: () => [],
      validator: (t) => !t.length || t.every((e) => !!e.type && (!["chips", "chipssingle"].includes(e.type) || e.freetext_allowed || !!e.options))
    },
    /**
     * specify a default value for a filter that is set when none of the
     * available filters is selected, should have the following properties:<br>
     *   <br>
     *    <b>label</b> {string} - the label of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      labelPropertyName.filter<br>
     *    <b>id</b> {string} - the identifier of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      identifierPropertyName.filter<br>
     *    <b>type</b> {('text'|'chips'|'chipssingle'|'date'|'daterange')} - the filter type<br>
     *    <b>freetext_allowed</b> {boolean} - determines if predetermined options from 'options'
     *      property are used or autocomplete is used
     *    <b>options</b> {Object[]} - for filter type 'chips' and 'chipssingle' the controlled
     *      vocabulary options<br>
     *    <b>filter_values</b> {Object[]|string[]|Object} - the values selected - object for date
     *      or array of objects or strings for type 'text', type 'chips' and 'chipssingle'
     *
     *    defaultFilter does not need the property subsets since results for all filters are
     *    shown per default
     */
    defaultFilter: {
      type: Object,
      default: () => ({
        id: "default",
        label: "Fulltext",
        type: "text",
        options: []
      }),
      validator: (t) => !t.length || t.every((e) => !!e.type && (!["chips", "chipssingle"].includes(e.type) || e.freetext_allowed || !!e.options))
    },
    /**
     * the filter currently applied, needs to be an object with the following properties:<br>
     *   <br>
     *    <b>label</b> {string} - the label of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      labelPropertyName.filter<br>
     *    <b>id</b> {string} - the identifier of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      identifierPropertyName.filter<br>
     *    <b>type</b> {('text'|'chips'|'chipssingle'|'date'|'daterange')} - the filter type<br>
     *    <b>freetext_allowed</b> {boolean} - determines if predetermined options from 'options'
     *      property are used or autocomplete is used
     *    <b>filter_values</b> {Object[]|string[]|Object} - the values selected - object for date
     *      or array of objects or strings for type 'text',  type 'chips' and 'chipssingle'
     *    <b>subsets</b> {string[]} - if a filter of `type` 'text' or 'chips' with
     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which
     *      the autosuggest results should also be shown - add these filter ids here
     */
    appliedFilter: {
      type: [Object, null],
      default: null,
      validator: (t) => t === null || !t.length || ["id", "type", "label"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * provide the component with the fetched autocomplete results
     * (drop down options)<br>
     * this needs to be an object array with the properties specified in
     * `autocompletePropertyNames`
     */
    autocompleteResults: {
      type: Array,
      default: () => []
    },
    /**
     * flag to set if loader should be shown (for autocomplete requests
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * specify a language (ISO 639-1) (used for label if label is language specific object
     * e.g. { de: 'xxx', en: 'yyy' })
     */
    language: {
      type: String,
      default: ""
    },
    /**
     * specify the object property that can be used for identification of filters,
     * autocomplete options and controlled vocabulary options.<br>
     *   Could be a string (used for all of the mentioned objects) or an object with the following
     *   properties:<br>
     *     <b>filter</b>: identifier property name in filter objects<br>
     *     <b>autocompleteOption</b>: identifier property name in autocomplete option objects<br>
     *     <b>controlledVocabularyOption</b>: identifier property name in controlled
     *     vocabulary option objects<br>
     */
    identifierPropertyName: {
      type: [Object, String],
      default: () => ({
        filter: "id",
        autocompleteOption: "id",
        controlledVocabularyOption: "id"
      })
    },
    /**
     * specify the object property that should be used for label display of filters,
     * autocomplete options and controlled vocabulary options.<br>
     *   Could be a string (used for all of the mentioned objects) or an object with the following
     *   properties:<br>
     *     <b>filter</b>: label property name in filter objects<br>
     *     <b>autocompleteOption</b>: label property name in autocomplete option objects<br>
     *     <b>controlledVocabularyOption</b>: label property name in controlled
     *     vocabulary option objects<br>
     */
    labelPropertyName: {
      type: [Object, String],
      default: () => ({
        filter: "label",
        autocompleteOption: "title",
        controlledVocabularyOption: "label"
      })
    },
    /**
     * autocomplete results need a label, an id and a data property that contains all the actual
     * autocomplete results for that specific category
     * TODO: make category optional
     */
    autocompletePropertyNames: {
      type: Object,
      default: () => ({
        label: "label",
        id: "id",
        data: "data"
      }),
      // check if all the necessary attributes are included in the provided object
      validator: (t) => ["label", "id", "data"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * add a placeholder for the search input; either just a string or an object with
     * different text for each search type (text, chips, date)
     */
    placeholder: {
      type: [String, Object],
      default: "Search and discover"
    },
    /**
     * specify informational texts for the component - this needs to be an object with the following
     * properties (if you dont want to display any text leave an empty string):  <br>
     *   <br>
     *     <b>title</b>: text shown as first line on the drop down in filters area<br>
     *     <b>subtext</b>: text shown as second line on the drop down in filters area<br>
     *     <b>availableOptions</b>: text shown with chips options for controlled vocabulary
     *     search<br>
     *  <br>
     *  The values of this object might be plain text or a key for an i18n file<br>
     * This prop can be ignored when the 'no-options' slot is used.
     */
    advancedSearchText: {
      type: Object,
      default: () => ({
        title: "Advanced Search",
        subtext: "Select a filter",
        availableOptions: "Available options"
      })
    },
    /**
     * specify informational texts for the drop down - this needs to be an object with the following
     * properties (if you dont want to display any text leave an empty string:  <br>
     *   <br>
     *     <b>autocompleteNoOptions</b>: text shown when no autocomplete options are available<br>
     *     <b>autocompleteOngoing</b>: text shown when an autocomplete search request is ongoing<br>
     *     <b>autocompleteInitial</b>: initial text shown before user started typing<br>
     *     <b>chipsNoOptions</b>: text shown when there are no options for controlled vocabulary
     *        available<br>
     *     <b>chipsMaxOptions</b>: text displayed if more than max number of options that can be
     *        displayed are available (configure via prop maxNumberControlledOptions)<br>
     *     <b>chipsNoMatch</b>: text displayed if string in input does not match any options<br>
     *     <b>chipsOngoing</b>: text shown for chips fetching request ongoing<br>
     *  <br>
     *  The values of this object might be plain text or a key for an i18n file<br>
     */
    dropDownInfoTexts: {
      type: Object,
      default: () => ({
        autocompleteNoOptions: "No matching options found",
        autocompleteOngoing: "Autocomplete is being fetched...",
        autocompleteInitial: "Please start typing or select a filter to see options",
        chipsNoOptions: "No more options available",
        chipsMaxOptions: "Please start typing to see options",
        chipsNoMatch: "No matching options were found",
        chipsOngoing: "Options are being loaded..."
      }),
      // checking if all necessary properties are part of the provided object
      validator: (t) => [
        "autocompleteNoOptions",
        "autocompleteOngoing",
        "autocompleteInitial",
        "chipsNoOptions",
        "chipsOngoing",
        "chipsMaxOptions",
        "chipsNoMatch"
      ].every((e) => Object.keys(t).includes(e))
    },
    /**
     * define a maximum number of controlled vocabulary options to be displayed
     */
    maxNumberControlledOptions: {
      type: Number,
      default: 100
    },
    /**
     * this prop gives the option to add assistive text for screen readers<br>
     * properties:<br>
     * <b>addFilter</b>: text/label used for add filter icon<br>
     * <b>removeFilter</b>: text/label used for remove filter icon<br>
     * <b>selectFilterLabel</b>: label (not visible) used for filter chips input field<br>
     * <b>searchLabel</b>: label (not visible) used for search input field<br>
     * <b>selectedOption</b>: text read when a selected option is focused (currently only
     *  working for type chips with autocomplete (=freetext_allowed))
     * **loaderActive**: text that is announced when results are being fetched (prop
     *  `isLoading` is set `true`)
     * **autocompleteResultsRetrieved**: text announced when autocomplete results are returned.
     *  use {optionsNumber} and {collectionsNumber} in the string to announce the number of
     *  total options and collections found respectively.
     * **autocompleteNoResults**: Text announced when no results were found with a given
     *  search string.
     * **autocompleteInitial**: Text announced when no search string was provided for
     *  autocomplete.
     * **categoryAnnouncement**: Text announced when a new category is entered in the
     *  autocomplete drop down options list with keyboard navigation. string '{label}' will
     *  be replaced by the actual specified category label
     * **optionsAnnouncement**: announced together with category when in category selection
     *  mode (after using arrowLeft key on autocomplete input) - to give the user a feeling
     *  how many options were found for the announced category. string '{number}' will be
     *  replaced by the number of entries in that category.
     * **results**: provide text that should be announced when the search has
     *  yielded results (or not).
     *
     * Caveat: `results` has a watcher attached to trigger the
     *    announcement so make sure the property values are reset after filling them
     *    by using update:assistive-text or resetting it manually (after a timeout)
     */
    assistiveText: {
      type: Object,
      default: () => ({
        addFilter: "Add filter",
        removeFilter: "Remove filter",
        selectFilterLabel: "Select filter",
        searchLabel: "Search for Entries",
        selectedOption: "",
        loaderActive: "loading.",
        autocompleteResultsRetrieved: "{optionsNumber} options found in {collectionsNumber} categories.",
        autocompleteNoResults: "No results found.",
        autocompleteInitial: "Please start typing to see suggestions.",
        categoryAnnouncement: "category {label}.",
        optionsAnnouncement: "{number} options.",
        results: ""
      })
    },
    /**
     * if desired the box shadow around the search rows can be deactivated here
     */
    applyBoxShadow: {
      type: Boolean,
      default: !0
    },
    /**
     * use this prop to set a delay in ms before date input calender is displayed
     */
    dateFieldDelay: {
      type: Number,
      default: 0
    },
    /**
     * set this flag to `true` to highlight autocomplete option characters that match
     *  the current search input string
     */
    highlightAutocompleteMatch: {
      type: Boolean,
      default: !1
    },
    /**
     * if `highlightAutocompleteMatch` is set `true`
     *  provide tag names to style the matched characters
     *  (without '<' and '>', e.g. ['b'] for <b>)
     */
    highlightAutocompleteTags: {
      type: Array,
      default: () => []
    }
  },
  setup() {
    const t = _(null), { announcement: e } = g(t);
    return {
      advancedSearchRow: t,
      announcement: e
    };
  },
  data() {
    return {
      /**
       * variable containing search text
       * @type {?string|?Object}
       */
      currentInput: "",
      /**
       * the currently selected filter
       * @type {Filter}
       */
      filter: null,
      /**
       * the currently active (selected by key navigation) filter
       * @type {?Filter}
       */
      activeFilter: null,
      /**
       * variable to steer filter mobile display fade outs
       * @type {Object}
       * @property {boolean} filterFade.left - left fade out
       * @property {boolean} filterFade.right - right fade out
       */
      filterFade: {
        left: !1,
        right: !0
      },
      /**
       * for autocomplete drop down navigation - collection level
       * @type {?string}
       */
      activeCollectionId: "",
      /**
       * switch between arrow use on collection or entry level
       * (true for collection level)
       * @type {boolean}
       */
      collectionSelect: !1,
      /**
       * the currently active controlled vocabulary entry
       * @type {?Object|?string}
       */
      activeControlledVocabularyEntry: null,
      /**
       * for autocomplete drop down navigation - single autocomplete option level
       * @type {?Object}
       */
      activeEntry: null,
      /**
       * to control if search field is active (and drop down shown)
       * @type {boolean}
       */
      isActive: !1,
      /**
       * store the current filter type to recognize when it changes and only take
       * action e.g. on focusing input field, after it was rendered
       * @type {string}
       */
      currentFilterType: this.appliedFilter ? this.appliedFilter.type : this.defaultFilter.type,
      /**
       * the search input element stored in a variable so it can easily be focused again after
       * option selection
       * @type {?HTMLElement}
       */
      searchInputElement: null,
      /**
       * Mutation observer for handling the focusing of input field after changes
       * @type {?MutationObserver}
       */
      observer: null,
      /**
       * Resize Observer to trigger actions (e.g. drop down columns calculations) when
       * component is resized
       * @type {?ResizeObserver}
       */
      resizeObserver: null,
      /**
       * depending on element size a different slot of BaseInput is used and needs
       * to be passed on to v-slot directive of template element
       * @type {string}
       */
      filterSlotName: "pre-input-field",
      /**
       * variable for touch devices to stop the click event from opening the drop down
       *  when click event was coming from elements within the search (e.g. BaseForm)
       */
      stopSearchClick: !1
    };
  },
  computed: {
    /**
     * create a row id either taken from externally specified id or
     * via createId function
     */
    internalRowId() {
      return this.searchRowId || m();
    },
    /**
     * v-model of BaseChipsInputField provides an array of selected options - do
     * conversion to object and array respectively with this computed variable
     * (this is triggered when deleting the selected filter)
     */
    selectedFilter: {
      /**
       * triggered on deleting a filter via chip 'x'
       * @param {Filter[]} val
       */
      set(t) {
        const e = t.length ? t.pop() : this.defaultFilter;
        this.filter = {
          ...e,
          filter_values: this.setFilterValues(e, this.filter)
        };
      },
      get() {
        return [this.filter];
      }
    },
    /**
     * for main filter do not display the default filter in the drop down list with
     *  available filters (mode 'list')
     * @returns {Filter[]}
     */
    displayFilterList() {
      return this.isMainSearch ? this.filterList.filter((t) => t[this.identifierPropertyName.filter] !== this.defaultFilter[[this.identifierPropertyName.filter]]) : this.filterList;
    },
    /**
     * variable to return if autocomplete functionality should be shown (= results fetched
     * and displayed in drop down, how input is handled, etc.)
     * this evaluates to true if type is text or chips with freetext allowed
     * @returns {boolean}
     */
    useAutocompleteFunctionality() {
      const { type: t } = this.filter;
      return t === "text" || t === "chips" && this.filter.freetext_allowed;
    },
    /**
     * depending on the filter type get selectedOptions for BaseSearch from filter values
     */
    selectedOptions: {
      /**
       * this is used when a chip is deleted
       * @param {Object[]|string[]} val - the new selected options to be set as filter_values in the
       *  current filter
       */
      set(t) {
        this.$set(this.filter, "filter_values", [...t]);
      },
      get() {
        return this.filter.type.includes("chips") ? this.filter && this.filter.filter_values ? [...this.filter.filter_values] : [] : [];
      }
    },
    /**
     * in case the filter is a controlled vocabulary filter get the options
     * from the corresponding filter in the filter list
     * @returns {Object[]}
     */
    controlledVocabularyOptions() {
      if (this.filter.type === "chips" && !this.filter.freetext_allowed) {
        const t = this.filterList.find((e) => e[this.identifierPropertyName.filter] === this.filter[this.identifierPropertyName.filter]);
        return t ? t.options : [];
      }
      return [];
    },
    /**
     * the actually displayed controlled vocabulary options
     * (filtered for already selected and for the current input string)
     *
     * @returns Object[]
     */
    displayedOptions() {
      if (this.controlledVocabularyOptions) {
        let t = [].concat(this.controlledVocabularyOptions);
        return this.filter.filter_values && this.filter.filter_values.length && (t = t.filter((e) => !this.filter.filter_values.map((r) => r[this.identifierPropertyName.controlledVocabularyOption]).includes(e[this.identifierPropertyName.controlledVocabularyOption]))), this.currentInput && (t = t.filter((e) => e[this.labelPropertyName.filter].toLowerCase().includes(this.currentInput.toLowerCase()))), v(
          t,
          this.labelPropertyName.controlledVocabularyOption,
          !1,
          this.getLangLabel
        );
      }
      return [];
    },
    /**
     * filtered autocomplete list, e.g. removing collections with no results
     * and options that were already selected
     * @type {Object[]} resultListInt
     * @returns {Object[]}
     */
    resultListInt() {
      if (this.useAutocompleteFunctionality) {
        let t = this.autocompleteResults;
        if (this.filter[this.identifierPropertyName.filter] !== this.defaultFilter[this.identifierPropertyName.filter] && (t = t.filter((e) => e[this.autocompletePropertyNames.id] === this.filter[this.identifierPropertyName.filter] || this.filter.subsets && this.filter.subsets.length && this.filter.subsets.includes(e[this.autocompletePropertyNames.id]))), t = t.filter((e) => e[this.autocompletePropertyNames.data] && e[this.autocompletePropertyNames.data].length), this.selectedOptions && this.selectedOptions.length) {
          const e = this.selectedOptions.map((r) => r[this.identifierPropertyName.autocompleteOption]);
          return t.map((r) => ({
            data: r[this.autocompletePropertyNames.data].filter((i) => !e.includes(i[this.identifierPropertyName.autocompleteOption])),
            [this.autocompletePropertyNames.id]: r[this.autocompletePropertyNames.id],
            [this.autocompletePropertyNames.label]: r[this.autocompletePropertyNames.label]
          }));
        }
        return t;
      }
      return [];
    },
    /**
     * list of autocomplete results used for determining currently active
     * collection // activity
     * @type {Object} consolidatedResultList
     * @returns {Object}
     */
    consolidatedResultList() {
      return this.resultListInt.reduce((t, e) => (this.$set(t, e[this.autocompletePropertyNames.id], e[this.autocompletePropertyNames.data]), t), {});
    },
    /**
     * function to determine if filter has filter values
     */
    filterHasValues() {
      return this.filter[this.identifierPropertyName.filter] !== this.defaultFilter[this.identifierPropertyName.filter] || b(this.filter.filter_values);
    },
    /**
     * map filter type
     */
    searchType() {
      if (this.filter) {
        const { type: t } = this.filter;
        return t === "chips" && !this.filter.freetext_allowed ? "controlled" : t;
      }
      return "text";
    }
  },
  watch: {
    /**
     * watch internal filter object for changes
     */
    filter: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.appliedFilter) && this.$emit("update:applied-filter", { ...t });
      },
      deep: !0
    },
    defaultFilter: {
      handler(t) {
        (!this.filter || this.filter.id === "default") && (this.filter = {
          ...t,
          // if filter is changed from outside this often means resetting a filter so previous
          // values should not be taken over (=leave second argument of function empty here)
          filter_values: this.setFilterValues(t)
        });
      },
      immediate: !0
    },
    /**
     * watch if applied filter changes from outside
     */
    appliedFilter: {
      /**
       * @param {Filter} val - the currently applied filter as set from outside
       */
      handler(t) {
        if (JSON.stringify(t) !== JSON.stringify(this.filter)) {
          const e = t || this.defaultFilter;
          this.filter = {
            ...e,
            // if filter is changed from outside this often means resetting a filter so previous
            // values should not be taken over (=leave second argument of function empty here)
            filter_values: e.filter_values || this.setFilterValues(e)
          }, t && t.filter_values ? t.type.includes("date") ? this.currentInput = t.filter_values : t.type === "text" ? this.currentInput = t.filter_values[0] || "" : this.currentInput = "" : this.currentInput = "";
        }
      },
      immediate: !0,
      deep: !0
    },
    /**
     * when current input changes emit this to parent component which should
     * do the fetching of autocomplete results (if filter type 'text') or assign
     * the values to filter.filter_values if type is 'date' or 'daterange'
     * @param {string} val - the search string
     */
    currentInput: {
      handler(t) {
        this.useAutocompleteFunctionality && this.$emit("fetch-autocomplete-results", { input: t, filter: this.filter });
      },
      immediate: !0
    },
    /**
     * if 'isActive' is set true reset the filterFade (for mobile filter view) to
     * default values
     */
    isActive(t) {
      t && (this.filterFade = {
        left: !1,
        right: !0
      }, this.activeEntry || setTimeout(() => {
        this.isActive && this.assembleAutocompleteResultsAnnouncement();
      }, 300)), !t && this.filter.type === "chips" && this.currentInput && this.currentInput.trim() ? this.filter.freetext_allowed && (!this.selectedOptions || !this.selectedOptions.some((e) => !e[this.identifierPropertyName.autocompleteOption] && e[this.labelPropertyName.autocompleteOption] === this.currentInput)) ? this.addOption({ [this.labelPropertyName.autocompleteOption]: this.currentInput }) : this.resetAllInput() : !t && this.filter.type === "text" && this.filter.filter_values.join() !== this.currentInput && this.addOption(this.currentInput), this.$emit("is-active", t);
    },
    /**
     * reset the currently active drop down autocomplete option when the list changes
     */
    autocompleteResults() {
      this.activeEntry = null, this.activeCollectionId = "", this.isActive && this.assembleAutocompleteResultsAnnouncement();
    },
    /**
     * reset the currently active controlled vocabulary option when the list changes
     */
    displayedOptions() {
      this.activeControlledVocabularyEntry = null;
    }
  },
  mounted() {
    this.getSearchInputElement(), this.initObservers();
  },
  updated() {
    this.$refs.filterBox && this.$refs.filterBox.addEventListener("scroll", this.calcFadeOut);
  },
  beforeDestroy() {
    this.resizeObserver && this.resizeObserver.unobserve(this.$refs.advancedSearchRow);
  },
  destroyed() {
    this.$refs.filterBox && this.$refs.filterBox.removeEventListener("scroll", this.calcFadeOut);
  },
  methods: {
    /** FILTER ROW RELATED FUNCTIONALITIES */
    // inform parent of click on plus or remove respectively
    addFilterRow() {
      this.$emit("add-filter-row", { filter: this.filter, input: this.currentInput });
    },
    removeFilter() {
      this.isMainSearch ? (this.filter = {
        ...this.defaultFilter,
        filter_values: this.setFilterValues(this.defaultFilter)
      }, this.resetAllInput(), this.isActive = !1) : this.$emit("remove-filter", this.filter);
    },
    /** FILTER RELATED FUNCTIONALITIES */
    /**
     * set the via click or navigation selected filter as currently
     * active filter
     *
     * @param {Filter} selectedFilter - the selected filter object
     * @property {string} selectedFilter.type - the type of the filter needed
     * to set the default filter values accordingly (array, string, object)
     */
    selectFilter(t) {
      if (t && this.filter[this.identifierPropertyName.filter] !== t[this.identifierPropertyName.filter]) {
        const e = this.filter, r = this.currentInput;
        this.filter = {
          ...t,
          // set filter values separately to be able to keep some values
          filter_values: this.setFilterValues(t, e)
        }, this.resetAllInput(), this.activeFilter = null, ["text", "chips"].includes(t.type) && ["text", "chips"].includes(e.type) && !(e.type === "text" && e.filter_values[0] === r) && (this.currentInput = r, (t.type === "text" || t.type === "chips" && t.freetext_allowed) && this.currentInput && !this.autocompleteResults.some((i) => i.filter_id === t.id) && this.$emit("fetch-autocomplete-results", { input: this.currentInput, filter: this.filter })), this.filter.type.includes("date") && (this.currentInput = this.filter.filter_values), this.filter.type === "chipssingle" && this.addOption(this.filter.options[0]);
      }
      this.searchInputElement && this.searchInputElement.focus();
    },
    /**
     * @param {KeyboardEvent} event - keyboard event bubbled from
     * filter input field
     */
    navigateFilters(t) {
      if (this.filterList.length && this.isActive && this.$refs.dropDown) {
        const e = this.filterList.indexOf(this.activeFilter), r = this.$refs.dropDown.$el;
        this.$refs.filterOption && r.scrollTop !== 0 && this.$refs.dropDown.$el.scrollTo({
          top: 0
        });
        const i = t.key === "ArrowDown";
        this.activeFilter = this.navigate(this.filterList, i, e, !0);
      }
    },
    /** CONTROLLED VOCABULARY AND AUTOCOMPLETE SELECT RELATED METHODS */
    /**
     * function to add any entry to the BaseSearch selectedChips list (since basically all
     * base search input is handled as chips)
     *
     * @param {Object} entry - the entry to add to the selected list
     * @param {string} collectionId - to set filter after adding from autocomplete a collection id
     *  is needed when option was selected by click
     */
    addOption(t, e = "") {
      const r = e || this.defaultFilter[this.identifierPropertyName.filter];
      if (!this.filterList || !this.filterList.length)
        this.$emit("option-selected", { entry: t, collectionId: r }), r !== this.defaultFilter[this.identifierPropertyName.filter] && this.resetAllInput();
      else if (this.useAutocompleteFunctionality && t[this.identifierPropertyName.autocompleteOption] && this.filter[this.identifierPropertyName.filter] !== r && !(this.filter.subsets && this.filter.subsets.length && this.filter.subsets.includes(r))) {
        const i = this.filterList.find((a) => a[this.identifierPropertyName.filter] === (this.activeCollectionId || e)) || this.defaultFilter, l = i[this.identifierPropertyName.filter] === this.defaultFilter[this.identifierPropertyName.filter] ? [].concat(t[this.labelPropertyName.autocompleteOption]) : [].concat(t), s = this.filter.filter_values && this.filter.filter_values.length === 1 && typeof this.filter.filter_values[0] == "string" ? [{
          [this.labelPropertyName.autocompleteOption]: this.filter.filter_values[0]
        }] : [];
        this.filter = {
          ...i,
          // check for filter_values property which does not exist in the filterList filters
          filter_values: s.concat(l)
        };
      } else
        this.selectedOptions = this.filter.filter_values.concat(t);
      this.filter.type !== "text" && (this.filter.type !== "chips" || this.filter.freetext_allowed || !this.displayedOptions.length) ? this.resetAllInput() : this.activeControlledVocabularyEntry = null, (this.filter.type !== "chips" || this.filter.freetext_allowed) && (this.isActive = !1);
    },
    /**
     * function triggered on BaseSearch keyboard enter. Will add the currently active option or
     * controlled vocabulary option respectively. Or if no option is active the current input text.
     * If there is no active option and no input text then the keyboard enter will be interpreted
     * as a signal to add the filter to a filter array (parent is informed)
     */
    selectOptionOnKeyEnter() {
      if (this.filter.type === "chips" && this.activeControlledVocabularyEntry)
        this.addOption(this.activeControlledVocabularyEntry);
      else if (this.useAutocompleteFunctionality && this.activeEntry)
        this.addOption(this.activeEntry, this.activeCollectionId);
      else if (this.filter.type === "text") {
        const t = [].concat(this.currentInput);
        JSON.stringify(this.filter.filter_values) !== JSON.stringify(t) ? (this.$set(this.filter, "filter_values", [].concat(this.currentInput)), this.isActive = !1) : this.isActive = !this.isActive;
      } else
        this.filter.type === "chips" && this.filter.freetext_allowed && this.currentInput && this.currentInput.trim() && (!this.selectedOptions || !this.selectedOptions.some((t) => !t[this.identifierPropertyName.autocompleteOption] && t[this.labelPropertyName.autocompleteOption] === this.currentInput)) ? this.addOption({
          [this.labelPropertyName.autocompleteOption]: this.currentInput
        }) : this.currentInput || (this.isActive = !this.isActive);
    },
    /**
     * @param {KeyboardEvent} event - the event triggered by keydown
     */
    handleKeyDownEvent(t) {
      const { key: e } = t;
      ["Tab", "Enter", " ", "Shift"].includes(e) ? e === " " && !this.currentInput && (this.isActive = !this.isActive, t.preventDefault()) : this.isActive = !0;
    },
    /**
     * create an announcement to inform about the information shown in the autocomplete
     * dropdown
     */
    assembleAutocompleteResultsAnnouncement() {
      if (this.resultListInt.length && this.assistiveText.autocompleteResultsRetrieved) {
        const t = this.resultListInt.reduce((e, r) => e + r.data.length, 0);
        this.announcement = this.assistiveText.autocompleteResultsRetrieved.replace("{optionsNumber}", t.toString()).replace("{collectionsNumber}", this.resultListInt.length.toString());
      } else
        !this.resultListInt.length && this.currentInput && this.assistiveText.autocompleteNoResults ? this.announcement = this.assistiveText.autocompleteNoResults : !this.resultListInt.length && !this.currentInput && this.assistiveText.autocompleteInitial && (this.announcement = this.assistiveText.autocompleteInitial);
    },
    /** DROP DOWN NAVIGATION */
    /**
     * event triggered on row click to open drop down and focus main input
     */
    openDropDown() {
      !this.isActive && this.mode === "list" && this.searchInputElement && this.searchInputElement.focus(), this.isActive = !0;
    },
    /**
     * primary drop down navigation deciding what arrow keys are used for
     * --> could be used for controlled vocabulary or autocomplete options
     * @param {KeyboardEvent} event - the keydown event bubbled from search input field
     */
    navigateDropDown(t) {
      t.preventDefault();
      const e = t.key === "ArrowDown";
      if (this.controlledVocabularyOptions && this.controlledVocabularyOptions.length && (t.key === "ArrowDown" || t.key === "ArrowUp")) {
        const r = this.displayedOptions.indexOf(this.activeControlledVocabularyEntry);
        this.activeControlledVocabularyEntry = this.navigate(
          this.displayedOptions,
          e,
          r,
          !0
        );
      } else
        this.navigateAutocomplete(t, e);
    },
    /**
     * navigation handling complexe autocomplete navigation with possibilities to
     * navigate single entries or collections (switch between collections and entries
     * by using left/right arrow key)
     *
     * @param {KeyboardEvent} event - the keydown event bubbled from search input field
     * @param {boolean} isArrowDown - param passed from navigateDropDown so no need to newly assign
     */
    navigateAutocomplete(t, e) {
      if (t.preventDefault(), this.resultListInt.length) {
        const r = this.activeCollectionId, { key: i } = t;
        if (i === "ArrowDown" || i === "ArrowUp") {
          this.activeCollectionId || (this.activeCollectionId = this.resultListInt[0][this.autocompletePropertyNames.id]);
          const l = this.resultListInt.map((c) => c[this.autocompletePropertyNames.id]).indexOf(this.activeCollectionId);
          let s = this.consolidatedResultList[this.activeCollectionId];
          const a = e ? 1 : -1, o = s.indexOf(this.activeEntry), n = this.isWithinArrayLimit(
            this.resultListInt,
            e,
            l + a
          );
          if (!this.collectionSelect && this.isWithinArrayLimit(
            s,
            e,
            o + a
          ))
            this.activeEntry = this.navigate(
              s,
              e,
              o
            );
          else if (!this.collectionSelect && !e && l === 0 && o === 0)
            this.activeEntry = null, this.activeCollectionId = "";
          else if (n) {
            this.activeCollectionId = this.resultListInt[l + a][this.autocompletePropertyNames.id], s = this.consolidatedResultList[this.activeCollectionId];
            const c = e || this.collectionSelect ? 0 : s.length - 1;
            this.activeEntry = s[c];
          } else
            !n && l === this.resultListInt.length - 1 && o === s.length - 1 ? (this.activeCollectionId = this.resultListInt[0][this.autocompletePropertyNames.id], s = this.consolidatedResultList[this.activeCollectionId], [this.activeEntry] = s) : !n && l === 0 && o === -1 && (this.activeCollectionId = this.resultListInt[this.resultListInt.length - 1][this.autocompletePropertyNames.id], s = this.consolidatedResultList[this.activeCollectionId], [this.activeEntry] = s.slice(-1));
        } else
          i === "ArrowLeft" ? this.collectionSelect = !0 : i === "ArrowRight" && (this.collectionSelect = !1);
        if (this.activeCollectionId && !this.collectionSelect && r !== this.activeCollectionId && this.assistiveText.categoryAnnouncement) {
          const l = this.autocompleteResults.find(({ [this.autocompletePropertyNames.id]: s }) => s === this.activeCollectionId)[this.autocompletePropertyNames.label];
          this.announcement = this.assistiveText.categoryAnnouncement.replace("{label}", l);
        }
      }
    },
    handleDropDownOnTabKey(t) {
      const e = this.$el.getElementsByTagName("input"), r = Array.from(e).filter((i) => i.id.includes("search"));
      if (e) {
        const i = r.indexOf(t.target);
        (!t.shiftKey && i >= r.length - 1 || t.shiftKey && i <= 0) && (this.isActive = !1);
      }
    },
    /**
     * handle the date input after it was validated (necessary to only assign valid date input
     * to filter_values)
     *
     * @param {string|Object} data - the date data in question - either a single string for type
     * 'date' or an object with date_from and date_to for type 'daterange'
     */
    handleDateInput(t) {
      this.filter.type.includes("date") && JSON.stringify(t) !== JSON.stringify(this.filter.filter_values) && (this.currentInput = t, this.$set(this.filter, "filter_values", this.currentInput), this.isActive = !1);
    },
    /** OTHERS */
    /**
         * function to set the correct values for filter.filter_values attribute
         *
         * @param {Filter} newFilter - the newly selected filter
         * @param {Filter} previousFilter - the previously set filter
    
         * @returns {?string|Array|Object} the correct value type for the filter type
         */
    setFilterValues(t, e = {}) {
      const r = e.filter_values, { type: i } = t, l = t.freetext_allowed;
      return i === "date" ? e.type && e.type.includes("date") && r ? r.date_from || r.date_to : "" : i === "daterange" ? e.type.includes("date") ? {
        date_from: r && (r.date_from || r) || "",
        date_to: r && r.to ? r.to : ""
      } : {
        date_from: "",
        date_to: ""
      } : i === "chips" && l && e.type === "chips" && e.freetext_allowed ? t.subsets && t.subsets.includes(e[this.identifierPropertyName.filter]) ? r : r && r.length ? r.filter((s) => !s[this.identifierPropertyName.autocompleteOption]) : [] : e.type === "text" && r && r.length && r[0] && i === "chips" && l ? [{
        [this.labelPropertyName.autocompleteOption]: r[0]
      }] : [];
    },
    /**
     * reset all filter row input and navigational variables
     */
    resetAllInput() {
      this.currentInput = "", this.activeEntry = null, this.activeCollectionId = "", this.activeControlledVocabularyEntry = null;
    },
    /**
     * needed for mobile filter view to determine when to show fade out on filter list
     *
     * @param {Event} event - the event that triggered the recalculation
     */
    calcFadeOut(t) {
      const e = t.target, r = e.scrollLeft, i = e.scrollWidth - e.clientWidth;
      this.filterFade = {
        // show fade out left as soon as scroll position is different from 0
        left: r !== 0,
        // show fade out right as soon as scroll position is different from maximum position
        right: r !== i
      };
    },
    /**
     * function called on tab keydown on row 'x' or '+' icon
     * @param {KeyboardEvent} event - the keydown event
     */
    onTab(t) {
      t.shiftKey || (this.isActive = !1);
    },
    /**
     * on touch devices click-outside is not only triggered by 'touchstart' instead of 'click'.
     *  this means the 'click-outside' event gets propagated before the 'click' event on touch devices (on
     *  desktop browsers it is the other way round). This leads to search drop down getting
     *  triggered when an element INSIDE search was clicked (in case of desktop when click-outside
     *  is propagated AFTER this leads to isActive = false again immediately after so no drop
     *  down showing). Therefore, we need to check for mobile event and set variable stopSearchClick
     *  to true so in event onSearchClick the click can be stopped from opening the drop-down.
     *
     * @param {MouseEvent|TouchEvent} event - the event provided by click-outside plugin
     */
    onClickedOutsideSearch(t) {
      this.isActive = !1;
      const { type: e } = t;
      e === "touchstart" && (this.stopSearchClick = !0, setTimeout(() => {
        this.stopSearchClick = !1;
      }, 500));
    },
    /**
     * need to special handle search click event due to the reasons described above in function
     *  onClickedOutsideSearch().
     *
     * @param {MouseEvent} event - the native click event
     */
    onSearchClick(t) {
      this.stopSearchClick ? (t.stopPropagation(), this.isActive = !1, this.stopSearchClick = !1) : this.isActive = !0;
    },
    initObservers() {
      const t = new MutationObserver(this.filterChangeObserverAction);
      t.observe(this.$refs.advancedSearchRow, {
        subtree: !0,
        childList: !0
      }), this.observer = t;
      const e = new ResizeObserver(this.resizeActions);
      e.observe(this.$refs.advancedSearchRow), this.resizeObserver = e;
    },
    filterChangeObserverAction() {
      this.getSearchInputElement(), this.filter.type !== this.currentFilterType && this.isActive && this.searchInputElement && (this.searchInputElement.focus(), this.currentFilterType = this.filter.type);
    },
    /**
     * calculate the number of columns for filters and chips dynamically and
     * use correct slot for selected filter depending on element size
     */
    resizeActions() {
      const t = this.$refs.advancedSearchRow, e = this.$refs.baseSearch;
      if (e) {
        const r = e.$el.clientWidth;
        this.$el.style.setProperty(
          "--col-number",
          Math.floor((r - r / 4) / 180) || 1
        );
      }
      if (t) {
        const r = t.clientWidth;
        this.filterSlotName = r >= 500 ? "pre-input-field" : "input-field-addition-before";
      }
    },
    /**
     * function to get the current search input element
     */
    getSearchInputElement() {
      const t = this.$el.getElementsByTagName("input");
      t && t.length && (this.searchInputElement = Array.from(t).find((e) => e.id.includes("search-input") && e.id.includes(this.searchRowId)));
    }
  }
};
var x = function() {
  var e = this, r = e._self._c;
  return r("div", { ref: "advancedSearchRow", staticClass: "base-advanced-search-row", on: { click: e.openDropDown } }, [r("BaseSearch", e._g({ ref: "baseSearch", class: [
    "base-advanced-search-row__search",
    { "base-advanced-search-row__search__shadow": e.applyBoxShadow }
  ], attrs: { id: "search-input-" + e.internalRowId, "show-pre-input-icon": e.isMainSearch && e.filter[e.identifierPropertyName.filter] === e.defaultFilter[e.identifierPropertyName.filter], label: e.assistiveText.searchLabel || "Search for Entries", type: e.searchType, "selected-chips": e.selectedOptions, loadable: e.filter.type === "text" || e.filter.type === "chips", "is-loading": e.isLoading, placeholder: e.placeholder, "drop-down-list-id": e.searchType === "controlled" ? `controlled-options-${e.internalRowId}` : "autocomplete-options-" + e.internalRowId, language: e.language, "identifier-property-name": e.useAutocompleteFunctionality ? e.identifierPropertyName.autocompleteOption : e.identifierPropertyName.controlledVocabularyOption, "label-property-name": e.useAutocompleteFunctionality ? e.labelPropertyName.autocompleteOption : e.labelPropertyName.controlledVocabularyOption, "is-active": e.isActive, "set-focus-on-active": !1, clearable: !1, "assistive-text": {
    selectedOption: e.assistiveText.selectedOption,
    loaderActive: e.assistiveText.loaderActive,
    results: e.assistiveText.results
  }, "date-field-delay": e.dateFieldDelay, "linked-list-option": e.activeEntry ? e.collectionSelect ? e.activeCollectionId : e.activeEntry[e.identifierPropertyName.autocompleteOption] : e.activeControlledVocabularyEntry ? e.activeControlledVocabularyEntry[e.identifierPropertyName.controlledVocabularyOption] : void 0 }, on: { "update:selectedChips": function(i) {
    e.selectedOptions = i;
  }, "update:selected-chips": function(i) {
    e.selectedOptions = i;
  }, "update:isActive": function(i) {
    e.isActive = i;
  }, "update:is-active": function(i) {
    e.isActive = i;
  }, "clicked-outside": e.onClickedOutsideSearch, keydown: [e.handleKeyDownEvent, function(i) {
    return !i.type.indexOf("key") && e._k(i.keyCode, "up", 38, i.key, ["Up", "ArrowUp"]) && e._k(i.keyCode, "down", 40, i.key, ["Down", "ArrowDown"]) && e._k(i.keyCode, "right", 39, i.key, ["Right", "ArrowRight"]) && e._k(i.keyCode, "left", 37, i.key, ["Left", "ArrowLeft"]) || "button" in i && i.button !== 2 || "button" in i && i.button !== 0 ? null : e.navigateDropDown.apply(null, arguments);
  }, function(i) {
    return !i.type.indexOf("key") && e._k(i.keyCode, "tab", 9, i.key, "Tab") ? null : e.handleDropDownOnTabKey.apply(null, arguments);
  }, function(i) {
    if (!i.type.indexOf("key") && e._k(i.keyCode, "esc", 27, i.key, ["Esc", "Escape"]))
      return null;
    e.isActive = !1;
  }], "!keydown": function(i) {
    return !i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : e.selectOptionOnKeyEnter.apply(null, arguments);
  }, "value-validated": e.handleDateInput }, nativeOn: { click: function(i) {
    return e.onSearchClick.apply(null, arguments);
  } }, scopedSlots: e._u([{ key: e.filterSlotName, fn: function() {
    return [e.mode === "list" ? r("BaseChipsInputField", { class: [
      "base-advanced-search-row__first-column",
      {
        "base-advanced-search-row__first-column__small": e.filterSlotName === "input-field-addition-before"
      },
      "base-advanced-search-row__filter-input",
      {
        hide: e.isMainSearch && e.filter[e.identifierPropertyName.filter] === e.defaultFilter[e.identifierPropertyName.filter]
      },
      {
        "base-advanced-search-row__filter-input__date": e.filter.type.includes("date")
      }
    ], attrs: { id: "search-filter-select-" + e.internalRowId, "selected-list": e.selectedFilter, "allow-multiple-entries": !1, "allow-unknown-entries": !1, "allow-dynamic-drop-down-entries": !1, "linked-list-option": e.activeFilter ? `filter-option-${e.activeFilter[e.identifierPropertyName.filter]}` : null, "use-form-field-styling": !1, "show-input-border": !1, "show-label": !1, label: e.assistiveText.selectFilterLabel || "Select filter", language: e.language, "drop-down-list-id": "filter-options-" + e.internalRowId, "identifier-property-name": e.identifierPropertyName.filter, "label-property-name": e.labelPropertyName.filter, "input-class": e.filterSlotName === "input-field-addition-before" ? "" : "base-advanced-search-row__input-field" }, on: { "update:selectedList": function(i) {
      e.selectedFilter = i;
    }, "update:selected-list": function(i) {
      e.selectedFilter = i;
    }, click: function(i) {
      e.isActive = !0;
    }, keydown: [e.handleKeyDownEvent, function(i) {
      return !i.type.indexOf("key") && e._k(i.keyCode, "tab", 9, i.key, "Tab") ? null : e.handleDropDownOnTabKey.apply(null, arguments);
    }, function(i) {
      return !i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : e.selectFilter(e.activeFilter);
    }, function(i) {
      return !i.type.indexOf("key") && e._k(i.keyCode, "up", 38, i.key, ["Up", "ArrowUp"]) && e._k(i.keyCode, "down", 40, i.key, ["Down", "ArrowDown"]) ? null : e.navigateFilters.apply(null, arguments);
    }] }, scopedSlots: e._u([{ key: "chip", fn: function({ entry: i }) {
      return [r("span", { key: "chip-" + i.idInt, staticClass: "base-advanced-search-row__selected-filter-label", attrs: { id: i.idInt } }, [e._v(" " + e._s(`#${e.getLangLabel(i[e.labelPropertyName.filter], !0)}`) + " ")])];
    } }], null, !1, 3344849930) }) : e._e()];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [!e.isMainSearch || e.filterHasValues || e.filter.type === "text" && e.currentInput ? r("button", { class: [
      "base-advanced-search-row__icon-button",
      { "base-advanced-search-row__icon-button__date": e.filter.type.includes("date") }
    ], on: { keydown: function(i) {
      return !i.type.indexOf("key") && e._k(i.keyCode, "tab", 9, i.key, "Tab") ? null : e.onTab.apply(null, arguments);
    }, focusin: function(i) {
      i.stopPropagation(), i.preventDefault();
    }, click: function(i) {
      return i.stopPropagation(), i.preventDefault(), e.removeFilter.apply(null, arguments);
    } } }, [r("BaseIcon", { staticClass: "base-advanced-search-row__search-row-icon", attrs: { title: e.assistiveText.removeFilter || "Remove filter", name: "remove" } })], 1) : e._e(), e._t("after")];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e.isActive ? r("BaseDropDownList", { ref: "dropDown", staticClass: "base-advanced-search-row__drop-down-body", attrs: { "drop-down-options": e.resultListInt, "active-option": { [e.autocompletePropertyNames.id]: e.activeCollectionId }, "list-id": "autocomplete-options-" + e.internalRowId, "active-styled": !1, "has-sub-options": !0, "display-as-drop-down": !1, "use-custom-option-active-background-color": !0, language: e.language, "identifier-property-name": e.autocompletePropertyNames.id, "label-property-name": e.autocompletePropertyNames.data, "list-body-style": {
      "max-height": "400px",
      "overflow-y": "auto"
    } }, nativeOn: { touchstart: function(i) {
      i.stopPropagation();
    }, click: function(i) {
      i.stopPropagation();
    } }, scopedSlots: e._u([e.mode === "list" ? { key: "before-list", fn: function() {
      return [r("div", { class: [
        "base-advanced-search-row__above-list-area",
        "base-advanced-search-row__area-padding",
        {
          "base-advanced-search-row__above-list-area-filters": e.filter.type === "text" || e.filter.type === "chips"
        }
      ] }, [r("div", { staticClass: "base-advanced-search-row__filter-area-wrapper" }, [r("div", { staticClass: "base-advanced-search-row__first-column base-advanced-search-row__filter-area" }, [r("div", { staticClass: "base-advanced-search-row__filter-area-header" }, [r("div", { staticClass: "base-advanced-search-row__filter-text" }, [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.advancedSearchText.title))) + " ")]), r("div", { staticClass: "base-advanced-search-row__filter-subtext" }, [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.advancedSearchText.subtext))) + " ")])]), r("span", { staticClass: "base-advanced-search-row__filter-area-close", on: { keydown: function(i) {
        if (!i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter"))
          return null;
        e.isActive = !1;
      }, click: function(i) {
        i.stopPropagation(), e.isActive = !1;
      } } }, [r("BaseIcon", { staticClass: "rotate-180 base-advanced-search-row__filter-area-close-icon", attrs: { name: "drop-down" } })], 1)]), r("div", { class: [
        "base-advanced-search-row__columns",
        "base-advanced-search-row__filter-list-wrapper",
        {
          "base-advanced-search-row__filter-list-wrapper__fade-right": e.filterFade.right
        },
        {
          "base-advanced-search-row__filter-list-wrapper__fade-left": e.filterFade.left
        }
      ] }, [r("ul", { ref: "filterBox", staticClass: "base-advanced-search-row__filter-list", attrs: { id: "filter-options-" + e.internalRowId, role: "listbox" } }, e._l(e.displayFilterList, function(i, l) {
        return r("li", { key: l, ref: "filterOption", refInFor: !0, staticClass: "base-advanced-search-row__filter base-advanced-search-row__column-item", class: [
          {
            "base-advanced-search-row__filter-active": e.activeFilter === i
          },
          {
            "base-advanced-search-row__filter-selected": e.filter && e.filter[e.identifierPropertyName.filter] === i[e.identifierPropertyName.filter]
          }
        ], attrs: { id: `filter-option-${i[e.identifierPropertyName.filter]}`, "aria-selected": (e.filter && e.filter[e.identifierPropertyName.filter] === i[e.identifierPropertyName.filter]).toString(), tabindex: "-1", role: "option" }, on: { keydown: function(s) {
          return !s.type.indexOf("key") && e._k(s.keyCode, "enter", 13, s.key, "Enter") ? null : (s.stopPropagation(), e.selectFilter(i));
        }, click: function(s) {
          return s.stopPropagation(), e.selectFilter(i);
        } } }, [e._v(" " + e._s(`#${i[e.labelPropertyName.filter]}`) + " ")]);
      }), 0)])])])];
    }, proxy: !0 } : null, { key: "option", fn: function({ option: i }) {
      return [!e.filter || e.useAutocompleteFunctionality ? r("div", { staticClass: "base-advanced-search-row__autocomplete-body" }, [i[e.autocompletePropertyNames.data].length ? r("div", { class: [
        "base-advanced-search-row__first-column",
        "base-advanced-search-row__autocomplete-collection"
      ] }, [r("div", { staticClass: "base-advanced-search-row__autocomplete-collection-text" }, [e._v(" " + e._s(i[e.autocompletePropertyNames.label]) + " "), e.assistiveText.optionsAnnouncement ? r("span", { staticClass: "hide" }, [e._v(e._s(e.assistiveText.optionsAnnouncement.replace("{number}", i[e.autocompletePropertyNames.data].length)))]) : e._e()])]) : e._e(), r("BaseDropDownList", { staticClass: "base-advanced-search-row__autocomplete-options", attrs: { "drop-down-options": i[e.autocompletePropertyNames.data], "active-option": e.activeCollectionId === i[e.autocompletePropertyNames.id] ? e.activeEntry : {}, "display-as-drop-down": !1, "list-id": "autocomplete-options-" + e.internalRowId, language: e.language, "identifier-property-name": e.identifierPropertyName.autocompleteOption, "label-property-name": e.labelPropertyName.autocompleteOption, "use-highlight-string-match": e.highlightAutocompleteMatch, "highlight-string-tags": e.highlightAutocompleteTags, "highlight-string-match": e.currentInput }, on: { "update:selected-option": function(l) {
        return e.addOption(
          l,
          i[e.autocompletePropertyNames.id]
        );
      } }, scopedSlots: e._u([{ key: "option", fn: function({ option: l }) {
        return [e._t("autocomplete-option", null, { option: l, collectionId: i[e.autocompletePropertyNames.id] })];
      } }], null, !0) })], 1) : e._e()];
    } }, e.filter.type === "chips" && !e.filter.freetext_allowed ? { key: "after-list", fn: function() {
      return [r("div", { staticClass: "base-advanced-search-row__above-list-area base-advanced-search-row__chips-area base-advanced-search-row__area-padding" }, [r("div", { class: [
        "base-advanced-search-row__chips-row",
        {
          "base-advanced-search-row__chips-row__no-options": e.filter.type === "chips" && !e.displayedOptions.length
        }
      ] }, [r("div", { staticClass: "base-advanced-search-row__controlled-options-title base-advanced-search-row__first-column" }, [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.advancedSearchText.availableOptions))) + " ")]), e.controlledVocabularyOptions && e.displayedOptions.length && (e.displayedOptions.length <= e.maxNumberControlledOptions || e.currentInput && e.currentInput.length >= 4) ? r("ul", { staticClass: "base-advanced-search-row__chips-list base-advanced-search-row__columns", attrs: { id: `controlled-options-${e.internalRowId}`, role: "listbox" } }, e._l(e.displayedOptions, function(i) {
        return r("li", { key: i[e.identifierPropertyName.controlledVocabularyOption], staticClass: "base-advanced-search-row__column-item", attrs: { id: i[e.identifierPropertyName.controlledVocabularyOption], value: i[e.labelPropertyName.controlledVocabularyOption], "aria-selected": (e.activeControlledVocabularyEntry && i[e.identifierPropertyName.controlledVocabularyOption] === e.activeControlledVocabularyEntry[e.identifierPropertyName.controlledVocabularyOption] || !1).toString(), role: "option", tabindex: "0" }, on: { mouseenter: function(l) {
          e.activeControlledVocabularyEntry = i;
        }, focusin: function(l) {
          e.activeControlledVocabularyEntry = i;
        }, mouseleave: function(l) {
          e.activeControlledVocabularyEntry = null;
        }, focusout: function(l) {
          e.activeControlledVocabularyEntry = null;
        } } }, [r("BaseChip", { staticClass: "base-advanced-search-row__option-chip", attrs: { "is-removable": !1, entry: e.getLangLabel(i[e.labelPropertyName.controlledVocabularyOption]), "chip-active": e.activeControlledVocabularyEntry && i[e.identifierPropertyName.controlledVocabularyOption] === e.activeControlledVocabularyEntry[e.identifierPropertyName.controlledVocabularyOption] }, on: { clicked: function(l) {
          return e.addOption(i);
        } } })], 1);
      }), 0) : e.isLoading ? r("div", { staticClass: "base-advanced-search-row__no-options base-advanced-search-row__area-padding" }, [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.dropDownInfoTexts.chipsOngoing, !0))) + " ")]) : e.displayedOptions.length > e.maxNumberControlledOptions && (!e.currentInput || e.currentInput.length < 4) ? r("div", { staticClass: "base-advanced-search-row__no-options base-advanced-search-row__area-padding" }, [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.dropDownInfoTexts.chipsMaxOptions, !0))) + " ")]) : e.currentInput && e.currentInput.length && !e.displayedOptions.length ? r("div", { staticClass: "base-advanced-search-row__no-options base-advanced-search-row__area-padding" }, [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.dropDownInfoTexts.chipsNoMatch, !0))) + " ")]) : e.displayedOptions.length ? e._e() : r("div", { staticClass: "base-advanced-search-row__no-options base-advanced-search-row__area-padding" }, [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.dropDownInfoTexts.chipsNoOptions, !0))) + " ")])])])];
    }, proxy: !0 } : null, { key: "no-options", fn: function() {
      return [e.useAutocompleteFunctionality ? r("div", { class: [
        "base-advanced-search-row__no-options",
        { "base-advanced-search-row__no-options-hidden": !e.useAutocompleteFunctionality }
      ] }, [!e.currentInput || typeof e.currentInput == "string" && !e.currentInput.trim() ? r("div", [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.dropDownInfoTexts.autocompleteInitial, !0))) + " ")]) : e.isLoading ? r("div", [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.dropDownInfoTexts.autocompleteOngoing, !0))) + " ")]) : r("div", [e._v(" " + e._s(e.getI18nTerm(e.getLangLabel(e.dropDownInfoTexts.autocompleteNoOptions, !0))) + " ")])]) : e._e()];
    }, proxy: !0 }], null, !0) }) : e._e(), e._t("below")];
  }, proxy: !0 }], null, !0), model: { value: e.currentInput, callback: function(i) {
    e.currentInput = i;
  }, expression: "currentInput" } }, e.$listeners)), e.mode === "list" && e.isMainSearch ? r("BaseButton", { class: [
    "base-advanced-search-row__add-filter-button",
    { "base-advanced-search-row__add-filter-button__shadow": e.applyBoxShadow }
  ], attrs: { icon: "plus", "button-style": "row", "icon-position": "right" }, on: { clicked: e.addFilterRow }, nativeOn: { click: function(i) {
    i.stopPropagation();
  } }, scopedSlots: e._u([{ key: "text", fn: function({ labelId: i }) {
    return [r("span", { staticClass: "base-advanced-search-row__add-filter-button__text", attrs: { id: i } }, [e._v(" " + e._s(e.assistiveText.addFilter || "Add filter") + " ")])];
  } }], null, !1, 773239955) }) : e._e()], 1);
}, P = [], C = /* @__PURE__ */ I(
  N,
  x,
  P,
  !1,
  null,
  "5e56cf87",
  null,
  null
);
const z = C.exports;
export {
  z as default
};
//# sourceMappingURL=BaseAdvancedSearchRow.vue.es.js.map
