import "./BaseMap.vue.es2.js";
import "./BaseMap.vue.es3.js";
import u from "../../_virtual/_plugin-vue2_normalizer.es.js";
const p = {
  name: "BaseMap",
  props: {
    /**
     * define map attribution
     */
    attribution: {
      type: String,
      default: 'Source: <a href="https://openstreetmap.org/">OpenStreetMap contributors</a>'
    },
    /**
     * define position of map attribution
     *   @values topright, bottomleft, bottomright
     */
    attributionPosition: {
      type: String,
      default: "bottomright",
      validator: (t) => ["topright", "bottomleft", "bottomright"].includes(t)
    },
    /**
     * set array index of marker to center map from outside
     */
    centerMarker: {
      type: Number,
      default: null
    },
    /**
     * define number of items for cluster sizes
     *   structure: `{ medium: 5, large: 20, xlarge: 100 }`
     *   Note: properties `medium`, `large`, `xlarge` are mandatory
     */
    clusterSizes: {
      type: Object,
      default: () => ({ medium: 5, large: 20, xlarge: 100 }),
      validator: (t) => t.medium && t.large && t.xlarge
    },
    /**
     * define map copyright
     */
    copyright: {
      type: String,
      default: "<a href=http://creativecommons.org/licenses/by-sa/3.0/>CC BY-SA 3.0</a>"
    },
    /**
     * set array index of marker to highlight it from outside
     */
    highlightMarker: {
      type: Number,
      default: null
    },
    /**
     * define html code for a custom icon
     */
    icon: {
      type: String,
      // eslint-disable-next-line max-len
      default: '<svg viewBox="0 0 70.866 70.866" xmlns="http://www.w3.org/2000/svg"><path d="m35.433 0a22.731 22.731 0 0 0-22.731 22.82 24.125 24.125 0 0 0 1.872 9.1814l19.611 38.063a1.3718 1.3718 0 0 0 2.496 0l19.611-38.063a22.249 22.249 0 0 0 1.872-9.1814 22.731 22.731 0 0 0-22.731-22.82zm0 32.858a10.216 10.216 0 1 1 10.216-10.216 10.241 10.241 0 0 1-10.216 10.216z" fill="#010101"/></svg>'
    },
    /**
     * define icon size
     */
    iconSize: {
      type: Number,
      default: 32
    },
    /**
     * define custom options for map data
     *   e.g. {
     *          style: 'normal',
     *          subdomains: ['mapsneu'],
     *          tileMatrixSet: 'google3857',
     *          type: 'geolandbasemap'
     *   }
     *
     *   usage custom keys in `url` property:
     *   https://{s}.wien.gv.at/basemap/{type}/{style}/{tileMatrixSet}/{z}/{y}/{x}.png
     *
     *   for more information refer to the [Leaflet TileLayer documentation](https://leafletjs.com/reference.html#tilelayer)
     */
    options: {
      type: Object,
      default: () => ({})
    },
    /**
     * define marker
     *   structure: [{
     *     coordinates: [16.382782, 48.208309],
     *     latLng: [48.208309, 16.382782],
     *     data: [ 'University of Applied Arts', 'Oskar Kokoschka-Platz 2',
     *     '1010 Vienna', 'Austria']
     *   }]
     *   Note: either GeoJSON coordinates or latLng is mandatory
     */
    marker: {
      type: Array,
      default: () => [],
      validator: (t) => t.every((e) => e.latLng || e.coordinates)
    },
    /**
     * show popups for marker
     */
    markerPopups: {
      type: Boolean,
      default: !0
    },
    /**
     * define max zoom factor
     */
    maxZoom: {
      type: Number,
      default: 18
    },
    /**
     * define url to tileLayer service
     */
    url: {
      type: String,
      default: ""
    },
    /**
     * specify service for the [tileLayer](https://leafletjs.com/examples/wms/wms.html)
     * @values WMTS, TMS, WMS'
     */
    tileLayerService: {
      type: String,
      default: "WMTS",
      validator(t) {
        return ["WMTS", "TMS", "WMS"].includes(t);
      }
    },
    /**
     * define initial zoom factor
     */
    zoom: {
      type: Number,
      default: 16
    }
  },
  data() {
    return {
      L: null,
      map: null,
      activePopUp: null,
      boundsPadding: [0, 20],
      highlightedMarker: null,
      markerClass: "base-map-marker-icon",
      markerClusterClass: "base-map-marker-cluster",
      popupOptions: {
        offset: [10, -25],
        closeButton: !1,
        keepInView: !0
      },
      scrollWheelZoom: !1
    };
  },
  computed: {
    // Observer to check if component is in viewport and init map
    observer() {
      return new IntersectionObserver((t, e) => {
        t.forEach((r) => {
          r.isIntersecting && (e.unobserve(r.target), this.init());
        });
      });
    },
    cssProps() {
      return {
        "--leaflet-popup-offset-bottom": `${this.popupOptions.offset[1]}px`
      };
    },
    // compare marker objects and remove duplicates
    markerFiltered() {
      return Array.from(new Set(this.marker.map(JSON.stringify))).map(JSON.parse);
    }
  },
  watch: {
    centerMarker(t) {
      t !== null && this.map.setView(
        this.getLatLng(this.markerFiltered[t]),
        this.zoom
      );
    },
    highlightMarker(t, e) {
      if (t !== null) {
        this.map.closePopup(), this.resetAllMarker(), this.map.eachLayer((i) => {
          if (i._bounds && i._icon) {
            const l = this.getLatLng(this.markerFiltered[t]);
            if (this.L.latLngBounds(i._bounds).contains(l)) {
              i._icon.classList.add(`${this.markerClusterClass}--active`);
              return;
            }
          }
          i.options.id != null && i.options.id === t && (this.highlightedMarker = i._icon, this.highlightedMarker.classList.add(`${this.markerClass}--active`));
        });
        return;
      }
      this.highlightedMarker != null && this.activePopUp !== e && (this.highlightedMarker.classList.remove(`${this.markerClass}--active`), this.highlightedMarker = null);
      const r = this.$el.querySelector(`.${this.markerClusterClass}--active`);
      r && r.classList.remove(`${this.markerClusterClass}--active`);
    }
  },
  beforeDestroy() {
    this.observer.disconnect();
  },
  mounted() {
    this.observer.observe(this.$el);
  },
  methods: {
    async init() {
      if (this.L)
        return;
      this.L = await import("leaflet");
      const { ResponsivePopup: t } = await import("leaflet-responsive-popup"), { MarkerClusterGroup: e } = await import("leaflet.markercluster");
      this.map = this.L.map(this.$refs.mapElement, {
        scrollWheelZoom: this.scrollWheelZoom,
        tap: !1
        // fix clickEvent for macOS Safari
      }), this.map.attributionControl.setPosition(this.attributionPosition);
      const r = {
        maxZoom: this.maxZoom,
        attribution: [this.attribution, this.copyright].join(", "),
        tms: this.tileLayerService === "TMS",
        ...this.options
      };
      if (this.tileLayerService === "WMS" ? this.L.tileLayer.wms(this.url, r).addTo(this.map) : this.L.tileLayer(this.url, r).addTo(this.map), !this.markerFiltered.length)
        return;
      const i = {
        className: this.markerClass,
        html: this.icon,
        iconSize: [this.iconSize, this.iconSize],
        iconAnchor: [this.iconSize / 2, this.iconSize]
      }, l = this.L.divIcon(i);
      if (this.markerCluster = new e({
        maxClusterRadius: 50,
        showCoverageOnHover: !1,
        iconCreateFunction: (s) => {
          const n = s.getAllChildMarkers().length;
          let a = "small", o = 48;
          return n > this.clusterSizes.medium && (a = "medium", o = 64), n > this.clusterSizes.large && (a = "large", o = 80), n > this.clusterSizes.xlarge && (a = "xlarge", o = 128), this.L.divIcon({
            html: `<div class="${this.markerClusterClass}__inner">${n}</div>`,
            className: `${this.markerClusterClass} ${this.markerClusterClass}--${a}`,
            iconSize: this.L.point(o, o)
          });
        }
      }), this.markerFiltered.forEach((s, n) => {
        const a = new t(this.popupOptions), o = {
          id: n,
          icon: l
        };
        if (!this.getLatLng(s))
          return;
        const h = this.L.marker(this.L.latLng(this.getLatLng(s)), o).on("mouseover", this.activateMarker).on("mouseout", this.resetMarker);
        this.markerPopups && Array.isArray(s.data) && (a.setContent(s.data.join("<br>")), h.bindPopup(a)), this.markerCluster.addLayer(h);
      }), this.map.addLayer(this.markerCluster), !this.markerFiltered.filter((s) => s.latLng || s.coordinates).length)
        return;
      const m = new this.L.LatLngBounds(
        this.markerFiltered.map((s) => this.getLatLng(s))
      );
      this.map.fitBounds(m, {
        padding: this.boundsPadding,
        maxZoom: this.zoom
      });
    },
    activateMarker(t) {
      const { id: e } = t.target.options, r = t.target._icon;
      this.resetAllMarker(), t.target.options.active || (this.activePopUp = e, this.markerState(e), r.classList.add(`${this.markerClass}--active`), t.target.options.active = !0);
    },
    resetMarker(t) {
      t.target._icon.classList.remove(`${this.markerClass}--active`), this.activePopUp = null, this.markerState(null), delete t.target.options.active;
    },
    resetAllMarker() {
      this.map.eachLayer((t) => {
        const e = t._icon;
        e && (e.classList.remove(`${this.markerClass}--active`), e.classList.remove(`${this.markerClusterClass}--active`), this.activePopUp = null, this.markerState(null), delete t.options.active);
      });
    },
    markerState(t) {
      this.$emit("highlighted", t);
    },
    getLatLng(t) {
      return t.coordinates ? [t.coordinates[1], t.coordinates[0]] : t.latLng ? t.latLng : null;
    }
  }
};
var d = function() {
  var e = this, r = e._self._c;
  return r("div", { ref: "mapElement", staticClass: "base-map", style: e.cssProps });
}, g = [], f = /* @__PURE__ */ u(
  p,
  d,
  g,
  !1,
  null,
  "10156f65",
  null,
  null
);
const C = f.exports;
export {
  C as default
};
//# sourceMappingURL=BaseMap.vue.es.js.map
