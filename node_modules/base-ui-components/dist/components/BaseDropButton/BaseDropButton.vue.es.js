import p from "vue-click-outside";
import l from "../BaseButton/BaseButton.vue.es.js";
import d from "../BaseDropDownList/BaseDropDownList.vue.es.js";
import u from "../BaseIcon/BaseIcon.vue.es.js";
import c from "../../mixins/navigateList.es.js";
import "./BaseDropButton.vue.es2.js";
import f from "../../_virtual/_plugin-vue2_normalizer.es.js";
const h = {
  name: "BaseDropButton",
  components: {
    BaseDropDownList: d,
    BaseButton: l,
    BaseIcon: u
  },
  directives: {
    ClickOutside: p
  },
  mixins: [c],
  props: {
    /**
     * array of button options
     * specify an array of strings naming the action (in case label and icon are handled via slot)
     * or objects with `action`, `label` and `icon` (`action` and `label` may be customized
     * via `identifierPropertyName` and `labelPropertyName` respectively)
     */
    buttons: {
      type: Array,
      default: () => []
    },
    /**
     * specify either a button object or the identifier value of one of the items in
     * the buttons array that should be shown as primary button - always visible.
     * in case a string is provided an object with that identifier should be present in the buttons
     * array!
     */
    primaryButton: {
      type: [Object, String],
      default: null
    },
    /**
     * add a description for the expand button - purely for accessibility
     * functionalities
     */
    expandButtonLabel: {
      type: String,
      default: "Show more Options"
    },
    /**
     * specify a custom buttons array object property that should be used as
     * identifier
     */
    identifierPropertyName: {
      type: String,
      default: "action"
    },
    /**
     * specify a custom buttons array object property that should be used as
     * label
     */
    labelPropertyName: {
      type: String,
      default: "label"
    }
  },
  data() {
    return {
      /**
       * handle hiding and showing of drop down options
       * @type {boolean}
       */
      showOptions: !1,
      /**
       * the currently active option when navigating via keys
       * @type {?Object}
       */
      activeOption: null,
      /**
       * a variable to steer the css classes for drop down positioning (this way
       * scss variables can still be used)
       * @type {Object}
       * @property {string} dropDownPosition.horizontal - to position drop down 'left' or 'right'
       * @property {string} dropDownPosition.vertical - to position drop down 'top' or 'bottom'
       */
      dropDownPosition: {
        horizontal: "right",
        vertical: "bottom"
      },
      /**
       * a variable to add additional styling to the drop-down in case there is not enough space
       * to handle positioning with css classes - since used for HTML attribute 'style' either an
       * object with 'transform' property or 'false' so that attribute is not shown
       * @type {boolean|Object}
       */
      dropDownTransformation: !1
    };
  },
  computed: {
    /**
     * get the primary button - since prop 'primaryButton' can be either a string with the
     * identifier or the complete object - it is handled here to have the complete object
     * available for primary button
     * @returns {Object}
     */
    primaryButtonInt() {
      return this.primaryButton ? typeof this.primaryButton == "object" ? this.primaryButton : this.buttons.find((e) => this.primaryButton === e[this.identifierPropertyName]) : this.buttons[0];
    },
    /**
     * filter the buttons for the primary button to not have it shown double
     * @returns {Object[]}
     */
    buttonsInt() {
      return this.buttons.filter((e) => e[this.identifierPropertyName] !== this.primaryButtonInt[this.identifierPropertyName]);
    }
  },
  watch: {
    buttonsInt() {
      this.calculateDropDownPosition();
    },
    showOptions(e) {
      e ? this.$nextTick(() => {
        this.calculateDropDownPosition();
      }) : this.activeOption = null;
    }
  },
  mounted() {
    window && window.addEventListener("resize", this.calculateDropDownPosition);
  },
  destroyed() {
    window.removeEventListener("resize", this.calculateDropDownPosition);
  },
  methods: {
    /**
     * function triggered on enter key event
     */
    dropDownEnterAction() {
      this.activeOption ? this.fireAction(this.activeOption[this.identifierPropertyName]) : this.showOptions = !this.showOptions;
    },
    /**
     * function triggered on key up or down and tab key
     * @param {KeyboardEvent} event
     */
    navigateOptions(e) {
      const t = e.key === "ArrowDown" || e.key === "Tab" && !e.shiftKey, n = this.buttonsInt.indexOf(this.activeOption);
      this.activeOption = this.navigate(
        this.buttonsInt,
        t,
        n,
        !0
      );
    },
    /**
     * function to inform parent that action was triggered (by click or enter)
     * @param {string} actionType
     */
    fireAction(e) {
      this.showOptions = !1, this.$emit("clicked", e);
    },
    /**
     * function to calculate correct drop down position within window limits
     */
    calculateDropDownPosition() {
      if (this.$refs.dropDown) {
        const e = window.visualViewport.width, t = this.$refs.dropDown.$el.getBoundingClientRect(), n = this.$refs.dropArea.getBoundingClientRect(), o = n.x, i = o + n.width, r = n.y, a = r + n.height;
        if (o + t.width >= e)
          if (i - t.width >= 0)
            this.dropDownTransformation = !1, this.dropDownPosition.horizontal = "left";
          else {
            const s = e - o - t.width;
            o + s >= 0 ? (this.dropDownTransformation = {
              transform: `translate(${s}px, 0px)`
            }, this.dropDownPosition.horizontal = "right") : (this.dropDownTransformation = {
              transform: `translate(-${o}px, 0px)`
            }, this.dropDownPosition.horizontal = "right");
          }
        else
          this.dropDownTransformation = !1, this.dropDownPosition.horizontal = "right";
        a + t.height >= window.visualViewport.height ? r - t.height >= 0 && (this.dropDownPosition.vertical = "top") : this.dropDownPosition.vertical = "bottom";
      }
    }
  }
};
var w = function() {
  var t = this, n = t._self._c;
  return n("div", { directives: [{ name: "click-outside", rawName: "v-click-outside", value: () => t.showOptions = !1, expression: "() => showOptions = false" }], staticClass: "base-drop-button" }, [n("BaseButton", { class: { "base-drop-button__button__multi": t.buttonsInt && t.buttonsInt.length }, attrs: { text: t.primaryButtonInt[t.labelPropertyName], icon: t.primaryButtonInt.icon || null, "icon-size": "large" }, on: { clicked: function(o) {
    return t.fireAction(t.primaryButtonInt[t.identifierPropertyName]);
  } }, scopedSlots: t._u([{ key: "left-of-text", fn: function() {
    return [t._t("left-of-text")];
  }, proxy: !0 }, { key: "right-of-text", fn: function() {
    return [t._t("right-of-text")];
  }, proxy: !0 }], null, !0) }), t.buttonsInt && t.buttonsInt.length ? n("div", { ref: "dropArea", staticClass: "base-drop-button__options-area" }, [n("button", { class: [
    "base-drop-button__toggle-button",
    { "base-drop-button__toggle-button__active": t.showOptions }
  ], attrs: { "aria-expanded": t.showOptions.toString(), "aria-label": t.expandButtonLabel, type: "button", "aria-haspopup": "listbox" }, on: { click: function(o) {
    o.preventDefault(), t.showOptions = !t.showOptions;
  }, keydown: [function(o) {
    return !o.type.indexOf("key") && t._k(o.keyCode, "enter", 13, o.key, "Enter") ? null : (o.preventDefault(), t.dropDownEnterAction.apply(null, arguments));
  }, function(o) {
    if (!o.type.indexOf("key") && t._k(o.keyCode, "tab", 9, o.key, "Tab"))
      return null;
    t.activeOption = null;
  }, function(o) {
    return !o.type.indexOf("key") && t._k(o.keyCode, "up", 38, o.key, ["Up", "ArrowUp"]) && t._k(o.keyCode, "down", 40, o.key, ["Down", "ArrowDown"]) ? null : (o.preventDefault(), t.navigateOptions.apply(null, arguments));
  }] } }, [n("BaseIcon", { class: [
    "base-drop-button__drop-icon",
    { "base-drop-button__drop-icon__rotated": t.showOptions }
  ], attrs: { name: "drop-down" } })], 1), t.showOptions ? n("BaseDropDownList", { ref: "dropDown", class: [
    "base-drop-button__drop-down",
    `base-drop-button__drop-down__${t.dropDownPosition.horizontal}`,
    `base-drop-button__drop-down__${t.dropDownPosition.vertical}`
  ], style: t.dropDownTransformation, attrs: { "drop-down-options": t.buttonsInt, "active-option": t.activeOption, "active-styled": !1, "aria-activedescendant": t.activeOption ? `button-${t.activeOption.action}` : !1, "identifier-property-name": t.identifierPropertyName, "label-property-name": t.labelPropertyName }, scopedSlots: t._u([{ key: "option", fn: function({ option: o }) {
    return [n("button", { class: [
      "base-drop-button__action",
      {
        "base-drop-button__action__active": t.activeOption && o[t.identifierPropertyName] === t.activeOption[t.identifierPropertyName]
      }
    ], attrs: { id: `button-${o[t.identifierPropertyName]}`, type: "button" }, on: { keydown: function(i) {
      if (!i.type.indexOf("key") && t._k(i.keyCode, "up", 38, i.key, ["Up", "ArrowUp"]) && t._k(i.keyCode, "down", 40, i.key, ["Down", "ArrowDown"]))
        return null;
      i.preventDefault();
    }, click: function(i) {
      return i.preventDefault(), t.fireAction(o[t.identifierPropertyName]);
    } } }, [o.icon ? n("BaseIcon", { staticClass: "base-drop-button__action-icon", attrs: { name: o.icon } }) : t._e(), n("span", [t._v(t._s(o[t.labelPropertyName]))])], 1)];
  } }], null, !1, 673672794) }) : t._e()], 1) : t._e()], 1);
}, m = [], y = /* @__PURE__ */ f(
  h,
  w,
  m,
  !1,
  null,
  "cd174e8c",
  null,
  null
);
const P = y.exports;
export {
  P as default
};
//# sourceMappingURL=BaseDropButton.vue.es.js.map
