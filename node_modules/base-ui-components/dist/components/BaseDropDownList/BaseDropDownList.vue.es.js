import { highlightText as c } from "../../utils/utils.es.js";
import u from "../../mixins/i18n.es.js";
import "./BaseDropDownList.vue.es2.js";
import f from "../../_virtual/_plugin-vue2_normalizer.es.js";
const g = {
  name: "BaseDropDownList",
  mixins: [
    u
  ],
  props: {
    /**
     * list of options to select from
     */
    dropDownOptions: {
      type: Array,
      default: () => []
    },
    /**
     * specify the name of a property that can be used as identifier
     * // TODO: need handling if no identifier provided!!
     */
    identifierPropertyName: {
      type: String,
      default: "id"
    },
    /**
     * specify the name of the property that should be displayed
     */
    labelPropertyName: {
      type: String,
      default: "value"
    },
    /**
     * specify the currently active option (will have gray background
     * if not disabled by setting `activeStyled` `false`) for example for
     * combination with input and keyboard use
     */
    activeOption: {
      type: [Object, String],
      default: () => ({})
    },
    /**
     * specify the currently selected option (will appear in app color if not disabled
     * by setting `selectStyled` `false`, but also used for `aria-selected`).
     *   the `.sync` modifier can be used here
     */
    selectedOption: {
      type: [Object, String],
      default: () => ({})
    },
    /**
     * in order to link the drop down body to an <input> element specify a list
     * id and use the `list` attribute on the input
     */
    listId: {
      type: String,
      default: ""
    },
    /**
     * add styling to the list body (e.g. max-height)
     */
    listBodyStyle: {
      type: Object,
      default: () => ({})
    },
    /**
     * flag if the currently active element should be styled
     * (gray background)
     */
    activeStyled: {
      type: Boolean,
      default: !0
    },
    /**
     * flag if the currently selected entry should be styled
     * (only makes sense for single select, color: app-color)
     */
    selectStyled: {
      type: Boolean,
      default: !1
    },
    /**
     * if `true` the element will be styled as a drop down element with
     * box-shadow
     */
    displayAsDropDown: {
      type: Boolean,
      default: !0
    },
    /**
     * message displayed when no selectable options are available
     */
    dropDownNoOptionsInfo: {
      type: String,
      default: ""
    },
    /**
     * specify a language (ISO 639-1) (used for label if label is language specific object
     * e.g. `{ de: 'xxx', en: 'yyy' }`
     */
    language: {
      type: String,
      default: ""
    },
    /**
     * this adds the possibility of nested options (thus a second list nested within the first one),
     * if this is set `true` this will have consequences for scroll adjustment of list on keyboard use
     * and how the active option is determined (the identifier property will be used)
     */
    hasSubOptions: {
      type: Boolean,
      default: !1
    },
    /**
     * in case a custom option background should be set to the currently active option
     *   (this will also apply if `activeStyled` is set `false`).
     * if you want to use this option please set the css variable `--option-background`
     * in your app
     */
    useCustomOptionActiveBackgroundColor: {
      type: Boolean,
      default: !1
    },
    /**
     * set true if option characters matching a string provided in `highlightStringMatch`
     *  should be highlighted
     */
    useHighlightStringMatch: {
      type: Boolean,
      default: !1
    },
    /**
     * if `useHighlightStringMatch` is set to `true`, provide a string to match with the
     *  option label here
     */
    highlightStringMatch: {
      type: String,
      default: ""
    },
    /**
     * provide tag names to style the matched characters
     *  (without '<' and '>', e.g. ['b'] for <b>)
     */
    highlightStringTags: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      /**
       * if there is any (associated by id) store the related input element
       * in this variable
       * @type {HTMLElement}
       */
      inputElement: null
    };
  },
  computed: {
    /**
     * variable to store if values provided in the list are strings
     * (or an object with language specific strings e.g. { de: 'xxx', en: 'yyy' }) or
     * if list contains other objects (e.g. for AdvancedSearch)
     * @returns {boolean}
     */
    valueIsString() {
      return this.dropDownOptions && this.dropDownOptions.length && typeof this.getLangLabel(this.dropDownOptions[0][this.labelPropertyName], !0) == "string";
    },
    /**
     * the index of the currently active option provided by parent
     * @returns {number}
     */
    activeOptionIndex() {
      return this.hasSubOptions && (!this.activeOption || this.activeOption[this.identifierPropertyName] !== void 0) ? this.dropDownOptions.findIndex((e) => e[this.identifierPropertyName] === this.activeOption[this.identifierPropertyName]) : this.dropDownOptions.indexOf(this.activeOption);
    },
    /**
     * determine if no-options slot has data
     * @returns {Boolean}
     */
    noOptionsSlotHasData() {
      return !!this.$slots["no-options"];
    },
    /**
     * create an object out of prop `highlightStringTags` so it can be
     *  spread into the options of the `highlightText` function
     * @returns {{highlightTags: []}|{}}
     */
    highlightTags() {
      var e;
      return (e = this.highlightStringTags) != null && e.length ? { highlightTags: this.highlightStringTags } : {};
    }
  },
  mounted() {
    const e = document.getElementsByTagName("input");
    if (e && e.length) {
      const t = Array.from(e);
      this.inputElement = t.find((n) => n.getAttribute("list") === this.listId), this.inputElement && this.inputElement.addEventListener("keydown", this.navigateOptions);
    }
  },
  destroyed() {
    this.inputElement && this.inputElement.removeEventListener("keydown", this.navigateOptions);
  },
  methods: {
    /**
     * function to highlight characters of a string
     * @param {string} word - the option that should be matched with query string
     * @returns {string} - the string to fill into v-html
     */
    highlight(e) {
      return c({
        word: e,
        queryString: this.highlightStringMatch,
        // this is an empty object if prop `highlightStringTags` was not used
        ...this.highlightTags
      });
    },
    /**
     * triggered if option was selected by click
     *
     * @param {Object} option - the selected option
     */
    selected(e) {
      this.$emit("update:selected-option", e);
    },
    /**
     * check if an option has data (and should be displayed)
     *
     * @param {Object} option - the option in question
     * @returns {boolean}
     */
    optionHasData(e) {
      return typeof e == "string" ? !!e : e && e.length ? !!e.length : !!(e && Object.keys(e).length);
    },
    /**
     * a function to navigate the dropdown list by keyboard, used in
     * event listener 'keydown'
     *
     * @property {KeyboardEvent} event - the keydown event from the input
     * field associated by 'id'
     */
    navigateOptions(e, { activeOptionHeight: t = 0, activeOptionTop: n = 0 } = {}) {
      const { key: o } = e;
      if (["ArrowDown", "ArrowUp"].includes(o) && (!this.hasSubOptions || t) && this.$refs.option && this.$refs.option[this.activeOptionIndex]) {
        const a = this.$refs.option[this.activeOptionIndex], i = t || a.clientHeight, r = a.offsetTop + n;
        if (this.$parent.$refs.dropDownContainer)
          this.$parent.navigateOptions(e, {
            activeOptionHeight: i,
            activeOptionTop: r
          });
        else {
          let s = this.$refs.dropDownContainer;
          const p = this.$refs.dropDownList;
          p.scrollHeight > p.clientHeight && (s = p);
          const l = s.scrollTop, d = s.clientHeight, h = r + i < l || r > l + d;
          !this.hasSubOptions && !this.activeOptionIndex ? s.scrollTo({
            top: 0
          }) : !this.hasSubOptions && this.activeOptionIndex === this.dropDownOptions.length - 1 ? s.scrollTo({
            top: r + i
          }) : e.key === "ArrowDown" ? h ? s.scrollTo({
            top: r
          }) : r + i > d + l && s.scrollTo({
            top: l + i
          }) : e.key === "ArrowUp" && (h ? s.scrollTo({
            top: r + i - d
          }) : l > r && s.scrollTo({
            top: l - i
          }));
        }
      }
    }
  }
};
var y = function() {
  var t = this, n = t._self._c;
  return n("div", { ref: "dropDownContainer", staticClass: "base-drop-down-list__container", class: [
    "base-drop-down-list__container",
    { "base-drop-down-list__container-drop-down-style": t.displayAsDropDown }
  ] }, [t._t("before-list"), n("ul", { ref: "dropDownList", staticClass: "base-drop-down-list", style: t.listBodyStyle, attrs: { id: t.listId, "aria-activedescendant": t.activeOption ? t.activeOption[t.identifierPropertyName] : !1, role: "listbox" } }, [t._l(t.dropDownOptions, function(o, a) {
    return [t.optionHasData(o[t.labelPropertyName]) ? n("li", { key: a, ref: "option", refInFor: !0, class: [
      "base-drop-down-list__option",
      { "base-drop-down-list__option__hover": t.activeStyled },
      {
        "base-drop-down-list__option__selected": t.selectStyled && o === t.selectedOption
      },
      {
        "base-drop-down-list__option__active": t.activeStyled && a === t.activeOptionIndex
      },
      {
        "base-drop-down-list__option__active-custom": t.useCustomOptionActiveBackgroundColor && a === t.activeOptionIndex
      }
    ], attrs: { id: o[t.identifierPropertyName], value: t.valueIsString ? t.getLangLabel(o[t.labelPropertyName], !0) : o[t.identifierPropertyName], "aria-selected": t.selectStyled && o[t.identifierPropertyName] === t.selectedOption, role: "option", tabindex: "0" }, on: { keydown: function(i) {
      return !i.type.indexOf("key") && t._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : t.selected(o);
    }, click: function(i) {
      return i.stopPropagation(), t.selected(o);
    }, touchstart: function(i) {
      i.stopPropagation();
    } } }, [t._t("option", function() {
      return [t.useHighlightStringMatch ? [n("span", { domProps: { innerHTML: t._s(t.highlight(t.getLangLabel(o[t.labelPropertyName], !0))) } })] : [t._v(" " + t._s(t.getLangLabel(o[t.labelPropertyName], !0)) + " ")]];
    }, { option: o })], 2) : t._e()];
  }), !t.dropDownOptions.length && (t.noOptionsSlotHasData || t.dropDownNoOptionsInfo) ? n("div", { class: [
    "base-drop-down-list__option",
    "base-drop-down-list__no-options"
  ] }, [t.dropDownOptions.length ? t._e() : t._t("no-options", function() {
    return [t._v(" " + t._s(t.dropDownNoOptionsInfo) + " ")];
  })], 2) : t._e()], 2), t._t("after-list")], 2);
}, _ = [], m = /* @__PURE__ */ f(
  g,
  y,
  _,
  !1,
  null,
  "99761913",
  null,
  null
);
const S = m.exports;
export {
  S as default
};
//# sourceMappingURL=BaseDropDownList.vue.es.js.map
