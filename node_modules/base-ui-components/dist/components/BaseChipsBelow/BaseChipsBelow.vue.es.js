import n from "vuedraggable";
import { ref as l } from "vue";
import { useAnnouncer as s } from "../../composables/useAnnouncer.es.js";
import d from "../BaseIcon/BaseIcon.vue.es.js";
import p from "../BaseChipsInput/BaseChipsInput.vue.es.js";
import u from "../BaseChip/BaseChip.vue.es.js";
import "./BaseChipsBelow.vue.es2.js";
import h from "../../_virtual/_plugin-vue2_normalizer.es.js";
const c = {
  name: "BaseChipsBelow",
  components: {
    BaseChipsInput: p,
    Draggable: n,
    BaseChip: u,
    BaseIcon: d
  },
  model: {
    prop: "selectedList",
    event: "selected-changed"
  },
  props: {
    /**
     * list of selectable options objects with at least an identifier and a label property.
     * property names can be set with props `identifierPropertyName` and `labelPropertyName`
     */
    list: {
      type: Array,
      default: () => []
    },
    /**
     * list of already selected options objects with at least an identifier and a label property
     * and a property to use for the secondary drop down ('additional property'), displayed as
     * chips.
     * property names can be set with props `identifierPropertyName`, `labelPropertyName` and
     * `additionalPropertyName`
     */
    selectedList: {
      type: Array,
      default: () => []
    },
    /**
     if field is occurring more than once - set an id
     */
    id: {
      type: String,
      default: ""
    },
    /**
     * input field label
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * define if label should be visible
     */
    showLabel: {
      type: Boolean,
      default: !0
    },
    /**
     * input field placeholder
     */
    placeholder: {
      type: String,
      default: null
    },
    /**
     * message displayed when no selectable options are available
     */
    dropDownNoOptionsInfo: {
      type: String,
      default: "No options available"
    },
    /**
     * define if the user can add an option that is not in the list
     */
    // can the user add Entries that are not available in the vocabulary (selectable list)
    allowUnknownEntries: {
      type: Boolean,
      default: !1
    },
    /**
     * define whether one or more entries can be selected from the drop-down menu
     */
    allowMultipleEntries: {
      type: Boolean,
      default: !0
    },
    /**
     * define if selectable list options should be fetched every time of if the
     * list passed in the beginning is used
     */
    allowDynamicDropDownEntries: {
      type: Boolean,
      default: !1
    },
    /**
     * this prop was added because there was some action needed to be done before entry was added
     * so this is possible if entry is not added to selectedList directly but only in parent
     * component
     */
    addSelectedEntryDirectly: {
      type: Boolean,
      default: !0
    },
    /**
     * define whether one or more options can be selected from the drop-down menu
     */
    additionalPropAllowMultipleEntries: {
      type: Boolean,
      default: !0
    },
    /**
     * Additional property options will set the drop down available for the selected entries
     * needs to be an object with following attributes:
     * **label|*** `string`: the label of the default option - use the property name set via prop `labelPropertyName`
     * **id|*** `string?`: (optional) identifier of the default option - use the property name set via prop `identifierPropertyName`
     */
    additionalPropOptions: {
      type: Array,
      default: () => []
    },
    /**
     * define a default option for additional props
     * see `defaultEntry` at [BaseChipsInput props](BaseChipsInput) for more details
     */
    additionalPropDefaultOption: {
      type: [Object, null],
      default: null
    },
    /**
     * specify additional options as required
     */
    additionalPropRequired: {
      type: Boolean,
      default: !1
    },
    /**
     * specify a placeholder of the additional property input field
     */
    additionalPropPlaceholder: {
      type: String,
      default: "Select role(s)"
    },
    /**
     * define validation messages
     */
    validationTexts: {
      type: Object,
      default: () => ({
        required: "Select an option."
      }),
      // checking if all necessary properties are part of the provided object
      validator: (t) => ["required"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * set content for the info box activatable by click
     * see [BaseHoverBox](BaseHoverBox) for more details
     */
    hoverboxContent: {
      type: Object,
      default: () => ({})
    },
    /**
     * show spinner to indicate that something is loading.
     *  This is meant for dynamically fetching entries from a backend and will only
     *  have an effect if prop `allowDynamicDropDownEntries` is set true!
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * if sorting is enabled this will be the text shown in the button
     */
    sortText: {
      type: String,
      default: "Sort A â€“ Z"
    },
    /**
     * if `true` sorting will consider the last string in a label or if a comma is
     * present the string before the comma
     */
    sortName: {
      type: Boolean,
      default: !1
    },
    /**
     * set a language (ISO 639-1)
     */
    language: {
      type: String,
      default: ""
    },
    /**
     * set a chips text for adding a new chip
     * (alternatively add a 'form.Add' value to your localization files).
     * if `allowUnknownEntries` is `true` please add this in one form or another!
     */
    addNewChipText: {
      type: String,
      default: ""
    },
    /**
     * specify the object property that should be used as identifier
     */
    identifierPropertyName: {
      type: String,
      default: "id"
    },
    /**
     * specify the object property that should be used as value to be displayed
     */
    labelPropertyName: {
      type: String,
      default: "label"
    },
    /**
     * define the name of the property that is relevant for the additional drop down
     * once a value was selected from the primary drop down
     */
    additionalPropertyName: {
      type: String,
      default: "roles"
    },
    /**
     * mark as required field
     */
    required: {
      type: Boolean,
      default: !1
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field.
     * for an example see [BaseInput](BaseInput)
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * set `true` if input field should be disabled.
     * for an example see [BaseInput](BaseInput)
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * add an error message to be displayed below form field if field is invalid
     * for an example see [BaseInput](BaseInput)
     */
    errorMessage: {
      type: String,
      default: ""
    },
    /**
     * define if error icon should be shown.
     * for an example see [BaseInput](BaseInput)
     */
    showErrorIcon: {
      type: Boolean,
      default: !1
    },
    /**
     * if true a remove icon will be shown allowing to remove
     * all input at once.
     * for an example see [BaseInput](BaseInput)
     */
    clearable: {
      type: Boolean,
      default: !1
    },
    /**
     * set `false` if dropdown should be still open after selecting an option
     */
    closeDropdownOnOptionSelect: {
      type: Boolean,
      default: !0
    },
    /**
     * specify additional input field styling
     */
    inputClass: {
      type: String,
      default: ""
    },
    /**
     * define if a button for sorting the entries is visible
     */
    sortable: {
      type: Boolean,
      default: !0
    },
    /**
     * define if chips should be draggable
     */
    draggable: {
      type: Boolean,
      default: !0
    },
    /**
     * set this flag to `true` to highlight autocomplete option characters that match
     *  the current search input string
     *  this will only have effect when the slot `drop-down-entry` is not used
     */
    highlightStringMatch: {
      type: Boolean,
      default: !1
    },
    /**
     * if `highlightAutocompleteMatch` is set `true`
     *  provide tag names to style the matched characters
     *  (without '<' and '>', e.g. ['b'] for <b>)
     *  this will only have effect when the slot `drop-down-entry` is not used
     */
    highlightStringTags: {
      type: Array,
      default: () => []
    },
    /**
     * this prop gives the option to add assistive text for screen readers
     * properties:
     * **loaderActive**: text that is announced when results are being fetched (prop
     *  `isLoading` is set `true`)
     * **resultsRetrieved**: text that is announced when results were retrieved (drop down
     *  list changed)
     * **optionAdded**: text read when option was added to the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     * **optionRemoved**: text read when option was removed from the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     */
    assistiveText: {
      type: Object,
      default: () => ({
        loaderActive: "loading.",
        resultsRetrieved: "{number} options in drop down.",
        optionAdded: "option {label} added to selected list.",
        optionRemoved: "option {label} removed."
      })
    }
  },
  setup() {
    const t = l(null), { announcement: e } = s(t);
    return {
      chipsBelow: t,
      announcement: e
    };
  },
  data() {
    return {
      chipsArray: [],
      selectedBelowListInt: [],
      chipActive: -1,
      // error handling
      invalidInt: !1,
      errorMessageInt: "",
      additionalPropErrors: []
    };
  },
  computed: {
    // need to filter language from $props for chips input component since only needed for
    // additional property (roles)!
    // leads to unwanted behaviour else (creating multilang object)
    chipsInputProps() {
      const t = { ...this.$props };
      return delete t.language, delete t.additionalPropOptions, delete t.additionalPropPlaceholder, delete t.additionalPropertyName, t;
    },
    isDragDropCapable() {
      return window ? !(navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && navigator.userAgent.indexOf("CriOS") === -1) && "DragEvent" in window : !1;
    }
  },
  watch: {
    /**
     * create internal list and reset errors
     * @param {Object[]} val
     */
    selectedList: {
      handler(t) {
        this.createInternalList(t), t.length && (this.invalidInt = this.invalid, this.errorMessageInt = this.errorMessage), this.allowUnknownEntries && this.additionalPropErrors.length && (this.additionalPropErrors = []);
      },
      immediate: !0
    },
    /**
     * keep externally set invalid variable and internal invalid variable in sync
     * @param {boolean} val
     */
    invalid: {
      handler(t) {
        this.invalidInt = t;
      },
      immediate: !0
    },
    /**
     * keep externally set error message variable and internal error message variable in sync
     * @param {string} val
     */
    errorMessage: {
      handler(t) {
        this.errorMessageInt = t;
      },
      immediate: !0
    },
    /**
     * reset the invalid status when the required property is externally set to false.
     * @param {boolean} val
     */
    required: {
      handler(t) {
        t || (this.invalidInt = this.invalid, this.errorMessageInt = this.errorMessage);
      }
    },
    /**
     * reset the additional prop errors when property is externally set to false.
     * @param {boolean} val
     */
    additionalPropRequired: {
      handler(t) {
        t || (this.additionalPropErrors = []);
      }
    }
  },
  methods: {
    addedEntry(t) {
      this.emitInternalList(t.map((e) => typeof e == "object" ? {
        ...e,
        [this.additionalPropertyName]: e[this.additionalPropertyName] || []
      } : {
        [this.labelPropertyName]: e,
        [this.additionalPropertyName]: e[this.additionalPropertyName] || []
      }));
    },
    removeEntry(t, e) {
      const r = this.selectedBelowListInt.splice(e, 1);
      this.$set(r, this.additionalPropertyName, {}), this.emitInternalList(this.selectedBelowListInt), this.announcement = this.assistiveText.optionRemoved.replace("{label}", r[0][this.labelPropertyName]);
    },
    updateList(t, e) {
      this.emitInternalList(e);
    },
    updateAdditionalProperty(t, e) {
      this.$set(this.selectedBelowListInt[e], this.additionalPropertyName, t), this.emitInternalList(this.selectedBelowListInt), this.isValidAdditionalOptions(this.selectedBelowListInt[e]), this.$emit("additional-property-changed", this.selectedList[e]);
    },
    createInternalList(t) {
      this.selectedBelowListInt = t.map((e, r) => typeof e == "object" ? {
        [this.additionalPropertyName]: [],
        idInt: this.identifierPropertyName && (e[this.identifierPropertyName] === 0 || e[this.identifierPropertyName]) ? e[this.identifierPropertyName] : e[this.labelPropertyName] + r,
        ...e
      } : {
        [this.labelPropertyName]: e,
        idInt: this.list.length + r,
        [this.additionalPropertyName]: []
      });
    },
    emitInternalList(t) {
      const e = [];
      t.forEach((r, i) => this.$set(e, i, { ...r })), e.forEach((r) => this.$delete(r, "idInt")), this.$emit("selected-changed", e);
    },
    modifyChipValue(t, e) {
      if (!t)
        this.selectedBelowListInt.splice(e, 1);
      else {
        const r = { ...this.selectedBelowListInt[e] };
        this.identifierPropertyName && this.$set(r, this.identifierPropertyName, ""), this.$set(r, this.labelPropertyName, t), this.$set(this.selectedBelowListInt, e, r);
      }
      this.emitInternalList(this.selectedBelowListInt);
    },
    fetchDropDownEntries(t) {
      this.$emit("fetch-dropdown-entries", t);
    },
    hoverBoxActive(t, e) {
      this.$emit("hoverbox-active", { value: t, entry: e });
    },
    /**
     * get additional options error message
     * @param {string} id - objects id
     * @param {number} index - index in selectedList (needed for unknown entries)
     * @returns {string}
     */
    additionalOptionsErrorMessage(t, e) {
      return this.additionalPropErrors.filter((r) => r.id === t).length || typeof this.additionalPropErrors[e] < "u" ? this.validationTexts.required : "";
    },
    /**
     * check if chips should be removable
     * @param {Object} obj
     * @returns {boolean}
     */
    isChipsRemovable(t) {
      return !this.additionalPropRequired || !!this.additionalPropAllowMultipleEntries && t.length > 1;
    },
    /**
     * validate chips input field
     * @returns {boolean} - error state
     */
    isValidChipsInput() {
      return this.required ? this.selectedList.length ? !0 : (this.invalidInt = !0, this.errorMessageInt = `${this.errorMessage} ${this.validationTexts.required}`.trim(), !1) : !0;
    },
    /**
     * check if a single additional option is invalid
     * @param {string} id
     * @param {number} index
     * @returns {boolean}
     */
    isInvalidAdditionalOption(t, e) {
      return !!this.additionalPropErrors.filter((r) => r.id === t).length || typeof this.additionalPropErrors[e] < "u";
    },
    /**
     * validate single or all additional option or all from selectedList
     * @param {object|null} obj - single row object (optional)
     * @returns {boolean} - valid state
     */
    isValidAdditionalOptions(t) {
      return this.additionalPropRequired ? t && t[this.additionalPropertyName].length ? (this.additionalPropErrors = this.additionalPropErrors.filter((e) => e.id !== t.id), !0) : (this.additionalPropErrors = this.selectedList.filter((e) => !e[this.additionalPropertyName] || !e[this.additionalPropertyName].length).map((e) => ({ id: e.id })), this.selectedBelowListInt.length ? !this.additionalPropErrors.length : !0) : !0;
    },
    /**
     * Validation can be triggered by executing e.g. `this.$refs.baseChipsBelow.validate();` from parent.<br>
     * Therefore, the component must have a reference set.
     * @public
     * @returns {boolean} - components error state
     */
    validate() {
      this.invalidInt = this.invalid, this.errorMessageInt = this.errorMessage, this.additionalPropErrors = [];
      const t = this.isValidChipsInput(), e = this.isValidAdditionalOptions(null);
      return !(t && e);
    }
  }
};
var f = function() {
  var e = this, r = e._self._c;
  return r("div", { ref: "chipsBelow", staticClass: "base-chips-below" }, [r("BaseChipsInput", e._b({ ref: "chipsInput", attrs: { "close-dropdown-on-option-select": e.closeDropdownOnOptionSelect, "is-loading": e.isLoading, "display-chips-inline": !1, "sort-text": e.sortText, "sort-name": e.sortName, invalid: e.invalidInt, "error-message": e.errorMessageInt }, on: { "selected-changed": e.addedEntry, "fetch-dropdown-entries": e.fetchDropDownEntries }, scopedSlots: e._u([{ key: "drop-down-entry", fn: function(i) {
    return [e._t("drop-down-entry", null, { item: i.item })];
  } }, { key: "label-addition", fn: function() {
    return [e._t("label-addition")];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [e._t("input-field-addition-before")];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [e._t("input-field-addition-after")];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [e._t("post-input-field")];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("remove-icon")];
  }, proxy: !0 }, { key: "no-options", fn: function() {
    return [e._t("no-options")];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e._t("below-input")];
  }, proxy: !0 }], null, !0), model: { value: e.selectedBelowListInt, callback: function(i) {
    e.selectedBelowListInt = i;
  }, expression: "selectedBelowListInt" } }, "BaseChipsInput", e.chipsInputProps, !1)), r("draggable", { attrs: { animation: 200, "force-fallback": !e.isDragDropCapable, "fallback-on-body": !e.isDragDropCapable, group: { name: "people" }, handle: ".base-chips-below-list-icon-wrapper" }, on: { end: function(i) {
    return e.updateList(i, e.selectedBelowListInt);
  } }, model: { value: e.selectedBelowListInt, callback: function(i) {
    e.selectedBelowListInt = i;
  }, expression: "selectedBelowListInt" } }, e._l(e.selectedBelowListInt, function(i, a) {
    return r("div", { key: "item" + i.idInt, class: [
      "base-chips-below-list-item",
      { "base-chips-below-list-item--draggable": e.draggable }
    ], attrs: { name: i[e.labelPropertyName] }, on: { mousedown: function(o) {
      e.chipActive = a;
    } } }, [r("div", { key: "line" + i.idInt, staticClass: "base-chips-below-list-item-line" }, [e.draggable ? r("div", { key: "iconwrapper" + i.idInt, staticClass: "base-chips-below-list-icon-wrapper" }, [r("base-icon", { key: "icon" + i.idInt, staticClass: "svg-icon base-chips-below-list-icon", attrs: { name: "drag-lines" } })], 1) : e._e(), r("div", { key: "chip-wrapper" + i.idInt, staticClass: "base-chips-below-list-item-chip-wrapper" }, [r("BaseChip", { key: "chip" + i.idInt, ref: "selectedChip", refInFor: !0, staticClass: "base-chips-input-chip", attrs: { id: "chips-below" + a, "is-linked": !i.edited && (i[e.identifierPropertyName] === 0 || !!i[e.identifierPropertyName]), "hover-box-content": e.hoverboxContent }, on: { "value-changed": function(o) {
      return e.modifyChipValue(o, a);
    }, "hoverbox-active": function(o) {
      return e.hoverBoxActive(o, i);
    }, "remove-entry": function(o) {
      return e.removeEntry(o, a);
    } }, model: { value: i[e.labelPropertyName], callback: function(o) {
      e.$set(i, e.labelPropertyName, o);
    }, expression: "entry[labelPropertyName]" } })], 1), r("BaseChipsInput", { key: "input_" + i.idInt, staticClass: "base-chips-below-chips-input", attrs: { id: `${e.id}_${e.additionalPropertyName}_${i[e.identifierPropertyName] || i.idInt}`, "show-label": !1, label: e.label + "-" + e.additionalPropertyName, list: e.additionalPropOptions, "show-input-border": !1, "allow-dynamic-drop-down-entries": !1, placeholder: e.additionalPropPlaceholder, "always-linked": !0, language: e.language, draggable: !0, "drop-down-no-options-info": e.dropDownNoOptionsInfo, "identifier-property-name": e.identifierPropertyName, "label-property-name": e.labelPropertyName, invalid: e.isInvalidAdditionalOption(i[e.labelPropertyName], a), "error-message": e.additionalOptionsErrorMessage(i[e.labelPropertyName], a), "allow-multiple-entries": e.additionalPropAllowMultipleEntries, "chips-removable": e.isChipsRemovable(i[e.additionalPropertyName]), "show-error-icon": e.showErrorIcon, required: e.additionalPropRequired, "default-entry": e.additionalPropDefaultOption }, on: { "selected-changed": function(o) {
      return e.updateAdditionalProperty(o, a);
    } }, model: { value: i[e.additionalPropertyName], callback: function(o) {
      e.$set(i, e.additionalPropertyName, o);
    }, expression: "entry[additionalPropertyName]" } })], 1)]);
  }), 0)], 1);
}, m = [], y = /* @__PURE__ */ h(
  c,
  f,
  m,
  !1,
  null,
  null,
  null,
  null
);
const L = y.exports;
export {
  L as default
};
//# sourceMappingURL=BaseChipsBelow.vue.es.js.map
