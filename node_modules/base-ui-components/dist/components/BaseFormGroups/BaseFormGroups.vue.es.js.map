{"version":3,"file":"BaseFormGroups.vue.es.js","sources":["../../../src/components/BaseFormGroups/BaseFormGroups.vue"],"sourcesContent":["<template>\n  <div\n    class=\"base-form-groups\">\n    <BaseForm\n      v-for=\"(formGroup, index) of formFieldsGrouped\"\n      :key=\"`${groupsId}-${index}`\"\n      :form-field-json=\"formGroup\"\n      v-bind=\"formProps\"\n      class=\"base-form-groups__group\"\n      v-on=\"$listeners\">\n      <template #label-addition=\"{ fieldName }\">\n        <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n        @binding {string} field-name - in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot\n          name=\"label-addition\"\n          :field-name=\"fieldName\" />\n      </template>\n      <template #pre-input-field=\"{ fieldName }\">\n        <!-- @slot slot to add elements within the form field but in a row before the actual input field. For an example see [BaseInput](BaseInput).\n        @binding {string} field-name in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot\n          name=\"pre-input-field\"\n          :field-name=\"fieldName\" />\n      </template>\n      <template\n        #input-field-addition-before=\"{ fieldName }\">\n        <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>).\n        @binding {string} field-name in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot\n          name=\"input-field-addition-before\"\n          :field-name=\"fieldName\" />\n      </template>\n      <template #input-field-inline-before=\"{ fieldName }\">\n        <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap. For an example see [BaseInput](BaseInput).\n        @binding {string} field-name in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot\n          name=\"input-field-inline-before\"\n          :field-name=\"fieldName\" />\n      </template>\n      <template #input-field-addition-after=\"{ fieldName }\">\n        <!-- @slot for adding elements after input\n        @binding {string} field-name in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot\n          name=\"input-field-addition-after\"\n          :field-name=\"fieldName\" />\n      </template>\n      <template #post-input-field=\"{ fieldName }\">\n        <!-- @slot for adding elements at the end covering the whole height\n        @binding {string} field-name in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot\n          name=\"post-input-field\"\n          :field-name=\"fieldName\" />\n      </template>\n      <template #error-icon>\n        <!-- @slot use a custom icon instead of standard error/warning icon -->\n        <slot name=\"error-icon\" />\n      </template>\n      <template #remove-icon>\n        <!-- @slot use a custom icon instead of standard remove icon\n        @binding {string} field-name in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot name=\"remove-icon\" />\n      </template>\n      <template #below-input=\"{ fieldName }\">\n        <!-- @slot below-input slot added to e.g. add drop down\n        @binding {string} field-name in order to use slot for only one field use a if condition with the form field name (the object property) -->\n        <slot\n          name=\"below-input\"\n          :field-name=\"fieldName\" />\n      </template>\n    </BaseForm>\n  </div>\n</template>\n\n<script>\nimport BaseForm from '@/components/BaseForm/BaseForm';\nimport { createId } from '@/utils/utils';\n\nexport default {\n  name: 'BaseFormGroups',\n  components: {\n    BaseForm,\n  },\n  props: {\n    /**\n     * the json object containing all the field information incl. `x-attrs` custom field\n     * for placeholder, field type, etc. For more information on the attributes see\n     * [BaseForm](BaseForm).\n     * Most importantly the `x-attrs` needs to include the field `form_group` assigning\n     *  a number (1-based index!) to each form field by which fields are grouped.\n     * Optional: add an attribute `form_group_title` to any group field (the field with the\n     *  lowest order takes precedent) to add a form group header.\n     */\n    formFieldJson: {\n      type: Object,\n      required: true,\n      // validator: (val) =>\n    },\n    /**\n     * the values for each field if any already present\n     */\n    valueList: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * set current language\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * provide information about all available languages\n     */\n    availableLocales: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * define additional style for the form\n     * should be an object eg. `{ 'padding-top': 0 }`.\n     *  note: this applies to [BaseForm](BaseForm) not the wrapper\n     *  component\n     */\n    formStyle: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define fields (specify field name!) for which tabs should be shown\n     */\n    fieldsWithTabs: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * enter the field name of a field that is currently fetching autocomplete\n     * results\n     */\n    fieldIsLoading: {\n      type: String,\n      default: '',\n    },\n    /**\n     * provide an object that contains the options list for all\n     * fields with autocomplete / chips input\n     */\n    dropDownLists: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define if error icon should be shown.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * provide an object with settings and properties for each field. This takes an object\n     * with the field name as properties with the props nested.\n     * `{ fieldName1: { required: false, ... }, fieldName2: { ... } }`.\n     *\n     * find the possible variables at the respective input components:\n     * [BaseInput](BaseInput)\n     * [BaseAutocompleteInput](BaseAutocompleteInput)\n     * [BaseMultilineTextInput](BaseMultilineTextInput)\n     * [BaseChipsInput](BaseChipsInput)\n     * [BaseChipsBelow](BaseChipsBelow)\n     * [BaseDateInput](BaseDateInput)\n     * [BaseToggle](BaseToggle)\n     */\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n      validator: val => Object.keys(val).length === 0 || Object.values(val)\n        .every(fieldProps => Object.keys(fieldProps)),\n    },\n  },\n  computed: {\n    /**\n     * modify the component $props, so they can be forwarded to BaseForm directly via\n     * v-bind\n     * @returns {{}}\n     */\n    formProps() {\n      const newProps = {\n        ...this.$props,\n      };\n      // this will be added in html per group\n      delete newProps.formFieldJson;\n      return newProps;\n    },\n    /**\n     * the formFieldJSON needs to be separated in to the specific groups according\n     * to `form_group` `x-attrs` field.\n     *  Fields that do not have the attribute set will be added at the end.\n     * @returns {Object[]}\n     */\n    formFieldsGrouped() {\n      const groupedFormFields = [];\n      const noGroupFields = {};\n      Object.entries(this.formFieldJson).forEach(([key, value]) => {\n        // check if the array index position exists already\n        if (value['x-attrs'] && value['x-attrs'].form_group) {\n          // if yes add the field information object to it (-1 because it is a 1-based\n          // index number and we need to set position in groups array)\n          const groupIndex = value['x-attrs'].form_group - 1;\n          // check if that array position already has content\n          if (groupedFormFields[groupIndex]) {\n            // if yes - add the object property\n            groupedFormFields[groupIndex][key] = value;\n          } else {\n            // if not set an object with first property\n            groupedFormFields[groupIndex] = {\n              [key]: value,\n            };\n          }\n        } else {\n          // if not - save the field to a separate object that will be added last\n          // this.$set(noGroupFields, key, value);\n          noGroupFields[key] = value;\n        }\n      });\n      if (Object.keys(noGroupFields).length) {\n        groupedFormFields.push(noGroupFields);\n      }\n      return groupedFormFields;\n    },\n    /**\n     * create an internal id for looping purposes\n     * @returns {string}\n     */\n    groupsId() {\n      return createId();\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../../styles/variables.scss\";\n\n.base-form-groups {\n  .base-form-groups__group:nth-of-type(n+2) {\n    margin-top: $spacing;\n  }\n}\n</style>\n"],"names":["_sfc_main","BaseForm","val","fieldProps","newProps","groupedFormFields","noGroupFields","key","value","groupIndex","createId"],"mappings":";;;;AA6EA,MAAAA,IAAA;AAAA,EACA,MAAA;AAAA,EACA,YAAA;AAAA,IACA,UAAAC;AAAA,EACA;AAAA,EACA,OAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,eAAA;AAAA,MACA,MAAA;AAAA,MACA,UAAA;AAAA;AAAA,IAEA;AAAA;AAAA;AAAA;AAAA,IAIA,WAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,UAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,kBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,MAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,WAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,gBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,MAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,gBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,eAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,eAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,WAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,YAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA,CAAA;AAAA,MACA,WAAA,CAAAC,MAAA,OAAA,KAAAA,CAAA,EAAA,WAAA,KAAA,OAAA,OAAAA,CAAA,EACA,MAAA,CAAAC,MAAA,OAAA,KAAAA,CAAA,CAAA;AAAA,IACA;AAAA,EACA;AAAA,EACA,UAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,YAAA;AACA,YAAAC,IAAA;AAAA,QACA,GAAA,KAAA;AAAA,MACA;AAEA,oBAAAA,EAAA,eACAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,oBAAA;AACA,YAAAC,IAAA,CAAA,GACAC,IAAA,CAAA;AACA,oBAAA,QAAA,KAAA,aAAA,EAAA,QAAA,CAAA,CAAAC,GAAAC,CAAA,MAAA;AAEA,YAAAA,EAAA,SAAA,KAAAA,EAAA,SAAA,EAAA,YAAA;AAGA,gBAAAC,IAAAD,EAAA,SAAA,EAAA,aAAA;AAEA,UAAAH,EAAAI,CAAA,IAEAJ,EAAAI,CAAA,EAAAF,CAAA,IAAAC,IAGAH,EAAAI,CAAA,IAAA;AAAA,YACA,CAAAF,CAAA,GAAAC;AAAA,UACA;AAAA,QAEA;AAGA,UAAAF,EAAAC,CAAA,IAAAC;AAAA,MAEA,CAAA,GACA,OAAA,KAAAF,CAAA,EAAA,UACAD,EAAA,KAAAC,CAAA,GAEAD;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,WAAA;AACA,aAAAK,EAAA;AAAA,IACA;AAAA,EACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}