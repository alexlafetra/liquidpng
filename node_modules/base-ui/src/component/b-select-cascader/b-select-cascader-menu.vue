<template>
    <div class="b-select-cascader-menu">
        <div class="card select-wrap">
            <div v-for="(selectingList, level) in selectingLists" ref="list" :key="level" class="select-list">
                <div
                    v-for="selecting in selectingList"
                    :key="selecting.label"
                    :class="{selected: isItemSelected(selecting, level), disabled: selecting.disabled}"
                    class="select-item"
                    @click="choose(selecting, level)"
                    @dblclick="choose(selecting, level, {confirm: true})">
                    {{ selecting.label }}
                </div>
            </div>
        </div>
    </div>
</template>

<script>
import KeyCodeMap from '../../util/keyCodeMap';

export default {
    name: 'BSelectCascaderMenu',

    props: {
        value: {
            type: null,
            required: true
        },
        list: {
            type: Array,
            required: true
        },
        options: {
            type: Object,
            default: () => ({})
        },
        enableEmitList: {
            type: Boolean,
            default: false
        }
    },

    data() {
        return {
            selectedList: [],
            currentLevel: 0,
            currentIndex: 0
        };
    },

    computed: {
        selectingLists() {
            const {list, selectedList} = this;
            const selectingLists = [list];

            let curList = list;
            selectedList.forEach(({label}) => {
                const next = curList.find(item => item.label === label);
                if (next && next.children && next.children.length) {
                    curList = next.children;
                    selectingLists.push(curList);
                }
            });

            return selectingLists;
        }
    },

    mounted() {
        const vm = this;
        const {value, list} = vm;
        if (value.length > 0) {
            vm.selectedList = [...value];
        } else if (list.length > 0) {
            vm.selectedList = [list[0]];
        }
        vm.updateLevelIndex();
    },


    methods: {
        choose(selecting, level, options = {}) {
            const vm = this;
            if (selecting.disabled) return;

            const {selectedList} = vm;
            const tailNum = selectedList.length - level;

            vm.selectedList[level] = selecting;
            vm.selectedList.splice(level + 1, tailNum);
            vm.updateLevelIndex();
            vm.$parent.$parent.$el.querySelector('input').focus();
            vm.$emit('choose', vm.selectedList, options);
        },

        isItemSelected({label}, level) {
            const {selectedList} = this;
            if (!selectedList[level]) return false;

            return selectedList[level].label === label;
        },

        updateLevelIndex() {
            this.currentLevel = this.selectedList.length - 1;
            const currentList = this.selectingLists[this.currentLevel];
            const selectedItem = this.selectedList[this.currentLevel];
            this.currentIndex = currentList.findIndex(({value}) => selectedItem.value === value);
        },

        handleScroll(level, index) {
            const vm = this;
            const {$refs: {list}} = vm;
            const currentScrollList = list[level];
            const currentSelectedEle = currentScrollList.querySelector(`div:nth-child(${index + 1})`);
            const scroll = currentSelectedEle.offsetTop - currentScrollList.scrollTop - 290;
            currentScrollList.scrollTop += scroll;
        },

        changeHighlight(direction) {
            const vm = this;
            const {currentLevel, currentIndex, selectingLists} = vm;
            const currentList = selectingLists[currentLevel];

            if (direction === 'down') {
                vm.currentIndex = currentIndex + 1 === currentList.length ? currentIndex : currentIndex + 1;
                vm.$set(vm.selectedList, currentLevel, currentList[vm.currentIndex]);
                vm.handleScroll(currentLevel, vm.currentIndex);
            }

            if (direction === 'up') {
                vm.currentIndex = currentIndex === 0 ? currentIndex : currentIndex - 1;
                vm.$set(vm.selectedList, currentLevel, currentList[vm.currentIndex]);
                vm.handleScroll(currentLevel, vm.currentIndex);
            }

            if (direction === 'right') {
                const currentItem = selectingLists[currentLevel][currentIndex];
                const hasChild = currentItem && !!currentItem.children && currentItem.children.length > 0;
                const nextLevel = hasChild ? currentLevel + 1 : currentLevel;
                const nextList = selectingLists[nextLevel];
                vm.currentIndex = 0;
                if (hasChild) {
                    vm.$set(vm.selectedList, nextLevel, nextList[vm.currentIndex]);
                    vm.currentLevel = nextLevel;
                }
            }

            if (direction === 'left') {
                if (currentLevel > 0) {
                    this.selectedList.pop();
                    this.updateLevelIndex();
                }

            }
        },

        handleKeyDown(keyCode) {
            const vm = this;
            const {selectingLists, currentLevel, currentIndex} = vm;

            switch (keyCode) {
                case KeyCodeMap.up: {
                    vm.changeHighlight('up');
                    break;
                }
                case KeyCodeMap.down: {
                    vm.changeHighlight('down');
                    break;
                }
                case KeyCodeMap.left: {
                    vm.changeHighlight('left');
                    break;
                }
                case KeyCodeMap.right: {
                    vm.changeHighlight('right');
                    break;
                }

                case KeyCodeMap.enter: {
                    const currentItem = selectingLists[currentLevel][currentIndex];
                    const hasChild = currentItem && !!currentItem.children && currentItem.children.length > 0;
                    if (hasChild) {
                        vm.changeHighlight('right');
                    } else {
                        vm.choose(currentItem, currentLevel);
                    }
                    break;
                }
                default: {
                    break;
                }
            }
        }
    }
};

</script>

