{"version":3,"file":"BaseAdvancedSearchRow.vue.cjs.js","sources":["../../../src/components/BaseAdvancedSearch/BaseAdvancedSearchRow.vue"],"sourcesContent":["<template>\n  <!-- eslint-disable-next-line vuejs-accessibility/click-events-have-key-events -->\n  <div\n    ref=\"advancedSearchRow\"\n    class=\"base-advanced-search-row\"\n    @click=\"openDropDown\">\n    <!-- SEARCH FIELD -->\n    <!-- note: the id is used in the javascript part as well as the parent component\n      BaseAdvancedSearch.vue - consider that when changing it! -->\n    <!-- note for @keydown.enter.capture: need to capture here so option select is handled\n      before input is blurred in search -->\n    <BaseSearch\n      :id=\"'search-input-' + internalRowId\"\n      ref=\"baseSearch\"\n      v-model=\"currentInput\"\n      :show-pre-input-icon=\"isMainSearch\n        && filter[identifierPropertyName.filter] === defaultFilter[identifierPropertyName.filter]\"\n      :label=\"assistiveText.searchLabel || 'Search for Entries'\"\n      :type=\"searchType\"\n      :selected-chips.sync=\"selectedOptions\"\n      :loadable=\"filter.type === 'text' || filter.type === 'chips'\"\n      :is-loading=\"isLoading\"\n      :placeholder=\"placeholder\"\n      :drop-down-list-id=\"searchType === 'controlled' ? `controlled-options-${internalRowId}`\n        : 'autocomplete-options-' + internalRowId\"\n      :language=\"language\"\n      :identifier-property-name=\"useAutocompleteFunctionality\n        ? identifierPropertyName.autocompleteOption\n        : identifierPropertyName.controlledVocabularyOption\"\n      :label-property-name=\"useAutocompleteFunctionality ? labelPropertyName.autocompleteOption\n        : labelPropertyName.controlledVocabularyOption\"\n      :is-active.sync=\"isActive\"\n      :set-focus-on-active=\"false\"\n      :clearable=\"false\"\n      :assistive-text=\"{\n        selectedOption: assistiveText.selectedOption,\n        loaderActive: assistiveText.loaderActive,\n        results: assistiveText.results,\n      }\"\n      :date-field-delay=\"dateFieldDelay\"\n      :linked-list-option=\"activeEntry\n        // set option for autocomplete - check if collection select mode is active and set id of that if yes\n        ? (collectionSelect ? activeCollectionId\n          // or set the active entry id\n          : activeEntry[identifierPropertyName.autocompleteOption])\n        // else check if there is an active controlled vocabulary entry and set that if yes\n        : (activeControlledVocabularyEntry\n          ? activeControlledVocabularyEntry[identifierPropertyName.controlledVocabularyOption]\n          // if everything else fails set undefined\n          : undefined)\"\n      :class=\"['base-advanced-search-row__search',\n               { 'base-advanced-search-row__search__shadow': applyBoxShadow }]\"\n      v-on=\"$listeners\"\n      @clicked-outside=\"onClickedOutsideSearch\"\n      @click.native=\"onSearchClick\"\n      @keydown=\"handleKeyDownEvent\"\n      @keydown.up.down.right.left=\"navigateDropDown\"\n      @keydown.tab=\"handleDropDownOnTabKey\"\n      @keydown.enter.capture=\"selectOptionOnKeyEnter\"\n      @keydown.esc=\"isActive = false\"\n      @value-validated=\"handleDateInput\">\n      <!-- FIRST COLUMN OF SEARCH FIELD (FILTERS) -->\n      <template #[filterSlotName]>\n        <BaseChipsInputField\n          v-if=\"mode === 'list'\"\n          :id=\"'search-filter-select-' + internalRowId\"\n          :selected-list.sync=\"selectedFilter\"\n          :allow-multiple-entries=\"false\"\n          :allow-unknown-entries=\"false\"\n          :allow-dynamic-drop-down-entries=\"false\"\n          :linked-list-option=\"activeFilter\n            ? `filter-option-${activeFilter[identifierPropertyName.filter]}` : null\"\n          :use-form-field-styling=\"false\"\n          :show-input-border=\"false\"\n          :show-label=\"false\"\n          :label=\"assistiveText.selectFilterLabel || 'Select filter'\"\n          :language=\"language\"\n          :drop-down-list-id=\"'filter-options-' + internalRowId\"\n          :identifier-property-name=\"identifierPropertyName.filter\"\n          :label-property-name=\"labelPropertyName.filter\"\n          :input-class=\"filterSlotName === 'input-field-addition-before'\n            ? '' : 'base-advanced-search-row__input-field'\"\n          :class=\"['base-advanced-search-row__first-column',\n                   {\n                     'base-advanced-search-row__first-column__small':\n                       filterSlotName === 'input-field-addition-before',\n                   },\n                   'base-advanced-search-row__filter-input',\n                   {\n                     hide: isMainSearch && filter\n                       [identifierPropertyName.filter] === defaultFilter\n                         [identifierPropertyName.filter],\n                   },\n                   {\n                     'base-advanced-search-row__filter-input__date':\n                       filter.type.includes('date'),\n                   }]\"\n          @click=\"isActive = true\"\n          @keydown=\"handleKeyDownEvent\"\n          @keydown.tab=\"handleDropDownOnTabKey\"\n          @keydown.enter=\"selectFilter(activeFilter)\"\n          @keydown.up.down=\"navigateFilters\">\n          <template #chip=\"{ entry }\">\n            <span\n              :id=\"entry.idInt\"\n              :key=\"'chip-' + entry.idInt\"\n              class=\"base-advanced-search-row__selected-filter-label\">\n              {{ `#${getLangLabel(entry[labelPropertyName.filter], true)}` }}\n            </span>\n          </template>\n        </BaseChipsInputField>\n      </template>\n      <template #post-input-field>\n        <button\n          v-if=\"!isMainSearch\n            || filterHasValues || (filter.type === 'text' && currentInput)\"\n          :class=\"['base-advanced-search-row__icon-button',\n                   { 'base-advanced-search-row__icon-button__date': filter.type.includes('date') }]\"\n          @keydown.tab=\"onTab\"\n          @focusin.stop.prevent\n          @click.stop.prevent=\"removeFilter\">\n          <BaseIcon\n            :title=\"assistiveText.removeFilter || 'Remove filter'\"\n            name=\"remove\"\n            class=\"base-advanced-search-row__search-row-icon\" />\n        </button>\n        <!-- @slot add an element at the end of the search row (e.g. additional button) -->\n        <slot name=\"after\" />\n      </template>\n\n      <!-- DROP DOWN BODY -->\n      <template #below-input>\n        <BaseDropDownList\n          v-if=\"isActive\"\n          ref=\"dropDown\"\n          :drop-down-options=\"resultListInt\"\n          :active-option=\"{ [autocompletePropertyNames.id]: activeCollectionId }\"\n          :list-id=\"'autocomplete-options-' + internalRowId\"\n          :active-styled=\"false\"\n          :has-sub-options=\"true\"\n          :display-as-drop-down=\"false\"\n          :use-custom-option-active-background-color=\"true\"\n          :language=\"language\"\n          :identifier-property-name=\"autocompletePropertyNames.id\"\n          :label-property-name=\"autocompletePropertyNames.data\"\n          :list-body-style=\"{\n            'max-height': '400px',\n            'overflow-y': 'auto',\n          }\"\n          class=\"base-advanced-search-row__drop-down-body\"\n          @touchstart.native.stop=\"\"\n          @click.native.stop=\"\">\n          <template\n            v-if=\"mode === 'list'\"\n            #before-list>\n            <div\n              :class=\"['base-advanced-search-row__above-list-area',\n                       'base-advanced-search-row__area-padding',\n                       {\n                         'base-advanced-search-row__above-list-area-filters':\n                           filter.type === 'text' || filter.type === 'chips',\n                       }]\">\n              <!-- FILTER SELECT LIST -->\n              <div\n                class=\"base-advanced-search-row__filter-area-wrapper\">\n                <div\n                  class=\"base-advanced-search-row__first-column\n                base-advanced-search-row__filter-area\">\n                  <div\n                    class=\"base-advanced-search-row__filter-area-header\">\n                    <div class=\"base-advanced-search-row__filter-text\">\n                      {{ getI18nTerm(getLangLabel(advancedSearchText.title)) }}\n                    </div>\n                    <div\n                      class=\"base-advanced-search-row__filter-subtext\">\n                      {{ getI18nTerm(getLangLabel(advancedSearchText.subtext)) }}\n                    </div>\n                  </div>\n                  <span\n                    class=\"base-advanced-search-row__filter-area-close\"\n                    @keydown.enter=\"isActive = false\"\n                    @click.stop=\"isActive = false\">\n                    <BaseIcon\n                      class=\"rotate-180 base-advanced-search-row__filter-area-close-icon\"\n                      name=\"drop-down\" />\n                  </span>\n                </div>\n                <div\n                  :class=\"['base-advanced-search-row__columns',\n                           'base-advanced-search-row__filter-list-wrapper',\n                           {\n                             'base-advanced-search-row__filter-list-wrapper__fade-right':\n                               filterFade.right,\n                           },\n                           {\n                             'base-advanced-search-row__filter-list-wrapper__fade-left':\n                               filterFade.left,\n                           }]\">\n                  <ul\n                    :id=\"'filter-options-' + internalRowId\"\n                    ref=\"filterBox\"\n                    role=\"listbox\"\n                    class=\"base-advanced-search-row__filter-list\">\n                    <li\n                      v-for=\"(singleFilter, index) in displayFilterList\"\n                      :id=\"`filter-option-${singleFilter[identifierPropertyName.filter]}`\"\n                      :key=\"index\"\n                      ref=\"filterOption\"\n                      :aria-selected=\"(filter && filter[identifierPropertyName.filter]\n                        === singleFilter[identifierPropertyName.filter]).toString()\"\n                      tabindex=\"-1\"\n                      class=\"base-advanced-search-row__filter base-advanced-search-row__column-item\"\n                      :class=\"[{\n                                 'base-advanced-search-row__filter-active':\n                                   activeFilter === singleFilter,\n                               },\n                               {\n                                 'base-advanced-search-row__filter-selected':\n                                   filter && filter[identifierPropertyName.filter]\n                                     === singleFilter[identifierPropertyName.filter],\n                               }]\"\n                      role=\"option\"\n                      @keydown.enter.stop=\"selectFilter(singleFilter)\"\n                      @click.stop=\"selectFilter(singleFilter)\">\n                      {{ `#${singleFilter[labelPropertyName.filter]}` }}\n                    </li>\n                  </ul>\n                </div>\n              </div>\n            </div>\n          </template>\n\n          <!-- AUTOCOMPLETE OPTIONS LIST -->\n          <template\n            #option=\"{ option }\">\n            <div\n              v-if=\"!filter || useAutocompleteFunctionality\"\n              class=\"base-advanced-search-row__autocomplete-body\">\n              <div\n                v-if=\"option[autocompletePropertyNames.data].length\"\n                :class=\"['base-advanced-search-row__first-column',\n                         'base-advanced-search-row__autocomplete-collection',\n                ]\">\n                <div class=\"base-advanced-search-row__autocomplete-collection-text\">\n                  {{ option[autocompletePropertyNames.label] }}\n                  <span\n                    v-if=\"assistiveText.optionsAnnouncement\"\n                    class=\"hide\">{{ assistiveText.optionsAnnouncement\n                      .replace('{number}', option[autocompletePropertyNames.data].length) }}</span>\n                </div>\n              </div>\n\n              <!-- AUTOCOMPLETE OPTIONS -->\n              <BaseDropDownList\n                :drop-down-options=\"option[autocompletePropertyNames.data]\"\n                :active-option=\"activeCollectionId === option[autocompletePropertyNames.id]\n                  ? activeEntry : {}\"\n                :display-as-drop-down=\"false\"\n                :list-id=\"'autocomplete-options-' + internalRowId\"\n                :language=\"language\"\n                :identifier-property-name=\"identifierPropertyName.autocompleteOption\"\n                :label-property-name=\"labelPropertyName.autocompleteOption\"\n                :use-highlight-string-match=\"highlightAutocompleteMatch\"\n                :highlight-string-tags=\"highlightAutocompleteTags\"\n                :highlight-string-match=\"currentInput\"\n                class=\"base-advanced-search-row__autocomplete-options\"\n                @update:selected-option=\"addOption(\n                  $event,\n                  option[autocompletePropertyNames.id],\n                )\">\n                <template #option=\"{ option: autocompleteOption }\">\n                  <!-- @slot to allow for modification of the autocomplete option\n                    @binding {Object} option - the option object as specified in the [autocompletePropertyNames.data] array\n                    @binding {string} collection-id the currently active collection as provided in [autocompletePropertyNames.id] -->\n                  <slot\n                    name=\"autocomplete-option\"\n                    :option=\"autocompleteOption\"\n                    :collection-id=\"option[autocompletePropertyNames.id]\" />\n                </template>\n              </BaseDropDownList>\n            </div>\n          </template>\n\n          <!-- CHIPS (CONTROLLED VOCABULARY OPTIONS) AREA -->\n          <template\n            v-if=\"filter.type === 'chips' && !filter.freetext_allowed\"\n            #after-list>\n            <div\n              class=\"base-advanced-search-row__above-list-area\n                 base-advanced-search-row__chips-area\n                 base-advanced-search-row__area-padding\">\n              <div\n                :class=\"['base-advanced-search-row__chips-row',\n                         {\n                           'base-advanced-search-row__chips-row__no-options':\n                             filter.type === 'chips' && !displayedOptions.length,\n                         }]\">\n                <div\n                  class=\"base-advanced-search-row__controlled-options-title\n                         base-advanced-search-row__first-column\">\n                  {{ getI18nTerm(getLangLabel(advancedSearchText.availableOptions)) }}\n                </div>\n                <ul\n                  v-if=\"controlledVocabularyOptions && displayedOptions.length\n                    && (displayedOptions.length <= maxNumberControlledOptions\n                      || (currentInput && currentInput.length >= 4))\"\n                  :id=\"`controlled-options-${internalRowId}`\"\n                  role=\"listbox\"\n                  class=\"base-advanced-search-row__chips-list base-advanced-search-row__columns\">\n                  <li\n                    v-for=\"chip in displayedOptions\"\n                    :id=\"chip[identifierPropertyName.controlledVocabularyOption]\"\n                    :key=\"chip[identifierPropertyName.controlledVocabularyOption]\"\n                    :value=\"chip[labelPropertyName.controlledVocabularyOption]\"\n                    :aria-selected=\"(activeControlledVocabularyEntry\n                      && chip[identifierPropertyName.controlledVocabularyOption]\n                        === activeControlledVocabularyEntry[identifierPropertyName\n                          .controlledVocabularyOption] || false).toString()\"\n                    role=\"option\"\n                    tabindex=\"0\"\n                    class=\"base-advanced-search-row__column-item\"\n                    @mouseenter=\"activeControlledVocabularyEntry = chip\"\n                    @focusin=\"activeControlledVocabularyEntry = chip\"\n                    @mouseleave=\"activeControlledVocabularyEntry = null\"\n                    @focusout=\"activeControlledVocabularyEntry = null\">\n                    <BaseChip\n                      :is-removable=\"false\"\n                      :entry=\"getLangLabel(chip[labelPropertyName.controlledVocabularyOption])\"\n                      :chip-active=\"activeControlledVocabularyEntry\n                        && chip[identifierPropertyName.controlledVocabularyOption]\n                          === activeControlledVocabularyEntry[identifierPropertyName\n                            .controlledVocabularyOption]\"\n                      class=\"base-advanced-search-row__option-chip\"\n                      @clicked=\"addOption(chip)\" />\n                  </li>\n                </ul>\n                <div\n                  v-else-if=\"isLoading\"\n                  class=\"base-advanced-search-row__no-options\n                     base-advanced-search-row__area-padding\">\n                  {{ getI18nTerm(getLangLabel(dropDownInfoTexts.chipsOngoing, true)) }}\n                </div>\n                <!-- INFO if there are too many options to display (however from a certain\n                string length options are still displayed because this would be not very\n                user friendly else... -->\n                <div\n                  v-else-if=\"displayedOptions.length > maxNumberControlledOptions\n                    && (!currentInput || currentInput.length < 4)\"\n                  class=\"base-advanced-search-row__no-options\n                  base-advanced-search-row__area-padding\">\n                  {{ getI18nTerm(getLangLabel(dropDownInfoTexts.chipsMaxOptions, true)) }}\n                </div>\n                <!-- IFNO if string does not match any options -->\n                <div\n                  v-else-if=\"currentInput && currentInput.length && !displayedOptions.length\"\n                  class=\"base-advanced-search-row__no-options\n                     base-advanced-search-row__area-padding\">\n                  {{ getI18nTerm(getLangLabel(dropDownInfoTexts.chipsNoMatch, true)) }}\n                </div>\n                <!-- INFO if no more options are available (all options already added) -->\n                <div\n                  v-else-if=\"!displayedOptions.length\"\n                  class=\"base-advanced-search-row__no-options\n                     base-advanced-search-row__area-padding\">\n                  {{ getI18nTerm(getLangLabel(dropDownInfoTexts.chipsNoOptions, true)) }}\n                </div>\n              </div>\n            </div>\n          </template>\n          <template\n            #no-options>\n            <div\n              v-if=\"useAutocompleteFunctionality\"\n              :class=\"[\n                'base-advanced-search-row__no-options',\n                { 'base-advanced-search-row__no-options-hidden': !useAutocompleteFunctionality },\n              ]\">\n              <div\n                v-if=\"!currentInput\n                  || (typeof currentInput === 'string' && !currentInput.trim())\">\n                {{ getI18nTerm(getLangLabel(dropDownInfoTexts.autocompleteInitial, true)) }}\n              </div>\n              <div\n                v-else-if=\"isLoading\">\n                {{ getI18nTerm(getLangLabel(dropDownInfoTexts.autocompleteOngoing, true)) }}\n              </div>\n              <div v-else>\n                {{ getI18nTerm(getLangLabel(dropDownInfoTexts.autocompleteNoOptions, true)) }}\n              </div>\n            </div>\n          </template>\n        </BaseDropDownList>\n        <!-- @slot add an element below the primary row (same styling (box-shadow) as primary row element) -->\n        <slot name=\"below\" />\n      </template>\n    </BaseSearch>\n    <BaseButton\n      v-if=\"mode === 'list' && isMainSearch\"\n      icon=\"plus\"\n      button-style=\"row\"\n      icon-position=\"right\"\n      :class=\"['base-advanced-search-row__add-filter-button',\n               { 'base-advanced-search-row__add-filter-button__shadow': applyBoxShadow }]\"\n      @clicked=\"addFilterRow\"\n      @click.native.stop=\"\">\n      <template #text=\"{ labelId }\">\n        <span\n          :id=\"labelId\"\n          class=\"base-advanced-search-row__add-filter-button__text\">\n          {{ assistiveText.addFilter || 'Add filter' }}\n        </span>\n      </template>\n    </BaseButton>\n  </div>\n</template>\n\n<script>\nimport BaseSearch from '@/components/BaseSearch/BaseSearch';\nimport BaseIcon from '@/components/BaseIcon/BaseIcon';\nimport BaseButton from '@/components/BaseButton/BaseButton';\nimport BaseChipsInputField from '@/components/BaseChipsInputField/BaseChipsInputField';\nimport BaseChip from '@/components/BaseChip/BaseChip';\nimport BaseDropDownList from '@/components/BaseDropDownList/BaseDropDownList';\nimport { createId, hasData, sort } from '@/utils/utils';\nimport { ref } from 'vue';\nimport { useAnnouncer } from '@/composables/useAnnouncer';\nimport navigateMixin from '../../mixins/navigateList';\nimport i18n from '../../mixins/i18n';\n\nexport default {\n  name: 'BaseAdvancedSearchRow',\n  components: {\n    BaseButton,\n    BaseDropDownList,\n    BaseChip,\n    BaseChipsInputField,\n    BaseSearch,\n    BaseIcon,\n  },\n  mixins: [navigateMixin, i18n],\n  props: {\n    /**\n     * provide an id for each search row\n     */\n    searchRowId: {\n      type: String,\n      default: '',\n    },\n    /**\n     *\n     */\n    mode: {\n      type: String,\n      default: 'list',\n      validator: val => ['list', 'form'].includes(val),\n    },\n    /**\n     * property to distinguish between one of multiple filter rows\n     * and the main search field (where new filters are added) that has\n     * a slightly different design and functionality\n     */\n    isMainSearch: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * list of available filters, needs to be an array of objects with the following properties:<br>\n     *   <br>\n     *    <b>label</b> {string} - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      labelPropertyName.filter<br>\n     *    <b>id</b> {string} - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      identifierPropertyName.filter<br>\n     *    <b>type</b> {('text'|'chips'|'chipssingle'|'date'|'daterange')} - the filter type<br>\n     *    <b>freetext_allowed</b> {boolean} - determines if predetermined options from 'options'\n     *      property are used or autocomplete is used\n     *    <b>options</b> {Object[]} - for filter type 'chips' and 'chipssingle' the controlled\n     *      vocabulary options\n     *    <b>subsets</b> {string[]} - if a filter of `type` 'text' or 'chips' with\n     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which\n     *      the autosuggest results should also be shown - add these filter ids here\n     */\n    filterList: {\n      type: Array,\n      default: () => ([]),\n      validator: val => !val.length\n        || (val.every(v => !!v.type && (!['chips', 'chipssingle'].includes(v.type)\n          || v.freetext_allowed || !!v.options))),\n    },\n    /**\n     * specify a default value for a filter that is set when none of the\n     * available filters is selected, should have the following properties:<br>\n     *   <br>\n     *    <b>label</b> {string} - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      labelPropertyName.filter<br>\n     *    <b>id</b> {string} - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      identifierPropertyName.filter<br>\n     *    <b>type</b> {('text'|'chips'|'chipssingle'|'date'|'daterange')} - the filter type<br>\n     *    <b>freetext_allowed</b> {boolean} - determines if predetermined options from 'options'\n     *      property are used or autocomplete is used\n     *    <b>options</b> {Object[]} - for filter type 'chips' and 'chipssingle' the controlled\n     *      vocabulary options<br>\n     *    <b>filter_values</b> {Object[]|string[]|Object} - the values selected - object for date\n     *      or array of objects or strings for type 'text', type 'chips' and 'chipssingle'\n     *\n     *    defaultFilter does not need the property subsets since results for all filters are\n     *    shown per default\n     */\n    defaultFilter: {\n      type: Object,\n      default: () => ({\n        id: 'default',\n        label: 'Fulltext',\n        type: 'text',\n        options: [],\n      }),\n      validator: val => !val.length\n        || (val.every(v => !!v.type && (!['chips', 'chipssingle'].includes(v.type)\n          || v.freetext_allowed || !!v.options))),\n    },\n    /**\n     * the filter currently applied, needs to be an object with the following properties:<br>\n     *   <br>\n     *    <b>label</b> {string} - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      labelPropertyName.filter<br>\n     *    <b>id</b> {string} - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      identifierPropertyName.filter<br>\n     *    <b>type</b> {('text'|'chips'|'chipssingle'|'date'|'daterange')} - the filter type<br>\n     *    <b>freetext_allowed</b> {boolean} - determines if predetermined options from 'options'\n     *      property are used or autocomplete is used\n     *    <b>filter_values</b> {Object[]|string[]|Object} - the values selected - object for date\n     *      or array of objects or strings for type 'text',  type 'chips' and 'chipssingle'\n     *    <b>subsets</b> {string[]} - if a filter of `type` 'text' or 'chips' with\n     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which\n     *      the autosuggest results should also be shown - add these filter ids here\n     */\n    appliedFilter: {\n      type: [Object, null],\n      default: null,\n      validator: val => val === null || !val.length || ['id', 'type', 'label'].every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * provide the component with the fetched autocomplete results\n     * (drop down options)<br>\n     * this needs to be an object array with the properties specified in\n     * `autocompletePropertyNames`\n     */\n    autocompleteResults: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * flag to set if loader should be shown (for autocomplete requests\n     */\n    isLoading: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * specify a language (ISO 639-1) (used for label if label is language specific object\n     * e.g. { de: 'xxx', en: 'yyy' })\n     */\n    language: {\n      type: String,\n      default: '',\n    },\n    /**\n     * specify the object property that can be used for identification of filters,\n     * autocomplete options and controlled vocabulary options.<br>\n     *   Could be a string (used for all of the mentioned objects) or an object with the following\n     *   properties:<br>\n     *     <b>filter</b>: identifier property name in filter objects<br>\n     *     <b>autocompleteOption</b>: identifier property name in autocomplete option objects<br>\n     *     <b>controlledVocabularyOption</b>: identifier property name in controlled\n     *     vocabulary option objects<br>\n     */\n    identifierPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'id',\n        autocompleteOption: 'id',\n        controlledVocabularyOption: 'id',\n      }),\n    },\n    /**\n     * specify the object property that should be used for label display of filters,\n     * autocomplete options and controlled vocabulary options.<br>\n     *   Could be a string (used for all of the mentioned objects) or an object with the following\n     *   properties:<br>\n     *     <b>filter</b>: label property name in filter objects<br>\n     *     <b>autocompleteOption</b>: label property name in autocomplete option objects<br>\n     *     <b>controlledVocabularyOption</b>: label property name in controlled\n     *     vocabulary option objects<br>\n     */\n    labelPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'label',\n        autocompleteOption: 'title',\n        controlledVocabularyOption: 'label',\n      }),\n    },\n    /**\n     * autocomplete results need a label, an id and a data property that contains all the actual\n     * autocomplete results for that specific category\n     * TODO: make category optional\n     */\n    autocompletePropertyNames: {\n      type: Object,\n      default: () => ({\n        label: 'label',\n        id: 'id',\n        data: 'data',\n      }),\n      // check if all the necessary attributes are included in the provided object\n      validator: val => ['label', 'id', 'data'].every(key => Object.keys(val).includes(key)),\n    },\n    /**\n     * add a placeholder for the search input; either just a string or an object with\n     * different text for each search type (text, chips, date)\n     */\n    placeholder: {\n      type: [String, Object],\n      default: 'Search and discover',\n    },\n    /**\n     * specify informational texts for the component - this needs to be an object with the following\n     * properties (if you dont want to display any text leave an empty string):  <br>\n     *   <br>\n     *     <b>title</b>: text shown as first line on the drop down in filters area<br>\n     *     <b>subtext</b>: text shown as second line on the drop down in filters area<br>\n     *     <b>availableOptions</b>: text shown with chips options for controlled vocabulary\n     *     search<br>\n     *  <br>\n     *  The values of this object might be plain text or a key for an i18n file<br>\n     * This prop can be ignored when the 'no-options' slot is used.\n     */\n    advancedSearchText: {\n      type: Object,\n      default: () => ({\n        title: 'Advanced Search',\n        subtext: 'Select a filter',\n        availableOptions: 'Available options',\n      }),\n    },\n    /**\n     * specify informational texts for the drop down - this needs to be an object with the following\n     * properties (if you dont want to display any text leave an empty string:  <br>\n     *   <br>\n     *     <b>autocompleteNoOptions</b>: text shown when no autocomplete options are available<br>\n     *     <b>autocompleteOngoing</b>: text shown when an autocomplete search request is ongoing<br>\n     *     <b>autocompleteInitial</b>: initial text shown before user started typing<br>\n     *     <b>chipsNoOptions</b>: text shown when there are no options for controlled vocabulary\n     *        available<br>\n     *     <b>chipsMaxOptions</b>: text displayed if more than max number of options that can be\n     *        displayed are available (configure via prop maxNumberControlledOptions)<br>\n     *     <b>chipsNoMatch</b>: text displayed if string in input does not match any options<br>\n     *     <b>chipsOngoing</b>: text shown for chips fetching request ongoing<br>\n     *  <br>\n     *  The values of this object might be plain text or a key for an i18n file<br>\n     */\n    dropDownInfoTexts: {\n      type: Object,\n      default: () => ({\n        autocompleteNoOptions: 'No matching options found',\n        autocompleteOngoing: 'Autocomplete is being fetched...',\n        autocompleteInitial: 'Please start typing or select a filter to see options',\n        chipsNoOptions: 'No more options available',\n        chipsMaxOptions: 'Please start typing to see options',\n        chipsNoMatch: 'No matching options were found',\n        chipsOngoing: 'Options are being loaded...',\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['autocompleteNoOptions', 'autocompleteOngoing', 'autocompleteInitial',\n        'chipsNoOptions', 'chipsOngoing', 'chipsMaxOptions', 'chipsNoMatch']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * define a maximum number of controlled vocabulary options to be displayed\n     */\n    maxNumberControlledOptions: {\n      type: Number,\n      default: 100,\n    },\n    /**\n     * this prop gives the option to add assistive text for screen readers<br>\n     * properties:<br>\n     * <b>addFilter</b>: text/label used for add filter icon<br>\n     * <b>removeFilter</b>: text/label used for remove filter icon<br>\n     * <b>selectFilterLabel</b>: label (not visible) used for filter chips input field<br>\n     * <b>searchLabel</b>: label (not visible) used for search input field<br>\n     * <b>selectedOption</b>: text read when a selected option is focused (currently only\n     *  working for type chips with autocomplete (=freetext_allowed))\n     * **loaderActive**: text that is announced when results are being fetched (prop\n     *  `isLoading` is set `true`)\n     * **autocompleteResultsRetrieved**: text announced when autocomplete results are returned.\n     *  use {optionsNumber} and {collectionsNumber} in the string to announce the number of\n     *  total options and collections found respectively.\n     * **autocompleteNoResults**: Text announced when no results were found with a given\n     *  search string.\n     * **autocompleteInitial**: Text announced when no search string was provided for\n     *  autocomplete.\n     * **categoryAnnouncement**: Text announced when a new category is entered in the\n     *  autocomplete drop down options list with keyboard navigation. string '{label}' will\n     *  be replaced by the actual specified category label\n     * **optionsAnnouncement**: announced together with category when in category selection\n     *  mode (after using arrowLeft key on autocomplete input) - to give the user a feeling\n     *  how many options were found for the announced category. string '{number}' will be\n     *  replaced by the number of entries in that category.\n     * **results**: provide text that should be announced when the search has\n     *  yielded results (or not).\n     *\n     * Caveat: `results` has a watcher attached to trigger the\n     *    announcement so make sure the property values are reset after filling them\n     *    by using update:assistive-text or resetting it manually (after a timeout)\n     */\n    assistiveText: {\n      type: Object,\n      default: () => ({\n        addFilter: 'Add filter',\n        removeFilter: 'Remove filter',\n        selectFilterLabel: 'Select filter',\n        searchLabel: 'Search for Entries',\n        selectedOption: '',\n        loaderActive: 'loading.',\n        autocompleteResultsRetrieved: '{optionsNumber} options found in {collectionsNumber} categories.',\n        autocompleteNoResults: 'No results found.',\n        autocompleteInitial: 'Please start typing to see suggestions.',\n        categoryAnnouncement: 'category {label}.',\n        optionsAnnouncement: '{number} options.',\n        results: '',\n      }),\n    },\n    /**\n     * if desired the box shadow around the search rows can be deactivated here\n     */\n    applyBoxShadow: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * use this prop to set a delay in ms before date input calender is displayed\n     */\n    dateFieldDelay: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * set this flag to `true` to highlight autocomplete option characters that match\n     *  the current search input string\n     */\n    highlightAutocompleteMatch: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `highlightAutocompleteMatch` is set `true`\n     *  provide tag names to style the matched characters\n     *  (without '<' and '>', e.g. ['b'] for <b>)\n     */\n    highlightAutocompleteTags: {\n      type: Array,\n      default: () => ([]),\n    },\n  },\n  setup() {\n    /**\n     * set up a reference to the element to be able to attach the announcements element\n     * @type {Ref<UnwrapRef<null|HTMLElement>>}\n     */\n    const advancedSearchRow = ref(null);\n    /**\n     * insert an HTML element with aria-live assertive that will announce the\n     * search result\n     * @type {Ref<UnwrapRef<string>>}\n     */\n    const { announcement } = useAnnouncer(advancedSearchRow);\n    return {\n      advancedSearchRow,\n      announcement,\n    };\n  },\n  data() {\n    return {\n      /**\n       * variable containing search text\n       * @type {?string|?Object}\n       */\n      currentInput: '',\n      /**\n       * the currently selected filter\n       * @type {Filter}\n       */\n      filter: null,\n      /**\n       * the currently active (selected by key navigation) filter\n       * @type {?Filter}\n       */\n      activeFilter: null,\n      /**\n       * variable to steer filter mobile display fade outs\n       * @type {Object}\n       * @property {boolean} filterFade.left - left fade out\n       * @property {boolean} filterFade.right - right fade out\n       */\n      filterFade: {\n        left: false,\n        right: true,\n      },\n      /**\n       * for autocomplete drop down navigation - collection level\n       * @type {?string}\n       */\n      activeCollectionId: '',\n      /**\n       * switch between arrow use on collection or entry level\n       * (true for collection level)\n       * @type {boolean}\n       */\n      collectionSelect: false,\n      /**\n       * the currently active controlled vocabulary entry\n       * @type {?Object|?string}\n       */\n      activeControlledVocabularyEntry: null,\n      /**\n       * for autocomplete drop down navigation - single autocomplete option level\n       * @type {?Object}\n       */\n      activeEntry: null,\n      /**\n       * to control if search field is active (and drop down shown)\n       * @type {boolean}\n       */\n      isActive: false,\n      /**\n       * store the current filter type to recognize when it changes and only take\n       * action e.g. on focusing input field, after it was rendered\n       * @type {string}\n       */\n      currentFilterType: this.appliedFilter ? this.appliedFilter.type : this.defaultFilter.type,\n      /**\n       * the search input element stored in a variable so it can easily be focused again after\n       * option selection\n       * @type {?HTMLElement}\n       */\n      searchInputElement: null,\n      /**\n       * Mutation observer for handling the focusing of input field after changes\n       * @type {?MutationObserver}\n       */\n      observer: null,\n      /**\n       * Resize Observer to trigger actions (e.g. drop down columns calculations) when\n       * component is resized\n       * @type {?ResizeObserver}\n       */\n      resizeObserver: null,\n      /**\n       * depending on element size a different slot of BaseInput is used and needs\n       * to be passed on to v-slot directive of template element\n       * @type {string}\n       */\n      filterSlotName: 'pre-input-field',\n      /**\n       * variable for touch devices to stop the click event from opening the drop down\n       *  when click event was coming from elements within the search (e.g. BaseForm)\n       */\n      stopSearchClick: false,\n    };\n  },\n  computed: {\n    /**\n     * create a row id either taken from externally specified id or\n     * via createId function\n     */\n    internalRowId() {\n      return this.searchRowId || createId();\n    },\n    /**\n     * v-model of BaseChipsInputField provides an array of selected options - do\n     * conversion to object and array respectively with this computed variable\n     * (this is triggered when deleting the selected filter)\n     */\n    selectedFilter: {\n      /**\n       * triggered on deleting a filter via chip 'x'\n       * @param {Filter[]} val\n       */\n      set(val) {\n        const newFilter = val.length ? val.pop() : this.defaultFilter;\n        // check if filter was selected - else use the default filter\n        this.filter = {\n          ...newFilter,\n          filter_values: this.setFilterValues(newFilter, this.filter),\n        };\n      },\n      get() {\n        // return current filter object as array\n        return [this.filter];\n      },\n    },\n    /**\n     * for main filter do not display the default filter in the drop down list with\n     *  available filters (mode 'list')\n     * @returns {Filter[]}\n     */\n    displayFilterList() {\n      if (!this.isMainSearch) return this.filterList;\n      return this.filterList.filter(filter => filter[this.identifierPropertyName.filter]\n        !== this.defaultFilter[[this.identifierPropertyName.filter]]);\n    },\n    /**\n     * variable to return if autocomplete functionality should be shown (= results fetched\n     * and displayed in drop down, how input is handled, etc.)\n     * this evaluates to true if type is text or chips with freetext allowed\n     * @returns {boolean}\n     */\n    useAutocompleteFunctionality() {\n      const { type } = this.filter;\n      return type === 'text' || (type === 'chips' && this.filter.freetext_allowed);\n    },\n    /**\n     * depending on the filter type get selectedOptions for BaseSearch from filter values\n     */\n    selectedOptions: {\n      /**\n       * this is used when a chip is deleted\n       * @param {Object[]|string[]} val - the new selected options to be set as filter_values in the\n       *  current filter\n       */\n      set(val) {\n        this.$set(this.filter, 'filter_values', [...val]);\n      },\n      get() {\n        /**\n         * this variable should only contain values for chips\n         * not for date, daterange or text\n         * @returns {Object[]|string[]}\n         */\n        if (this.filter.type.includes('chips')) {\n          return this.filter && this.filter.filter_values ? [...this.filter.filter_values] : [];\n        }\n        return [];\n      },\n    },\n    /**\n     * in case the filter is a controlled vocabulary filter get the options\n     * from the corresponding filter in the filter list\n     * @returns {Object[]}\n     */\n    controlledVocabularyOptions() {\n      // check first if filter is type controlled vocabulary\n      if (this.filter.type === 'chips' && !this.filter.freetext_allowed) {\n        // if yes - get the filter from filterList that has all the options\n        const currentFilter = this.filterList\n          .find(filter => filter[this.identifierPropertyName.filter]\n            === this.filter[this.identifierPropertyName.filter]);\n        // if one was found return the options\n        return currentFilter ? currentFilter.options : [];\n      }\n      return [];\n    },\n    /**\n     * the actually displayed controlled vocabulary options\n     * (filtered for already selected and for the current input string)\n     *\n     * @returns Object[]\n     */\n    displayedOptions() {\n      if (this.controlledVocabularyOptions) {\n        let options = [].concat(this.controlledVocabularyOptions);\n        // remove already selected options if there are any\n        if (this.filter.filter_values && this.filter.filter_values.length) {\n          options = options.filter(option => !this.filter.filter_values\n            .map(value => value[this.identifierPropertyName.controlledVocabularyOption])\n            .includes(option[this.identifierPropertyName.controlledVocabularyOption]));\n        }\n        // only display options matching the current input string\n        if (this.currentInput) {\n          options = options.filter(filter => filter[this.labelPropertyName.filter]\n            .toLowerCase().includes(this.currentInput.toLowerCase()));\n        }\n        return sort(\n          options,\n          this.labelPropertyName.controlledVocabularyOption,\n          false,\n          this.getLangLabel,\n        );\n      }\n      return [];\n    },\n    /**\n     * filtered autocomplete list, e.g. removing collections with no results\n     * and options that were already selected\n     * @type {Object[]} resultListInt\n     * @returns {Object[]}\n     */\n    resultListInt() {\n      if (this.useAutocompleteFunctionality) {\n        let resultsToDisplay = this.autocompleteResults;\n        // if a filter is not default filter then only show autocomplete results that\n        // have same category as selected text filter\n        if (this.filter[this.identifierPropertyName.filter]\n          !== this.defaultFilter[this.identifierPropertyName.filter]) {\n          // filter for identical autocomplete section id OR if a filter has the\n          // prop `subsets` specified also filter for the ids specified in that array\n          resultsToDisplay = resultsToDisplay\n            .filter(section => section[this.autocompletePropertyNames.id]\n              === this.filter[this.identifierPropertyName.filter]\n              || (this.filter.subsets && this.filter.subsets.length\n                && this.filter.subsets.includes(section[this.autocompletePropertyNames.id])));\n        }\n        // filter empty collections\n        resultsToDisplay = resultsToDisplay\n          .filter(section => section[this.autocompletePropertyNames.data]\n            && section[this.autocompletePropertyNames.data].length);\n        // filter options already selected previously\n        if (this.selectedOptions && this.selectedOptions.length) {\n          const selectedOptionIds = this.selectedOptions\n            .map(option => option[this.identifierPropertyName.autocompleteOption]);\n          return resultsToDisplay.map(section => ({\n            data: section[this.autocompletePropertyNames.data].filter(entry => !selectedOptionIds\n              .includes(entry[this.identifierPropertyName.autocompleteOption])),\n            [this.autocompletePropertyNames.id]:\n              section[this.autocompletePropertyNames.id],\n            [this.autocompletePropertyNames.label]:\n              section[this.autocompletePropertyNames.label],\n          }));\n        }\n        return resultsToDisplay;\n      }\n      return [];\n    },\n    /**\n     * list of autocomplete results used for determining currently active\n     * collection // activity\n     * @type {Object} consolidatedResultList\n     * @returns {Object}\n     */\n    consolidatedResultList() {\n      return this.resultListInt.reduce((prev, curr) => {\n        this.$set(prev, curr[this\n          .autocompletePropertyNames.id], curr[this.autocompletePropertyNames.data]);\n        return prev;\n      }, {});\n    },\n    /**\n     * function to determine if filter has filter values\n     */\n    filterHasValues() {\n      // check if filter is not default filter\n      return this.filter[this.identifierPropertyName.filter]\n        !== this.defaultFilter[this.identifierPropertyName.filter]\n        // or has filter values\n        || hasData(this.filter.filter_values);\n    },\n    /**\n     * map filter type\n     */\n    searchType() {\n      if (this.filter) {\n        const { type } = this.filter;\n        // chips input filters that don't allow freetext need to have the type 'controlled'\n        // in BaseSearchComponent\n        if (type === 'chips' && !this.filter.freetext_allowed) {\n          return 'controlled';\n        }\n        return type;\n      }\n      return 'text';\n    },\n  },\n  watch: {\n    /**\n     * watch internal filter object for changes\n     */\n    filter: {\n      handler(val) {\n        if (JSON.stringify(val) !== JSON.stringify(this.appliedFilter)) {\n          /**\n           * event emitted when the applied filter changes<br>\n           *   (possible to use .sync modifier on prop appliedFilter)\n           * @event update:applied-filter\n           * @property {Filter} val - the new currently applied filter\n           */\n          this.$emit('update:applied-filter', { ...val });\n        }\n      },\n      deep: true,\n    },\n    defaultFilter: {\n      handler(val) {\n        // check if the props default defaultFilter is still applied\n        if (!this.filter || this.filter.id === 'default') {\n          this.filter = {\n            ...val,\n            // if filter is changed from outside this often means resetting a filter so previous\n            // values should not be taken over (=leave second argument of function empty here)\n            filter_values: this.setFilterValues(val),\n          };\n        }\n      },\n      immediate: true,\n    },\n    /**\n     * watch if applied filter changes from outside\n     */\n    appliedFilter: {\n      /**\n       * @param {Filter} val - the currently applied filter as set from outside\n       */\n      handler(val) {\n        // check if anything actually changed\n        if (JSON.stringify(val) !== JSON.stringify(this.filter)) {\n          const newFilter = val || this.defaultFilter;\n          this.filter = {\n            ...newFilter,\n            // if filter is changed from outside this often means resetting a filter so previous\n            // values should not be taken over (=leave second argument of function empty here)\n            filter_values: newFilter.filter_values || this.setFilterValues(newFilter),\n          };\n          // check if the new filter has values\n          if (val && val.filter_values) {\n            // distinguish between date and others to assign to correct variable\n            if (val.type.includes('date')) {\n              this.currentInput = val.filter_values;\n            } else if (val.type === 'text') {\n              this.currentInput = val.filter_values[0] || '';\n            } else {\n              this.currentInput = '';\n            }\n          } else {\n            this.currentInput = '';\n          }\n        }\n      },\n      immediate: true,\n      deep: true,\n    },\n    /**\n     * when current input changes emit this to parent component which should\n     * do the fetching of autocomplete results (if filter type 'text') or assign\n     * the values to filter.filter_values if type is 'date' or 'daterange'\n     * @param {string} val - the search string\n     */\n    currentInput: {\n      handler(val) {\n        // if filter type is text - just emit for fetching autocomplete results\n        if (this.useAutocompleteFunctionality) {\n          /**\n           * event emitted when input string for text or chips filter changes\n           *\n           * @event fetch-autocomplete-results\n           * @property {string} input - the input string\n           * @property {Filter} filter - the filter currently applied\n           */\n          this.$emit('fetch-autocomplete-results', { input: val, filter: this.filter });\n        }\n      },\n      immediate: true,\n    },\n    /**\n     * if 'isActive' is set true reset the filterFade (for mobile filter view) to\n     * default values\n     */\n    isActive(val) {\n      if (val) {\n        // reset filter fade (mobile view)\n        this.filterFade = {\n          left: false,\n          right: true,\n        };\n        // if drop down was opened and there is no currently active entry (if there is, the options\n        // are announced anyway) we announce the dropdown content\n        if (!this.activeEntry) {\n          // timeout and secondary isActive check is needed because on click in the form the isActive value\n          // also changes to true for a second before it switches back to false\n          setTimeout(() => {\n            if (this.isActive) {\n              this.assembleAutocompleteResultsAnnouncement();\n            }\n          }, 300);\n        }\n      }\n      // if isActive becomes false and the drop down closes check for remaining input strings\n      // if the filter is chips\n      if (!val && this.filter.type === 'chips' && !!this.currentInput && this.currentInput.trim()) {\n        // check if the string can actually be added (freetext options allowed) and that the option\n        // was not added previously\n        if (this.filter.freetext_allowed && (!this.selectedOptions || !this.selectedOptions\n          .some(option => (!option[this.identifierPropertyName.autocompleteOption]\n            && option[this.labelPropertyName.autocompleteOption] === this.currentInput)))) {\n          // if this holds true - add the option\n          this.addOption({ [this.labelPropertyName.autocompleteOption]: this.currentInput });\n        } else {\n          // else reset all input\n          this.resetAllInput();\n        }\n        // if filter type is text and the value was not added in that form yet also add it\n        // (which will trigger search)\n      } else if (!val && this.filter.type === 'text'\n        && this.filter.filter_values.join() !== this.currentInput) {\n        this.addOption(this.currentInput);\n      }\n      /**\n       * event emitted when input field becomes active / inactive\n       * @event is-active\n       * @type {boolean}\n       */\n      this.$emit('is-active', val);\n    },\n    /**\n     * reset the currently active drop down autocomplete option when the list changes\n     */\n    autocompleteResults() {\n      // reset the active entry / collection set with the previous results\n      this.activeEntry = null;\n      this.activeCollectionId = '';\n      // on results change announce what was found, but only if the dropdown is active\n      if (this.isActive) {\n        this.assembleAutocompleteResultsAnnouncement();\n      }\n    },\n    /**\n     * reset the currently active controlled vocabulary option when the list changes\n     */\n    displayedOptions() {\n      // reset currently active vc entry if list changed\n      this.activeControlledVocabularyEntry = null;\n    },\n  },\n  mounted() {\n    // get the search input element for later use\n    this.getSearchInputElement();\n    // initialize observers that calculate the number of columns shown for filters\n    // and chips options on render and recalculate on resize of element and that handle\n    // focusing of the search input on changes\n    this.initObservers();\n  },\n  updated() {\n    // if the filterBox element exists add\n    // the listener\n    if (this.$refs.filterBox) {\n      this.$refs.filterBox.addEventListener('scroll', this.calcFadeOut);\n    }\n  },\n  beforeDestroy() {\n    if (this.resizeObserver) this.resizeObserver.unobserve(this.$refs.advancedSearchRow);\n  },\n  destroyed() {\n    // remove event listener again if element exists\n    if (this.$refs.filterBox) {\n      this.$refs.filterBox.removeEventListener('scroll', this.calcFadeOut);\n    }\n  },\n  methods: {\n    /** FILTER ROW RELATED FUNCTIONALITIES */\n\n    // inform parent of click on plus or remove respectively\n    addFilterRow() {\n      /**\n       * event emitted when user took action to add filter\n       *\n       * @event add-filter-row\n       * @property {Filter} filter - the filter object in question\n       * @property {string} input - the current input\n       */\n      this.$emit('add-filter-row', { filter: this.filter, input: this.currentInput });\n    },\n    removeFilter() {\n      if (this.isMainSearch) {\n        this.filter = {\n          ...this.defaultFilter,\n          filter_values: this.setFilterValues(this.defaultFilter),\n        };\n        this.resetAllInput();\n        this.isActive = false;\n      } else {\n        /**\n         * event emitted when user triggered remove icon on filter row\n         *\n         * @event remove-filter\n         * @property {Filter} filter - the filter to be removed\n         */\n        this.$emit('remove-filter', this.filter);\n      }\n    },\n\n    /** FILTER RELATED FUNCTIONALITIES */\n\n    /**\n     * set the via click or navigation selected filter as currently\n     * active filter\n     *\n     * @param {Filter} selectedFilter - the selected filter object\n     * @property {string} selectedFilter.type - the type of the filter needed\n     * to set the default filter values accordingly (array, string, object)\n     */\n    selectFilter(selectedFilter) {\n      // check if filter actually changed\n      if (selectedFilter && this.filter[this.identifierPropertyName.filter]\n        !== selectedFilter[this.identifierPropertyName.filter]) {\n        // store the previous filter in a variable\n        const previousFilter = this.filter;\n        // store previous input value in a variable (to keep it if new filter type is\n        // compatible\n        const previousInput = this.currentInput;\n        // set newly selected filter as current filter\n        this.filter = {\n          ...selectedFilter,\n          // set filter values separately to be able to keep some values\n          filter_values: this.setFilterValues(selectedFilter, previousFilter),\n        };\n        // reset all input variables\n        this.resetAllInput();\n        this.activeFilter = null;\n        // now restore the input value if it makes sense (=filter type is autocomplete filter and\n        // type stays the same or switches to other autocomplete type (chips, text))\n        if (['text', 'chips'].includes(selectedFilter.type)\n          && ['text', 'chips'].includes(previousFilter.type)\n          && !(previousFilter.type === 'text' && previousFilter.filter_values[0] === previousInput)) {\n          // restore the input value\n          this.currentInput = previousInput;\n          // now - if there is an input value and there are no autocomplete results available for\n          // the category of the new filter - trigger the autocomplete fetch again\n          if ((selectedFilter.type === 'text' || (selectedFilter.type === 'chips' && selectedFilter.freetext_allowed))\n            && this.currentInput && !this.autocompleteResults\n            .some(category => category.filter_id === selectedFilter.id)) {\n            this.$emit('fetch-autocomplete-results', { input: this.currentInput, filter: this.filter });\n          }\n        }\n        // if filter type date sync current input\n        if (this.filter.type.includes('date')) {\n          this.currentInput = this.filter.filter_values;\n        }\n        if (this.filter.type === 'chipssingle') {\n          this.addOption(this.filter.options[0]);\n        }\n      }\n      if (this.searchInputElement) {\n        // in either case - focus on input field again after click on filter\n        this.searchInputElement.focus();\n      }\n    },\n    /**\n     * @param {KeyboardEvent} event - keyboard event bubbled from\n     * filter input field\n     */\n    navigateFilters(event) {\n      if (this.filterList.length && this.isActive && this.$refs.dropDown) {\n        const currentIndex = this.filterList.indexOf(this.activeFilter);\n        const dropDownElement = this.$refs.dropDown.$el;\n        // if filters are out of view - scroll to top to make them visible\n        if (this.$refs.filterOption && dropDownElement.scrollTop !== 0) {\n          this.$refs.dropDown.$el.scrollTo({\n            top: 0,\n          });\n        }\n        // determine if arrow was up or down - true if down, false for up\n        const isArrowDown = event.key === 'ArrowDown';\n        this.activeFilter = this.navigate(this.filterList, isArrowDown, currentIndex, true);\n      }\n    },\n\n    /** CONTROLLED VOCABULARY AND AUTOCOMPLETE SELECT RELATED METHODS */\n\n    /**\n     * function to add any entry to the BaseSearch selectedChips list (since basically all\n     * base search input is handled as chips)\n     *\n     * @param {Object} entry - the entry to add to the selected list\n     * @param {string} collectionId - to set filter after adding from autocomplete a collection id\n     *  is needed when option was selected by click\n     */\n    addOption(entry, collectionId = '') {\n      // get the result category of the selected option (on key navigation this.activeCollectionId\n      // should be set, if selected from drop down by click the collectionId is passed to the\n      // function else the default filter category is assumed\n      const selectedOptionCollection = collectionId\n        || this.defaultFilter[this.identifierPropertyName.filter];\n      // check if filters were specified - if not assume the input is handled in parent component\n      if (!this.filterList || !this.filterList.length) {\n        this.$emit('option-selected', ({ entry, collectionId: selectedOptionCollection }));\n        // check if filter is not default filter\n        if (selectedOptionCollection !== this.defaultFilter[this.identifierPropertyName.filter]) {\n          // only then reset all input\n          this.resetAllInput();\n        }\n        // if option is coming from autocomplete drop down list (=has an id)\n        // and currently active filter is not identical\n        // with the category of the selected item (if everything is going right this should\n        // be 'default') then set the category of the selected item as current filter\n      } else if (this.useAutocompleteFunctionality\n        && entry[this.identifierPropertyName.autocompleteOption]\n        // and currently active filter is not identical\n        // with the category of the selected item\n        && this.filter[this.identifierPropertyName.filter]\n          !== selectedOptionCollection\n        // and selected item is not from a subset (so\n        // if everything goes right category should be 'default')\n        && !(this.filter.subsets && this.filter.subsets.length\n          && this.filter.subsets.includes(selectedOptionCollection))) {\n        // then set the category of the selected item as current filter\n        const newFilter = this.filterList.find(filter => filter[this.identifierPropertyName.filter]\n          // the filterList SHOULD have the filter included that is displayed as autocomplete option\n          // category but if everything fails - use default filter again\n          === (this.activeCollectionId || collectionId)) || this.defaultFilter;\n        // since default filter could be other than chips at least safeguard against type 'text'\n        // TODO: this assumes default filter type is 'text'! needs further handling if other filter\n        // types could be default\n        const newValue = newFilter[this.identifierPropertyName.filter]\n        === this.defaultFilter[this.identifierPropertyName.filter]\n          ? [].concat(entry[this.labelPropertyName.autocompleteOption]) : [].concat(entry);\n        const oldFilterValues = this.filter.filter_values && this.filter.filter_values.length === 1\n          && typeof this.filter.filter_values[0] === 'string' ? [{\n            [this.labelPropertyName.autocompleteOption]: this.filter.filter_values[0],\n          }] : [];\n        this.filter = {\n          ...newFilter,\n          // check for filter_values property which does not exist in the filterList filters\n          filter_values: oldFilterValues.concat(newValue),\n        };\n      } else {\n        this.selectedOptions = this.filter.filter_values.concat(entry);\n      }\n      // if filter type is text only use string for search on enter so dont remove the input\n      // new addition: also controlled vocabulary input should stay as long as options available\n      if (this.filter.type !== 'text' && (this.filter.type !== 'chips' || this.filter.freetext_allowed\n        || !this.displayedOptions.length)) {\n        // reset everything\n        this.resetAllInput();\n      } else {\n        // else just empty the previously selected controlled vocabulary entry\n        this.activeControlledVocabularyEntry = null;\n      }\n\n      // if filter row is not controlled vocabulary close the filter to be able to see search\n      // results\n      if (this.filter.type !== 'chips' || this.filter.freetext_allowed) {\n        this.isActive = false;\n      }\n    },\n    /**\n     * function triggered on BaseSearch keyboard enter. Will add the currently active option or\n     * controlled vocabulary option respectively. Or if no option is active the current input text.\n     * If there is no active option and no input text then the keyboard enter will be interpreted\n     * as a signal to add the filter to a filter array (parent is informed)\n     */\n    selectOptionOnKeyEnter() {\n      // else check if filter type is chips and there is an active entry in the options list\n      if (this.filter.type === 'chips' && this.activeControlledVocabularyEntry) {\n        this.addOption(this.activeControlledVocabularyEntry);\n        // if an active entry is present (=selected by key naviagation) add the entry\n      } else if (this.useAutocompleteFunctionality && this.activeEntry) {\n        this.addOption(this.activeEntry, this.activeCollectionId);\n        // check if filter type is text\n      } else if (this.filter.type === 'text') {\n        const newTextArray = [].concat(this.currentInput);\n        if (JSON.stringify(this.filter.filter_values) !== JSON.stringify(newTextArray)) {\n          this.$set(this.filter, 'filter_values', [].concat(this.currentInput));\n          this.isActive = false;\n        } else {\n          this.isActive = !this.isActive;\n        }\n        // if there is no active entry check if there is input in the search field and\n        // add the text input as chip if available, however check if text was already added\n        // to avoid duplicates\n      } else if (this.filter.type === 'chips' && this.filter.freetext_allowed\n        && this.currentInput && this.currentInput.trim()\n        && (!this.selectedOptions || !this.selectedOptions\n          .some(option => (!option[this.identifierPropertyName.autocompleteOption]\n            && option[this.labelPropertyName.autocompleteOption] === this.currentInput)))) {\n        this.addOption({\n          [this.labelPropertyName.autocompleteOption]: this.currentInput,\n        });\n        // if this is main search and there is no current input and filter values are present\n        // inform parent that filter can be processed\n      } else if (!this.currentInput) {\n        this.isActive = !this.isActive;\n      }\n    },\n    /**\n     * @param {KeyboardEvent} event - the event triggered by keydown\n     */\n    handleKeyDownEvent(event) {\n      const { key } = event;\n      if (!['Tab', 'Enter', ' ', 'Shift'].includes(key)) {\n        this.isActive = true;\n      } else if (key === ' ' && !this.currentInput) {\n        this.isActive = !this.isActive;\n        event.preventDefault();\n      }\n    },\n    /**\n     * create an announcement to inform about the information shown in the autocomplete\n     * dropdown\n     */\n    assembleAutocompleteResultsAnnouncement() {\n      // check if there are results to display and if the needed assistive text was defined in\n      // the prop\n      if (this.resultListInt.length && this.assistiveText.autocompleteResultsRetrieved) {\n        // calculate the complete number of results provided\n        const resultsNumber = this.resultListInt.reduce((prev, curr) => prev + curr.data.length, 0);\n        // set the announcement text with the appropriate number of collections and total results\n        // displayed\n        this.announcement = this.assistiveText.autocompleteResultsRetrieved\n          .replace('{optionsNumber}', resultsNumber.toString())\n          .replace('{collectionsNumber}', this.resultListInt.length.toString());\n        // else handle an empty drop down list if\n        // a) no results were found or\n      } else if (!this.resultListInt.length && this.currentInput\n        && this.assistiveText.autocompleteNoResults) {\n        this.announcement = this.assistiveText.autocompleteNoResults;\n        // b) no search input string is given\n      } else if (!this.resultListInt.length && !this.currentInput\n        && this.assistiveText.autocompleteInitial) {\n        this.announcement = this.assistiveText.autocompleteInitial;\n      }\n    },\n\n    /** DROP DOWN NAVIGATION */\n\n    /**\n     * event triggered on row click to open drop down and focus main input\n     */\n    openDropDown() {\n      // set focus to input field when drop down opens only if\n      // a) drop down is not already open (e.g. otherwise this would always cause the first input field of a date\n      //    range to get focused on element click\n      // b) mode is 'list'\n      // c) search input element exists\n      if (!this.isActive && this.mode === 'list' && this.searchInputElement) {\n        this.searchInputElement.focus();\n      }\n      this.isActive = true;\n    },\n    /**\n     * primary drop down navigation deciding what arrow keys are used for\n     * --> could be used for controlled vocabulary or autocomplete options\n     * @param {KeyboardEvent} event - the keydown event bubbled from search input field\n     */\n    navigateDropDown(event) {\n      event.preventDefault();\n      // determine if arrow was up or down - true if down, false for up\n      const isArrowDown = event.key === 'ArrowDown';\n      // if navigation is used to navigate controlled vocabulary options (= are there\n      // option specified in the filter?) only use arrow up and down\n      if (this.controlledVocabularyOptions && this.controlledVocabularyOptions.length\n        && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {\n        const currentIndex = this.displayedOptions.indexOf(this.activeControlledVocabularyEntry);\n        this.activeControlledVocabularyEntry = this.navigate(\n          this.displayedOptions,\n          isArrowDown,\n          currentIndex,\n          true,\n        );\n        // else navigation is used for autocomplete options\n      } else {\n        this.navigateAutocomplete(event, isArrowDown);\n      }\n    },\n    /**\n     * navigation handling complexe autocomplete navigation with possibilities to\n     * navigate single entries or collections (switch between collections and entries\n     * by using left/right arrow key)\n     *\n     * @param {KeyboardEvent} event - the keydown event bubbled from search input field\n     * @param {boolean} isArrowDown - param passed from navigateDropDown so no need to newly assign\n     */\n    navigateAutocomplete(event, isArrowDown) {\n      // prevent moving of cursor on input line\n      event.preventDefault();\n      if (this.resultListInt.length) {\n        // remember the previous collection so it can be decided if\n        // announcement should be read in the end\n        const previousActiveCollection = this.activeCollectionId;\n        // store key stroked in variable\n        const { key } = event;\n        // actions for arrow up or down\n        if (key === 'ArrowDown' || key === 'ArrowUp') {\n          // if there is no active Collection (could happen due to hover)\n          // set the first item in array\n          if (!this.activeCollectionId) {\n            this.activeCollectionId = this\n              .resultListInt[0][this.autocompletePropertyNames.id];\n          }\n          // get the index of the currently active collection\n          const currentCollectionIndex = this.resultListInt\n            .map(section => section[this.autocompletePropertyNames.id])\n            .indexOf(this.activeCollectionId);\n          let currentCollectionArray = this.consolidatedResultList[this.activeCollectionId];\n          // depending if arrow was up or down set +/- one to add or subtract\n          // generically\n          const numberToAdd = isArrowDown ? 1 : -1;\n          // get the index of the currently active entry within a collection\n          const currentEntryIndex = currentCollectionArray.indexOf(this.activeEntry);\n          // check if the last or first entry of the options list is reached\n          const isWithinListLimit = this.isWithinArrayLimit(\n            this.resultListInt,\n            isArrowDown,\n            currentCollectionIndex + numberToAdd,\n          );\n          // check if collection select is active and if not, if the arrow action is\n          // within the limits of the array\n          if (!this.collectionSelect\n            && this.isWithinArrayLimit(\n              currentCollectionArray,\n              isArrowDown,\n              currentEntryIndex + numberToAdd,\n            )) {\n            // set new active entry\n            this.activeEntry = this.navigate(\n              currentCollectionArray,\n              isArrowDown,\n              currentEntryIndex,\n            );\n            // since it is allowed to add unknown entries it must be possible to\n            // have no active entry when navigating beyond list\n          } else if (!this.collectionSelect\n            && (!isArrowDown && currentCollectionIndex === 0 && currentEntryIndex === 0)) {\n            this.activeEntry = null;\n            this.activeCollectionId = '';\n            // if collection select is active or first/last element of the current collection\n            // is reached - switch to next/previous collection\n          } else if (isWithinListLimit) {\n            // set the new active collection\n            this.activeCollectionId = this.resultListInt[currentCollectionIndex + numberToAdd][this\n              .autocompletePropertyNames.id];\n            currentCollectionArray = this.consolidatedResultList[this.activeCollectionId];\n            // define which element in the newly active collection should appear active\n            // if collection select or arrow up - first one otherwise last\n            const newItemIndex = isArrowDown || this.collectionSelect ? 0\n              : currentCollectionArray.length - 1;\n            // set the active entry of the newly set collection\n            this.activeEntry = currentCollectionArray[newItemIndex];\n            // if it is the last entry of the complete list - start from the top\n          } else if (!isWithinListLimit && currentCollectionIndex === this.resultListInt.length - 1\n            && currentEntryIndex === currentCollectionArray.length - 1) {\n            this.activeCollectionId = this\n              .resultListInt[0][this.autocompletePropertyNames.id];\n            currentCollectionArray = this.consolidatedResultList[this.activeCollectionId];\n            [this.activeEntry] = currentCollectionArray;\n            // else if current index is at -1 go to the last entry in the list\n          } else if (!isWithinListLimit && currentCollectionIndex === 0\n            && currentEntryIndex === -1) {\n            this.activeCollectionId = this.resultListInt[this.resultListInt.length - 1][this\n              .autocompletePropertyNames.id];\n            currentCollectionArray = this.consolidatedResultList[this.activeCollectionId];\n            [this.activeEntry] = currentCollectionArray.slice(-1);\n          }\n        } else if (key === 'ArrowLeft') {\n          this.collectionSelect = true;\n        } else if (key === 'ArrowRight') {\n          this.collectionSelect = false;\n        }\n        // if the assistive text was set, announce if a new category was entered via\n        // key navigation! (not if in collection select mode because then category is announced\n        // anyway)\n        if (this.activeCollectionId && !this.collectionSelect\n          && previousActiveCollection !== this.activeCollectionId\n          && this.assistiveText.categoryAnnouncement) {\n          // since this.activeCollectionId is just the id we need to get the collection label\n          const collectionLabel = this.autocompleteResults\n            .find(({ [this.autocompletePropertyNames.id]: id }) => id === this.activeCollectionId)[this\n              .autocompletePropertyNames.label];\n          // set the announcement and the collection label\n          this.announcement = this.assistiveText.categoryAnnouncement\n            .replace('{label}', collectionLabel);\n        }\n      }\n    },\n    handleDropDownOnTabKey(event) {\n      // get all input elements\n      const inputElements = this.$el.getElementsByTagName('input');\n      // create an array out of input elements found\n      const searchInputArray = Array.from(inputElements)\n        // and filter only for elements that are connected to search (necessary for mode\n        // 'form' which has additional input fields)\n        .filter(element => element.id.includes('search'));\n      // check if some where found\n      if (inputElements) {\n        // get the index of the element the event came from\n        const eventInputIndex = searchInputArray.indexOf(event.target);\n        // check if element is either the last input element and no shift key was used or\n        // it is the first element and shift key was used --> if true --> close drop down\n        if ((!event.shiftKey && eventInputIndex >= searchInputArray.length - 1)\n          || (event.shiftKey && eventInputIndex <= 0)) {\n          this.isActive = false;\n        }\n      }\n    },\n    /**\n     * handle the date input after it was validated (necessary to only assign valid date input\n     * to filter_values)\n     *\n     * @param {string|Object} data - the date data in question - either a single string for type\n     * 'date' or an object with date_from and date_to for type 'daterange'\n     */\n    handleDateInput(data) {\n      // check if filter is actually of type date and the validated value differs from the\n      // previously set values\n      if (this.filter.type.includes('date')\n        && JSON.stringify(data) !== JSON.stringify(this.filter.filter_values)) {\n        this.currentInput = data;\n        // set the filter_values with date values - this will trigger search\n        this.$set(this.filter, 'filter_values', this.currentInput);\n        this.isActive = false;\n      }\n    },\n\n    /** OTHERS */\n\n    /**\n     * function to set the correct values for filter.filter_values attribute\n     *\n     * @param {Filter} newFilter - the newly selected filter\n     * @param {Filter} previousFilter - the previously set filter\n\n     * @returns {?string|Array|Object} the correct value type for the filter type\n     */\n    setFilterValues(newFilter, previousFilter = {}) {\n      const previousFilterValues = previousFilter.filter_values;\n      const { type } = newFilter;\n      const freetextAllowed = newFilter.freetext_allowed;\n      if (type === 'date') {\n        // map the date from daterange to date if necessary\n        return previousFilter.type && previousFilter.type.includes('date')\n          && previousFilterValues ? previousFilterValues.date_from || previousFilterValues.date_to : '';\n      }\n      if (type === 'daterange') {\n        // check if it can be mapped from date to daterange\n        if (previousFilter.type.includes('date')) {\n          return {\n            date_from: previousFilterValues ? previousFilterValues.date_from || previousFilterValues || '' : '',\n            date_to: previousFilterValues && previousFilterValues.to ? previousFilterValues.to : '',\n          };\n        }\n        // else just return empty object\n        return {\n          date_from: '',\n          date_to: '',\n        };\n      }\n      // check if both are autocomplete chips filters\n      if (type === 'chips' && freetextAllowed && previousFilter.type === 'chips' && previousFilter.freetext_allowed) {\n        // check if new filter is a superset filter of the previous filter (=previous\n        // filter id is included in current filter 'subsets' property\n        if (newFilter.subsets\n          && newFilter.subsets.includes(previousFilter[this.identifierPropertyName.filter])) {\n          return previousFilterValues;\n        }\n        // if both are chips with freetext keep options without id (=not specific entries)\n        return previousFilterValues && previousFilterValues.length ? previousFilterValues\n          .filter(value => !value[this.identifierPropertyName.autocompleteOption]) : [];\n      }\n      // check if previous filter was text and new filter is autocomplete chips\n      if (previousFilter.type === 'text' && previousFilterValues && previousFilterValues.length\n        && !!previousFilterValues[0] && type === 'chips' && freetextAllowed) {\n        return [{\n          [this.labelPropertyName.autocompleteOption]: previousFilterValues[0],\n        }];\n      }\n      return [];\n    },\n    /**\n     * reset all filter row input and navigational variables\n     */\n    resetAllInput() {\n      this.currentInput = '';\n      this.activeEntry = null;\n      this.activeCollectionId = '';\n      this.activeControlledVocabularyEntry = null;\n    },\n    /**\n     * needed for mobile filter view to determine when to show fade out on filter list\n     *\n     * @param {Event} event - the event that triggered the recalculation\n     */\n    calcFadeOut(event) {\n      // get the target element\n      const scrollElement = event.target;\n      // get the actual scroll position\n      const scrollPosition = scrollElement.scrollLeft;\n      // determine the maximum possible scroll position\n      const scrollMax = scrollElement.scrollWidth - scrollElement.clientWidth;\n      // set filter fade variables\n      this.filterFade = {\n        // show fade out left as soon as scroll position is different from 0\n        left: scrollPosition !== 0,\n        // show fade out right as soon as scroll position is different from maximum position\n        right: scrollPosition !== scrollMax,\n      };\n    },\n    /**\n     * function called on tab keydown on row 'x' or '+' icon\n     * @param {KeyboardEvent} event - the keydown event\n     */\n    onTab(event) {\n      // check if shift key was pressed on tab keydown (only if not the focus leaves the row)\n      if (!event.shiftKey) {\n        // if no - set row active to false\n        this.isActive = false;\n      }\n    },\n    /**\n     * on touch devices click-outside is not only triggered by 'touchstart' instead of 'click'.\n     *  this means the 'click-outside' event gets propagated before the 'click' event on touch devices (on\n     *  desktop browsers it is the other way round). This leads to search drop down getting\n     *  triggered when an element INSIDE search was clicked (in case of desktop when click-outside\n     *  is propagated AFTER this leads to isActive = false again immediately after so no drop\n     *  down showing). Therefore, we need to check for mobile event and set variable stopSearchClick\n     *  to true so in event onSearchClick the click can be stopped from opening the drop-down.\n     *\n     * @param {MouseEvent|TouchEvent} event - the event provided by click-outside plugin\n     */\n    onClickedOutsideSearch(event) {\n      // do the regular action to set is active false (and close drop down)\n      this.isActive = false;\n      // get the event type\n      const { type } = event;\n      // if event type is 'touchstart' we assume mobile that was propagated before click event\n      if (type === 'touchstart') {\n        // therefore we set the click stop variable true\n        this.stopSearchClick = true;\n        // since this should only affect click events triggered directly after set\n        // the variable false again after a time out\n        setTimeout(() => {\n          this.stopSearchClick = false;\n        }, 500);\n      }\n    },\n    /**\n     * need to special handle search click event due to the reasons described above in function\n     *  onClickedOutsideSearch().\n     *\n     * @param {MouseEvent} event - the native click event\n     */\n    onSearchClick(event) {\n      // check if mobile variable to stop click being propagated after click-outside\n      // was set\n      if (!this.stopSearchClick) {\n        // if no - show drop down\n        this.isActive = true;\n      } else {\n        // if click-outside was propagated before click event stop the event here\n        // and don't open drop down\n        event.stopPropagation();\n        this.isActive = false;\n        // set variable false again after\n        this.stopSearchClick = false;\n      }\n    },\n    initObservers() {\n      const tempObserver = new MutationObserver(this.filterChangeObserverAction);\n      tempObserver.observe(this.$refs.advancedSearchRow, {\n        subtree: true,\n        childList: true,\n      });\n      this.observer = tempObserver;\n      const tempResizeObserver = new ResizeObserver(this.resizeActions);\n      tempResizeObserver.observe(this.$refs.advancedSearchRow);\n      this.resizeObserver = tempResizeObserver;\n    },\n    filterChangeObserverAction() {\n      this.getSearchInputElement();\n      if (this.filter.type !== this.currentFilterType && this.isActive) {\n        if (this.searchInputElement) {\n          this.searchInputElement.focus();\n          this.currentFilterType = this.filter.type;\n        }\n      }\n    },\n    /**\n     * calculate the number of columns for filters and chips dynamically and\n     * use correct slot for selected filter depending on element size\n     */\n    resizeActions() {\n      // get the components base element\n      const searchRowElement = this.$refs.advancedSearchRow;\n      const searchElement = this.$refs.baseSearch;\n      // check if it was found\n      if (searchElement) {\n        // SET COLUMN STYLE\n        // get the width of the element\n        const searchElementWidth = searchElement.$el.clientWidth;\n        // set a css variable that is responsible for the number of items\n        // (subtract 1/4 of elementWidth because of first column): 180px is assumed for each column\n        this.$el.style.setProperty(\n          '--col-number',\n          Math.floor((searchElementWidth - searchElementWidth / 4) / 180) || 1,\n        );\n      }\n      // check if it was found\n      if (searchRowElement) {\n        // SET CORRECT SLOT FOR SELECTED FILTER DISPLAY\n        // get the width of the element\n        const searchRowElementWidth = searchRowElement.clientWidth;\n        this.filterSlotName = searchRowElementWidth >= 500 ? 'pre-input-field' : 'input-field-addition-before';\n      }\n    },\n    /**\n     * function to get the current search input element\n     */\n    getSearchInputElement() {\n      // get input elements\n      const inputElements = this.$el.getElementsByTagName('input');\n      // check if input elements were found\n      if (inputElements && inputElements.length) {\n        // if yes - transform HTMLElement list to Array and find the search input element\n        this.searchInputElement = Array.from(inputElements).find(inputElem => inputElem.id.includes('search-input')\n          && inputElem.id.includes(this.searchRowId));\n      }\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../../styles/variables\";\n\n.base-advanced-search-row {\n  position: relative;\n  width: 100%;\n  // css variable to define option background color\n  // THIS IS SETTING THE BACKGROUND COLOR IN BASEDROPDOWNLIST\n  --option-background: rgb(248, 248, 248);\n  // set number of columns for filters and chips\n  --col-number: 4;\n  display: flex;\n  flex-direction: row;\n\n  .base-advanced-search-row__search {\n    width: 100%;\n\n    &__shadow {\n      box-shadow: $box-shadow-reg;\n    }\n\n    .base-advanced-search-row__first-column {\n      // if the 25% is changed the function resizeActions() column calculations\n      // needs to be adapted as well\n      flex: 0 0 25%;\n      min-width: 120px;\n      max-width: 250px;\n      overflow-wrap: break-word;\n      margin-right: $spacing;\n\n      &__small {\n        flex: unset;\n        max-width: 100%;\n      }\n    }\n\n    .base-advanced-search-row__area-padding {\n      padding-right: $spacing;\n      padding-left: $spacing;\n    }\n\n    .base-advanced-search-row__filter-input {\n      align-self: center;\n\n      &.base-advanced-search-row__filter-input__date {\n        padding-left: $spacing-small;\n      }\n\n      .base-advanced-search-row__selected-filter-label {\n        color: $app-color;\n        display: -webkit-box;\n        -webkit-line-clamp: 2;\n        -webkit-box-orient: vertical;\n        overflow: hidden;\n      }\n    }\n\n    .base-advanced-search-row__icon-button {\n      display: flex;\n      flex: 0 0 auto;\n      align-self: center;\n      height: 100%;\n      padding: $spacing;\n      margin-right: -$spacing-small;\n      cursor: pointer;\n\n      &:active, &:focus {\n        color: $app-color;\n        fill: $app-color;\n      }\n\n      &.base-advanced-search-row__icon-button__date {\n        margin-right: -$spacing-small;\n        align-items: center;\n      }\n\n      .base-advanced-search-row__search-row-icon {\n        height: $icon-medium;\n        width: $icon-medium;\n      }\n\n      .base-advanced-search-row__icon-button__text {\n        display: none;\n      }\n    }\n\n    .base-advanced-search-row__drop-down-body {\n      background: white;\n      border-top: $separation-line;\n      width: 100%;\n      position: absolute;\n      box-shadow: $drop-shadow;\n      z-index: map-get($zindex, dropdown);\n\n      &.base-advanced-search-row__drop-down-body__date {\n        width: calc(100% + #{$spacing});\n        left: -$spacing-small;\n      }\n\n      .base-advanced-search-row__columns {\n        column-gap: $spacing;\n        column-count: var(--col-number, 4);\n        // this is used in the script part to calculate columns! (~line 1589)\n        column-width: 180px;\n        display: block;\n        width: 100%;\n\n        .base-advanced-search-row__column-item {\n          // for chrome columns not aligned properly and\n          // last item bleeding into next column\n          -webkit-column-break-inside: avoid;\n          backface-visibility: hidden;\n        }\n      }\n\n      .base-advanced-search-row__above-list-area {\n        &.base-advanced-search-row__above-list-area-filters {\n          border-bottom: $separation-line;\n          padding-top: $spacing-small-half;\n          padding-bottom: $spacing-small-half;\n        }\n\n        .base-advanced-search-row__filter-area-wrapper {\n          .base-advanced-search-row__filter-area {\n            display: flex;\n            flex-direction: row;\n            justify-content: space-between;\n            align-items: center;\n            width: 100%;\n\n            .base-advanced-search-row__filter-area-header {\n              align-self: flex-start;\n              max-width: 100%;\n\n              .base-advanced-search-row__filter-text {\n                padding-top: $spacing-small-half;\n                color: $font-color-second;\n              }\n              .base-advanced-search-row__filter-subtext {\n                color: $font-color-second;\n                font-size: $font-size-small;\n              }\n            }\n          }\n        }\n\n        .base-advanced-search-row__filter-list-wrapper {\n          .base-advanced-search-row__filter-list {\n            .base-advanced-search-row__filter {\n              cursor: pointer;\n              color: $app-color;\n              padding: $spacing-small-half $spacing;\n\n              &:focus {\n                outline: none;\n              }\n\n              &.base-advanced-search-row__filter-active, &:hover {\n                box-shadow: inset 0 0 0 1px $app-color;\n              }\n\n              &.base-advanced-search-row__filter-selected {\n\n              }\n            }\n          }\n        }\n\n        .base-advanced-search-row__chips-row, .base-advanced-search-row__filter-area-wrapper {\n          display: flex;\n        }\n\n        .base-advanced-search-row__chips-row {\n          align-items: baseline;\n          min-height: calc(#{$row-height-small} + #{$spacing-small});\n          padding-top: $spacing-small-half;\n          padding-bottom: $spacing-small-half;\n\n          &.base-advanced-search-row__chips-row__no-options {\n            padding-top: 0;\n            padding-bottom: 0;\n          }\n\n          .base-advanced-search-row__controlled-options-title {\n            color: $font-color-second;\n            min-height: $row-height-small;\n            padding-top: calc(#{$spacing-small} / 2);\n          }\n\n          .base-advanced-search-row__chips-list {\n            margin-left: $spacing;\n            line-height: $row-height-small;\n\n            .base-advanced-search-row__option-chip {\n              cursor: pointer;\n\n              &:hover::after {\n                content: '';\n                width: 100%;\n                height: 100%;\n                position: absolute;\n                top: 0;\n                right: 0;\n                background: $app-color;\n                opacity: 0.5;\n              }\n            }\n          }\n        }\n      }\n\n      .base-advanced-search-row__autocomplete-body {\n        display: flex;\n        flex-direction: row;\n        width: 100%;\n\n        .base-advanced-search-row__autocomplete-collection {\n          font-weight: 600;\n\n          .base-advanced-search-row__autocomplete-collection-text {\n            min-height: $row-height-small;\n            padding-top: calc(#{$spacing-small} / 2);\n          }\n        }\n\n        .base-advanced-search-row__autocomplete-options {\n          width: 100%;\n        }\n      }\n\n      .base-advanced-search-row__no-options {\n        min-height: calc(#{$row-height-small} + #{$spacing-small});\n        padding-top: 0;\n        padding-bottom: 0;\n        width: 100%;\n        display: flex;\n        align-items: center;\n\n        &.base-advanced-search-row__no-options-hidden {\n          display: none;\n        }\n      }\n    }\n  }\n}\n\n.base-advanced-search-row__add-filter-button {\n  margin-left: $spacing-small;\n  width: $row-height-large;\n\n  .base-advanced-search-row__add-filter-button__text {\n    display: none;\n  }\n\n  &__shadow {\n    box-shadow: $box-shadow-reg;\n  }\n}\n\n.base-advanced-search-row__filter-area-close {\n  display: none;\n\n  .base-advanced-search-row__filter-area-close-icon {\n    width: $icon-medium;\n    height: $icon-medium;\n  }\n}\n\n@media screen and (max-width: $mobile) {\n  .base-advanced-search-row {\n    flex-direction: column;\n\n    .base-advanced-search-row__add-filter-button {\n      margin-left: 0;\n      margin-top: $spacing-small;\n      height: $row-height-large;\n      width: 100%;\n\n      .base-advanced-search-row__add-filter-button__text {\n        display: inline;\n        margin-right: $spacing;\n      }\n    }\n\n    .base-advanced-search-row__first-column {\n      max-width: 100%;\n      margin-right: $spacing-small;\n    }\n\n    .base-advanced-search-row__drop-down-body {\n      .base-advanced-search-row__above-list-area{\n\n        .base-advanced-search-row__filter-area-wrapper, .base-advanced-search-row__chips-row {\n          flex-direction: column;\n        }\n\n        .base-advanced-search-row__filter-area-wrapper {\n          .base-advanced-search-row__filter-area {\n            max-width: unset;\n\n            .base-advanced-search-row__filter-area-close {\n              display: inline;\n              padding: $spacing-small $spacing;\n            }\n          }\n        }\n\n        .base-advanced-search-row__filter-list-wrapper {\n          position: relative;\n          overflow: hidden;\n          display: flex;\n          min-height: $row-height-small;\n\n          &.base-advanced-search-row__filter-list-wrapper__fade-right {\n            &::after {\n              content: '';\n              height: 100%;\n              width: 80px;\n              position: absolute;\n              top: 0;\n              right: 0;\n              background: linear-gradient(to right, rgba(255, 255, 255, 0),\n                rgba(255, 255, 255, 1));\n              pointer-events: none;\n            }\n          }\n\n          &.base-advanced-search-row__filter-list-wrapper__fade-left {\n            &::before {\n              content: '';\n              height: 100%;\n              width: 80px;\n              position: absolute;\n              top: 0;\n              left: 0;\n              background: linear-gradient(to right, rgba(255, 255, 255, 1),\n                rgba(255, 255, 255, 0));\n              pointer-events: none;\n            }\n          }\n\n          .base-advanced-search-row__filter-list {\n            column-count: unset;\n            column-gap: unset;\n            column-width: unset;\n            display: flex;\n            align-items: center;\n            flex-direction: row;\n            overflow: auto;\n            margin: 0 1px;\n            scrollbar-width: none; /* Firefox */\n            -ms-overflow-style: none;  /* Internet Explorer 10+ */\n\n            &::-webkit-scrollbar { /* WebKit */\n              width: 0;\n              height: 0;\n            }\n\n            .base-advanced-search-row__filter {\n              white-space: nowrap;\n\n              &.base-advanced-search-row__filter-selected,\n              &.base-advanced-search-row__filter-active,\n              &.base-advanced-search-row__filter:hover {\n                box-shadow: none;\n              }\n            }\n          }\n        }\n      }\n\n      .base-advanced-search-row__autocomplete-body {\n        flex-wrap: wrap;\n\n        .base-advanced-search-row__autocomplete-collection {\n          flex: 0 0 auto;\n          margin-right: 0;\n        }\n      }\n    }\n  }\n}\n</style>\n\n<style lang=\"scss\">\n@import '../../styles/variables';\n\n.base-advanced-search-row__input-field {\n  height: calc(#{$row-height-large} - 4px);\n}\n</style>\n"],"names":["_sfc_main","BaseButton","BaseDropDownList","BaseChip","BaseChipsInputField","BaseSearch","BaseIcon","navigateMixin","i18n","val","v","prop","key","advancedSearchRow","ref","announcement","useAnnouncer","createId","newFilter","filter","type","currentFilter","options","option","value","sort","resultsToDisplay","section","selectedOptionIds","entry","prev","curr","hasData","selectedFilter","previousFilter","previousInput","category","event","currentIndex","dropDownElement","isArrowDown","collectionId","selectedOptionCollection","newValue","oldFilterValues","newTextArray","resultsNumber","previousActiveCollection","currentCollectionIndex","currentCollectionArray","numberToAdd","currentEntryIndex","isWithinListLimit","newItemIndex","collectionLabel","id","inputElements","searchInputArray","element","eventInputIndex","data","previousFilterValues","freetextAllowed","scrollElement","scrollPosition","scrollMax","tempObserver","tempResizeObserver","searchRowElement","searchElement","searchElementWidth","searchRowElementWidth","inputElem"],"mappings":"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"}