<script type="text/babel">
import elementResizeDetectorMaker from 'element-resize-detector';

import BPagination from '../b-pagination';
import BTableBody from './b-table-body.vue';
import BTableHeader from './b-table-header.vue';

import {OrderType} from '../../constant/OrderConf';
import {genSortedRecords} from './helper/helper';
import {getText} from '../../util/i18n'; // eslint-disable-line


const EventTypes = {
    ON_SELECT: 'on-select',
    ON_PAGINATE: 'on-paginate',
    ON_SORT: 'on-sort',
    ON_LINE_CLICK: 'on-line-click'
};

let uniqueCellKey = 1;


export default {
    name: 'BTable',

    components: {
        BPagination,
        BTableHeader,
        BTableBody
    },

    props: {
        options: {
            type: Object,
            default: () => ({})
        },

        records: {
            type: Array,
            default: () => []
        },

        pagination: {
            type: Object,
            default: () => ({})
        },

        tbodyComponent: {
            type: [String, Object],
            default: 'tbody'
        },

        tbodyProps: {
            type: Object,
            default: null
        },

        tbodyListeners: {
            type: Object,
            default: null
        },

        showSummary: {
            type: Boolean,
            default: false
        },

        sumText: {
            type: String,
            default: '合计'
        },

        summaryMethod: {
            type: Function,
            default: null
        },

        fixHeight: {
            type: Number,
            default: null
        },

        hasChildren: {
            type: Boolean,
            default: false
        }
    },

    data() {
        const foldMap = this.options.colDefs.reduce((map, {field, children, foldOpen}) => {
            if (children) {
                map[field] = !!foldOpen;
            }
            return map;
        }, {});
        return {
            OrderType,

            sortInfo: {
                field: '',
                order: OrderType.NONE
            },

            foldMap,

            innerPagination: {
                pageNo: 1,
                pageSize: 10,
                total: 10
            },

            isAllSelected: false,
            selectedRows: [],
            hoverIndex: null,
            scrollValue: 0,
            scrollTop: 0,
            leftScroll: 0,
            bodyRowsHeight: [],
            headerRowsHeight: [],
            headersHeight: null,
            bodyHeight: null,
            table: {
                main: [],
                left: [],
                right: []
            }
        };
    },

    computed: {
        leftFixedColumns() {
            const vm = this;
            const {options: {colDefs = []}} = vm;
            return colDefs.filter(item => item.fixed === 'left');
        },

        rightFixedColumns() {
            const vm = this;
            const {options: {colDefs = []}} = vm;
            return colDefs.filter(item => item.fixed === 'right');
        },

        sortedRecords() {
            const vm = this;
            const {records, options: {enableClientSort = false}, sortInfo: {field, order}} = vm;

            if (!enableClientSort) return records;

            return genSortedRecords(records, field, order);
        },

        treeRecords() {
            const vm = this;
            const {sortedRecords, hasChildren} = vm;
            if (hasChildren) {
                sortedRecords.forEach((record) => {
                    const {children} = record;
                    vm.$set(record, 'extend', !!children && children.length > 0);
                });
            }

            return sortedRecords;
        },

        renderedRecords() {
            const vm = this;
            const {
                treeRecords,
                options: {enableClientPagination = false},
                innerPagination: {
                    pageNo,
                    pageSize
                }
            } = vm;

            if (!enableClientPagination) return treeRecords;

            return treeRecords.slice((pageNo - 1) * pageSize, pageNo * pageSize);
        },

        enableSort() {
            const {options: {enableClientSort, enableServerSort}} = this;
            return enableClientSort || enableServerSort;
        },


        hasRightShadow() {
            const vm = this;
            const {scrollValue} = vm;
            return scrollValue < vm.leftScroll;
        },


        hasLeftShadow() {
            const vm = this;
            const {scrollValue} = vm;
            return scrollValue > 0;
        },

        hasHeaderShadow() {
            const vm = this;
            const {scrollTop} = vm;
            return scrollTop > 0;
        }
    },

    watch: {
        records(newVal, oldVal) {
            if (newVal === oldVal) return;
            const vm = this;
            vm.handleWidthAndHeight();
            vm.updateInnerState();
            vm.updateAllSelectedState();
        },

        pagination(newVal) {
            const vm = this;

            Object.assign(
                vm.innerPagination,
                newVal
            );
        }
    },

    mounted() {
        const vm = this;

        vm.updateInnerState();
        vm.handleWidthAndHeight();

        vm.erd = elementResizeDetectorMaker();
        vm.erd.listenTo(vm.$el, vm.handleWidthAndHeight);
    },

    beforeDestroy() {
        this.erd.uninstall(this.$el);
    },

    methods: {
        handleWidthAndHeight() {
            const vm = this;
            vm.$nextTick(() => {
                if (vm.$refs.mainTable) {
                    vm.leftScroll = vm.$refs.mainTable.scrollWidth - vm.$refs.mainTable.clientWidth;
                    const {fixTableHeader, mainTableHeader} = vm.$refs;
                    const header = fixTableHeader || (mainTableHeader && mainTableHeader.$el);
                    vm.headerRowsHeight = vm.handleHeight(header);
                    vm.headersHeight = vm.getSummary(vm.headerRowsHeight);
                    vm.bodyRowsHeight = vm.handleHeight(vm.$refs.mainTableBody.$el);
                    vm.bodyHeight = vm.getSummary(vm.bodyRowsHeight);
                    vm.handleWidth();
                }
            });
        },

        getSummary(rows) {
            return rows.reduce((total, cur) => total + cur);
        },

        handleHeight(node, tag = 'tr') {
            const rows = Array.from(node.querySelectorAll(tag));

            return rows.map(item => item.offsetHeight);
        },

        handleWidth() {
            const vm = this;
            const bodyRows = vm.$refs.mainTableBody.$el.querySelectorAll('tr:first-of-type>td');
            const right = Array.from(bodyRows).filter(({className}) => className.includes('right'));
            const left = Array.from(bodyRows).filter(({className}) => className.includes('left'));
            const rightTableWidth = right.map(row => ({width: row.offsetWidth, field: row.getAttribute('field')}));
            const leftTableWidth = left.map(row => ({width: row.offsetWidth, field: row.getAttribute('field')}));
            const mainTableWidth = Array.from(bodyRows)
                .map(row => ({width: row.offsetWidth, field: row.getAttribute('field')}));
            vm.$set(vm.table, 'main', mainTableWidth);
            vm.$set(vm.table, 'left', leftTableWidth);
            vm.$set(vm.table, 'right', rightTableWidth);
        },

        handleBodyScroll() {
            const vm = this;
            const {fixTableHeader, mainTable, fixLeftTable, fixRightTable} = vm.$refs;
            const {scrollLeft, scrollTop} = mainTable;
            vm.scrollValue = scrollLeft;
            if (fixTableHeader) {
                fixTableHeader.scrollLeft = vm.scrollValue;
                vm.scrollTop = scrollTop;
            }
            if (fixLeftTable) fixLeftTable.scrollTop = scrollTop;
            if (fixRightTable) fixRightTable.scrollTop = scrollTop;
        },

        handleChangeRow(index) {
            const vm = this;
            vm.hoverIndex = index;
        },

        handleMouseLeave() {
            const vm = this;
            vm.hoverIndex = null;
        },

        isShowSortIcon(field) {
            const {enableSort, sortInfo: {supportFields = []}} = this;
            if (!enableSort) return false;
            if (!supportFields.length) return true;

            return supportFields.includes(field);
        },

        toggleSort(sortInfo) {
            const vm = this;
            const {
                options: {enableServerSort}
            } = vm;

            if (vm.isShowSortIcon(sortInfo.field)) {
                vm.sortInfo = sortInfo;
                vm.resetSelect();
                if (enableServerSort) {
                    vm.$emit(EventTypes.ON_SORT, sortInfo);
                }
            }
        },

        toggleFold({field}) {
            const vm = this;
            const {leftFixedColumns, rightFixedColumns, fixHeight} = vm;
            vm.$set(vm.foldMap, field, !vm.foldMap[field]);
            if (leftFixedColumns.length || rightFixedColumns.length || fixHeight) vm.handleWidthAndHeight();
        },

        onInnerPaginationChange(pagination) {
            const vm = this;

            Object.assign(vm.innerPagination, {...pagination});
            vm.resetSelect();
            vm.$emit(EventTypes.ON_PAGINATE, {...vm.innerPagination});
        },

        lineClick(record, lineIndex) {
            const vm = this;
            vm.$emit(EventTypes.ON_LINE_CLICK, {record, lineIndex});
        },

        onSelectAllChange(isSelected) {
            const vm = this;
            const {options: {disableSelect = () => false}, renderedRecords, selectedRows} = vm;
            renderedRecords.forEach((record, idx) => {
                if (disableSelect(record)) return;

                selectedRows.splice(idx, 1, isSelected);
            });
            vm.$emit(EventTypes.ON_SELECT, {
                selectedRecords: renderedRecords.filter((record, idx) => selectedRows[idx]),
                selectedRecord: null
            });
            this.isAllSelected = isSelected;
        },

        updateAllSelectedState() {
            const vm = this;
            const {options: {disableSelect = () => false}, renderedRecords, selectedRows} = vm;
            vm.isAllSelected = renderedRecords.every(
                (record, idx) => (selectedRows[idx] || disableSelect(record))
            );
        },

        onSelectChange(selectRecord) {
            const vm = this;
            const {renderedRecords, selectedRows} = vm;

            vm.updateAllSelectedState();
            vm.$emit(EventTypes.ON_SELECT, {
                selectedRecords: renderedRecords.filter((record, idx) => selectedRows[idx]),
                selectedRecord: selectRecord
            });
        },

        updateInnerState() {
            const vm = this;
            const {
                options: {
                    enableClientSort = false,
                    enableServerSort = false,
                    enableClientPagination = false,
                    enableServerPagination = false,

                    sortInfo
                },
                records = [],
                pagination = {}
            } = vm;

            if (sortInfo && (enableServerSort || enableClientSort)) Object.assign(vm.sortInfo, sortInfo);
            if (enableClientPagination || enableServerPagination) {
                Object.assign(
                    vm.innerPagination,
                    {
                        pageNo: 1,
                        pageSize: 10,
                        total: records.length
                    },
                    pagination
                );
            }

            this.initDefaultSelected();
        },

        initDefaultSelected() {
            const {options: {defaultSelected}, renderedRecords} = this;
            this.selectedRows = new Array(renderedRecords.length);
            if (defaultSelected) {
                renderedRecords.forEach((record, idx) => {
                    if (defaultSelected(record)) {
                        this.selectedRows.splice(idx, 1, true);
                    }
                });
                this.updateAllSelectedState();
                this.$emit(EventTypes.ON_SELECT, {
                    selectedRecords: renderedRecords.filter((record, idx) => this.selectedRows[idx]),
                    selectedRecord: null
                });

            }
        },

        getCellKey({field, enforceUpdateCell = false}) {
            uniqueCellKey += 1;
            return enforceUpdateCell ? `${field}${uniqueCellKey}` : field;
        },

        getText(key, defaultText) {
            return getText({vm: this, key: `baseui.table.${key}`, defaultText});
        },

        resetSelect() {
            const vm = this;

            this.isAllSelected = false;
            this.selectedRows = [];
            this.initDefaultSelected();
            vm.$emit(EventTypes.ON_SELECT, {
                selectedRecords: [],
                selectedRecord: null
            });
        },

        getPaginationProps() {
            const vm = this;
            const {onInnerPaginationChange, options: {paginationProps, size}} = vm;
            return {
                props: {
                    size,
                    ...paginationProps
                },
                on: {
                    'on-change': onInnerPaginationChange
                }
            };
        },

        getTableHeaderCommonProps() {
            const vm = this;
            const {
                options, isAllSelected, sortInfo, foldMap,
                onSelectAllChange, toggleSort, toggleFold, fixHeight
            } = vm;
            return {
                props: {
                    options, isAllSelected, sortInfo, foldMap, fixHeight
                },
                on: {
                    'select-all-change': onSelectAllChange,
                    'toggle-sort': toggleSort,
                    'toggle-fold': toggleFold
                }
            };
        },

        getTableBodyCommonProps() {
            const vm = this;
            const {
                options,
                tbodyComponent,
                tbodyProps,
                tbodyListeners,
                selectedRows,
                innerPagination,
                renderedRecords,
                hoverIndex,
                showSummary,
                sumText,
                summaryMethod,
                lineClick,
                onSelectChange,
                handleChangeRow,
                foldMap,
                fixHeight,
                hasChildren
            } = vm;
            return {
                props: {
                    options,
                    tbodyComponent,
                    tbodyProps,
                    tbodyListeners,
                    selectedRows,
                    pagination: innerPagination,
                    renderedRecords,
                    hoverIndex,
                    showSummary,
                    sumText,
                    summaryMethod,
                    foldMap,
                    fixHeight,
                    hasChildren
                },
                on: {
                    'change-row': handleChangeRow,
                    'select-change': onSelectChange,
                    'line-click': lineClick
                }
            };
        }
    },

    render() {
        const vm = this;
        const {options,
            records,
            $scopedSlots,
            innerPagination,
            leftFixedColumns,
            rightFixedColumns,
            handleMouseLeave,
            handleBodyScroll,
            hasLeftShadow,
            hasRightShadow,
            bodyRowsHeight,
            headerRowsHeight,
            fixHeight,
            headersHeight,
            bodyHeight,
            hasHeaderShadow,
            table
        } = vm;

        const noData = vm.getText('noData', '暂无数据');
        const paginationProps = vm.getPaginationProps();
        const tableHeaderCommonProps = vm.getTableHeaderCommonProps();
        const tableBodyCommonProps = vm.getTableBodyCommonProps();
        const viewHeight = Math.min(Number(bodyHeight), Number(fixHeight));
        const commonStyle = {height: `${viewHeight || null}px`};

        let fixTableStyle = {height: `${bodyHeight + headersHeight}px`};
        if (fixHeight && Number(bodyHeight) > fixHeight) {
            fixTableStyle = {height: `${fixHeight + headersHeight}px`};
        }
        const leftFixedTableStyle = {
            ...fixTableStyle,
            width: `${table.left.reduce((total, cur) => total + cur.width, 0)}px`
        };
        const rightFixedTableStyle = {
            ...fixTableStyle,
            width: `${table.right.reduce((total, cur) => total + cur.width, 0)}px`
        };
        return (
            <div class={[{'b-table-with-extra-th': options.extraThDefsList}, 'b-table']}
                onMouseleave={handleMouseLeave} >
                {
                    records.length && fixHeight ? (
                        <div class={[
                            'table-area',
                            'fixed-header',
                            {'table-fixed-header-scroll': hasHeaderShadow}
                        ]}
                            ref="fixTableHeader">
                            <table class="table">
                                <colgroup>
                                    {
                                        table.main
                                            .map(({field, width}) => <col name={field} key={field} style={`width:${width}px`} />)// eslint-disable-line
                                    }
                                </colgroup>
                                <b-table-header
                                    {...tableHeaderCommonProps}
                                    scopedSlots={$scopedSlots}
                                >
                                </b-table-header>
                            </table>
                        </div>
                    ) : ''
                }
                {
                    records.length > 0 ? (
                        <div class={[
                            'table-area',
                            {'fixed-body': fixHeight}
                        ]}
                            style={commonStyle} ref="mainTable" onScroll={handleBodyScroll}>
                            <table class="table main-table">
                                {!fixHeight && (<b-table-header
                                    ref="mainTableHeader"
                                    {...tableHeaderCommonProps}
                                    scopedSlots={$scopedSlots}
                                >
                                </b-table-header>)}
                                <b-table-body
                                    ref="mainTableBody"
                                    {...tableBodyCommonProps}
                                    scopedSlots={$scopedSlots}
                                >
                                </b-table-body>
                            </table>
                        </div>) : (<p class="no-record-remind">{noData}</p>)
                }
                {records.length && (options.enableClientPagination || options.enableServerPagination) ? (
                    <div
                        class="foot-area">
                        <b-pagination
                            {...paginationProps}
                            pagination={innerPagination}
                        />
                    </div>
                ) : ''}
                {records.length && leftFixedColumns.length > 0 ? (
                    <div class={[{'table-fixed-left-scroll': hasLeftShadow},
                        'table-area layout-fixed-left']} style={leftFixedTableStyle} ref="fixLeftTable">
                        <table class="table fixed-left" >
                            <colgroup>
                                {
                                    table.left
                                        .map(({field, width}) => <col name={field} key={field} style={`width:${width}px`} />)// eslint-disable-line
                                }
                            </colgroup>
                            <b-table-header
                                {...tableHeaderCommonProps}
                                rowsHeight={headerRowsHeight}
                                fixed="left"
                                scopedSlots={$scopedSlots}
                            >
                            </b-table-header>
                            <b-table-body
                                {...tableBodyCommonProps}
                                rowsHeight={bodyRowsHeight}
                                fixed="left"
                                scopedSlots={$scopedSlots}
                            >
                            </b-table-body>
                        </table>
                    </div>) : ''}
                {records.length && rightFixedColumns.length > 0 ? (
                    <div class={[{'table-fixed-right-scroll': hasRightShadow},
                        'table-area layout-fixed-right']} style={rightFixedTableStyle} ref="fixRightTable">
                        <table class="table fixed-right">
                            <colgroup>
                                {
                                    table.right
                                        .map(({field, width}) => <col name={field} key={field} style={`width:${width}px`} />)// eslint-disable-line
                                }
                            </colgroup>
                            <b-table-header
                                {...tableHeaderCommonProps}
                                rowsHeight={headerRowsHeight}
                                fixed="right"
                                scopedSlots={$scopedSlots}
                            >
                            </b-table-header>
                            <b-table-body
                                {...tableBodyCommonProps}
                                rowsHeight={bodyRowsHeight}
                                fixed="right"
                                scopedSlots={$scopedSlots}
                            >
                            </b-table-body>
                        </table>
                    </div>) : ''}
            </div>);
    }
};
</script>
