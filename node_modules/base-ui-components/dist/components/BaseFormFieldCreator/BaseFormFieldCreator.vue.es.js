import a from "../../directives/InsertTextAsHtml.es.js";
import d from "../../mixins/i18n.es.js";
import "./BaseFormFieldCreator.vue.es2.js";
import s from "../../_virtual/_plugin-vue2_normalizer.es.js";
const f = {
  name: "BaseFormFieldCreator",
  components: {
    BaseDropDown: () => import("../BaseDropDown/BaseDropDown.vue.es.js").then((t) => t.default || t),
    BaseDateInput: () => import("../BaseDateInput/BaseDateInput.vue.es.js").then((t) => t.default || t),
    BaseForm: () => import("../BaseForm/BaseForm.vue.es.js").then((t) => t.default || t),
    BaseToggle: () => import("../BaseToggle/BaseToggle.vue.es.js").then((t) => t.default || t),
    BaseLink: () => import("../BaseLink/BaseLink.vue.es.js").then((t) => t.default || t)
  },
  directives: {
    insertTextAsHtml: a
  },
  mixins: [d],
  props: {
    /**
     * a key to uniquely identify the field
     */
    fieldKey: {
      type: [Number, String],
      required: !0
    },
    /**
     * field information as provided in [openAPI](https://spec.openapis.org/oas/v3.1.0#schema-object) standard
     */
    field: {
      type: Object,
      required: !0
    },
    /**
     * the field value
     */
    fieldValue: {
      type: [Object, String, Array, Date, Number, Boolean],
      required: !0
    },
    /**
     * add properties any input field can take and set values - find the possible variables at the
     * respective input components:
     * [BaseInput](BaseInput)
     * [BaseAutocompleteInput](BaseAutocompleteInput)
     * [BaseMultilineTextInput](BaseMultilineTextInput)
     * [BaseChipsInput](BaseChipsInput)
     * [BaseChipsBelow](BaseChipsBelow)
     * [BaseDateInput](BaseDateInput)
     * [BaseToggle](BaseToggle)
     *
     * **Caveat**: this means several input field properties are settable via separate props as well
     * as via `fieldProps` (e.g. `language`, `required`, `sortText`) the logic here is the following:
     *  separate props will have priority over `fieldProps` values **unless** the separate
     *  prop has a default value other than ones evaluating to `false` (boolean false,
     *  empty string).
     *  Field props that are set via `x-attrs` (e.g. `allowUnknownEntries`) in the OpenAPI definition
     *  have priority over `fieldProps` set values.
     *  Fields for which a unified appearance makes sense (e.g. `clearable`, `showErrorIcon`) or that
     *  are modified internally (e.g. `input`, `selectedList`) might not be settable
     *  via `fieldProps`.
     */
    fieldProps: {
      type: Object,
      default: () => ({})
    },
    /**
     * a label for the field
     */
    label: {
      type: String,
      default: ""
    },
    /**
     * define if field label should be shown
     */
    showLabel: {
      type: Boolean,
      default: !0
    },
    /**
     * a placeholder for the field
     * per default the placeholder attribute in OpenAPI `x-attrs` field will be used
     * (no need to specify that)
     */
    placeholder: {
      type: [String, Object],
      default: ""
    },
    /**
     * provide an options list for `autocomplete`, `chips` or `chips-below` fields
     * for field type `group` provide a nested object with field names
     * as properties and an array for each field to ensure the correct options are assigned
     * even if field names within different groups are identical
     */
    dropDownList: {
      type: [Array, Object],
      default: () => []
    },
    /**
     * provide a second options list (needed e.g. for texts field (text type) or
     * contributors field (roles)
     */
    secondaryDropdown: {
      type: Array,
      default: () => []
    },
    /**
     * provide data for elements that have a hover box (chips)
     */
    hoverBoxData: {
      type: Object,
      default: () => ({})
    },
    /**
     * possibility to steer field loading (`chips`, `autocomplete`) from outside
     */
    autocompleteLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * set the current language
     */
    language: {
      type: String,
      default: "en"
    },
    /**
     * provide available locales
     */
    availableLocales: {
      type: Array,
      default: () => []
    },
    /**
     * set a sorting text
     */
    sortText: {
      type: String,
      default: "Sort A - Z"
    },
    /**
     * pass down all necessary options for potential subform.
     *   see [BaseForm props](BaseForm)
     */
    fieldGroupParams: {
      type: Object,
      default: () => ({})
    },
    /**
     * mark as required field
     *
     * **Caveat**: currently the required prop is only used to trigger [BaseChipsBelow](BaseChipsBelow) validation -
     *             for all other form fields it is only used for the `aria-required` attributes
     * **Note**: if required is also set via OpenAPI definition x-attrs (provided by prop `field`) this will overwrite the prop!
     */
    required: {
      type: Boolean,
      default: !1
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field.
     * for an example see [BaseInput](BaseInput)
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * add an error message to be displayed below form field if field is invalid.
     * for an example see [BaseInput](BaseInput)
     */
    errorMessage: {
      type: String,
      default: ""
    },
    /**
     * define validation texts to be displayed below form field if input is invalid.
     * for an example see [BaseInput](BaseInput)
     */
    validationTexts: {
      type: Object,
      default: () => ({
        text: {
          min: "Value must be greater than or equal to {value}.",
          max: "Value must be less than or equal to {value}.",
          minLength: "Text must be at least {value} character(s) long.",
          maxLength: "Text cannot be longer than {value} characters."
        },
        chips: {
          required: "Select an option."
        }
      }),
      // checking if all necessary properties are part of the provided object
      validator: (t) => ["text"].every((e) => Object.keys(t).includes(e)) && ["min", "max", "minLength", "maxLength"].every((e) => Object.keys(t.text).includes(e))
    },
    /**
     * define if error icon should be shown.
     * for an example see [BaseInput](BaseInput)
     */
    showErrorIcon: {
      type: Boolean,
      default: !0
    },
    /**
     * if `true` a remove icon will be shown allowing to remove
     * all input at once.
     * for an example see [BaseInput](BaseInput)
     */
    clearable: {
      type: Boolean,
      default: !0
    },
    /**
     * specify the object property that should be used as identifier
     */
    identifierPropertyName: {
      type: String,
      default: "source"
    },
    /**
     * specify the object property that should be used as value to be displayed
     */
    labelPropertyName: {
      type: String,
      default: "label"
    },
    /**
     * this prop gives the option to add assistive text for screen readers
     * properties:
     *
     * Options for inputs type `autocomplete`, `chips`, `chips-below`:
     * **loaderActive**: text that is announced when options are being fetched (prop
     *  `isLoading` is set `true`)
     *
     * Options for inputs type `chips`:
     * **optionToRemoveSelected**: text read when option is marked active for removal (by using
     *  backspace in empty input field). string {label} could be added to be replaced
     *  by the actual chip label (value in [`labelPropertyName`])
     *
     * Options for inputs type `chips`, `chips-below`:
     * **resultsRetrieved**: text that is announced when results were retrieved (drop down
     *  list changed)
     * **optionAdded**: text read when option was added to the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     * **optionRemoved**: text read when option was removed from the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     */
    assistiveText: {
      type: Object,
      default: () => ({
        loaderActive: "loading.",
        resultsRetrieved: "{number} options in drop down.",
        optionAdded: "option {label} added to selected list.",
        optionToRemoveSelected: "option {label} from selected list marked for removal. Press delete or backspace to remove.",
        optionRemoved: "option {label} removed."
      })
    }
  },
  data() {
    return {
      /**
       * internal representation of field value
       * @type {any}
       */
      fieldValueInt: null,
      /**
       * variable for current text input in chips fields
       * @type {string}
       */
      textInput: "",
      /**
       * internal loading indicator
       * @type {boolean}
       */
      fetchingData: !1,
      /**
       * internal active tab for multiline text field
       * @type {string}
       */
      activeTab: "",
      /**
       * store a copy of fieldValueInt to only trigger event when value
       *  has changed
       *  @type {any}
       */
      originalFieldValueInt: null
    };
  },
  computed: {
    /**
     * import the relevant component
     * @returns {(function(): Promise)|null}
     */
    fieldElement() {
      return this.fieldType === "text" || this.fieldType === "integer" || this.fieldType === "float" ? () => import("../BaseInput/BaseInput.vue.es.js") : this.fieldType === "multiline" ? () => import("../BaseMultilineTextInput/BaseMultilineTextInput.vue.es.js") : this.fieldType === "autocomplete" ? () => import("../BaseAutocompleteInput/BaseAutocompleteInput.vue.es.js") : this.fieldType === "chips" ? () => import("../BaseChipsInput/BaseChipsInput.vue.es.js") : this.fieldType === "chips-below" ? () => import("../BaseChipsBelow/BaseChipsBelow.vue.es.js") : null;
    },
    /**
     * check which date field type was provided and set type accordingly
     * @returns {string}
     */
    dateType() {
      const t = this.field.properties || this.field.items && this.field.items.properties ? Object.keys(this.field.properties || this.field.items.properties) : [];
      return !this.field.properties && (!this.field.items || !this.field.items.properties) ? "single" : t.includes("date_to") && t.includes("time_to") ? "daterangetimerange" : t.includes("date") && t.includes("time_to") ? "datetimerange" : t.includes("time") ? "datetime" : t.includes("date_to") ? "daterange" : t.includes("time_from") && t.includes("time_to") ? "timerange" : "single";
    },
    /**
     * get field properties from swagger info - necessary for subforms
     * @returns {Object}
     */
    groupFormFields() {
      return this.field.type === "array" ? this.field.items.properties : this.field.properties;
    },
    /**
     * function to check if dropdowns for field groups are nested. Nesting was necessary
     * to ensure every field group gets their own dropdown even if field names are identical.
     * For backwards compatibility keep using direct base level fieldName array as fallback.
     * @returns {{ [fieldName]: Object[] }}
     */
    fieldGroupDropDownLists() {
      const t = this.field.name, { dropDownLists: e } = this.fieldGroupParams;
      return e && e[t] ? e[t] : e;
    },
    formFieldXAttrs() {
      return this.field["x-attrs"] || {};
    },
    // the type default for texts field
    textTypeDefault() {
      return {
        // map the language specific labels for no value selected to the default
        [this.labelPropertyName]: this.setLangLabels("form.noTextType", this.availableLocales),
        [this.identifierPropertyName]: ""
      };
    },
    // compute the texts type drop down list specific for texts
    textTypeOptions() {
      return [this.textTypeDefault].concat(this.secondaryDropdown);
    },
    // for chips input fields - check if it is a contributors field
    isContributorOrEquivalent() {
      return this.field.name === "contributors" || this.formFieldXAttrs.equivalent === "contributors";
    },
    // to determine text display for chips input
    fieldInput() {
      return this.textInput && this.textInput.length > 2;
    },
    // check if chips input is a single select field
    isChipsSingleSelect() {
      return this.fieldType && this.fieldType.includes("chips") && this.field.type === "object";
    },
    // check if label was specified - if not defer from title or check if there is a localized term
    labelInt() {
      return this.label || this.fieldProps.label ? this.label || this.fieldProps.label : this.field.title || this.getI18nTerm(`form.${this.field.name}` || this.field.name);
    },
    // check if placeholder was specified - if not defer from
    // title or check if there is a localized term
    placeholderInt() {
      return this.placeholder || this.fieldProps.placeholder ? this.placeholder || this.fieldProps.placeholder : this.formFieldXAttrs.placeholder || "" || `${this.hasI18n ? this.getI18nTerm("form.select") : "Select"} ${this.labelInt}`;
    },
    // compute field type
    fieldType() {
      return this.formFieldXAttrs.field_type || "text";
    },
    tabs() {
      return this.field.items && this.field.items.properties && this.field.items.properties.data && this.field.items.properties.data.items && this.field.items.properties.data.items.properties && this.field.items.properties.data.items.properties.language ? Object.keys(this.field.items.properties.data.items.properties.language.properties.label.properties).filter((t) => this.availableLocales.includes(t)) : [];
    },
    /**
     * check if field is either type integer of float
     * @returns {boolean}
     */
    isNumberField() {
      const t = this.field.items ? this.field.items.type : this.field.type;
      return ["integer", "number"].includes(t) && ["integer", "float", "text"].includes(this.fieldType);
    },
    /**
     * check allowed number of decimals
     * @returns {number|null}
     */
    allowedDecimals() {
      const t = this.formFieldXAttrs.decimals || this.fieldProps.decimals, e = this.field.type === "array" ? this.field.items.type : this.field.type, l = this.field.type === "array" ? this.field.items.format : this.field.format;
      return e === "number" && ["float", "double", "decimal"].includes(l) && !(t || t === 0) ? -1 : (e === "number" || this.fieldProps.fieldType === "number") && ["float", "double", "decimal"].includes(l) && (t || t === 0) ? t : e === "integer" || this.fieldProps.fieldType === "number" || t === 0 ? 0 : null;
    },
    /**
     * create the assistiveText object as required by the input component
     * depending on field type
     * @returns {{loaderActive: (string|*)}|Object|undefined|{}}
     */
    assistiveTextInt() {
      if (this.fieldType === "chips")
        return this.assistiveText;
      if (this.fieldType === "autocomplete")
        return {
          loaderActive: this.assistiveText.loaderActive || ""
        };
      if (this.fieldType === "chips-below") {
        const t = { ...this.assistiveText };
        return delete t.optionToRemoveSelected, t;
      }
    }
  },
  watch: {
    fieldValue: {
      handler(t) {
        if (JSON.stringify(this.fieldValueInt) !== JSON.stringify(t)) {
          this.setFieldValue(t);
          const e = this.fieldProps.tabs || this.tabs;
          e && e.length && (this.activeTab = this.setActiveTab());
        }
      },
      immediate: !0
    },
    fieldValueInt: {
      handler(t) {
        t !== void 0 && JSON.stringify(this.fieldValue) !== JSON.stringify(t) && this.$emit("field-value-changed", t);
      },
      deep: !0
    },
    dropDownList: {
      handler() {
        this.fetchingData = !1;
      },
      deep: !0
    }
  },
  mounted() {
    this.setFieldValue(this.fieldValue), this.tabs && this.tabs.length && (this.activeTab = this.setActiveTab());
  },
  methods: {
    // function for setting internal field value breaking all potential links to
    // value passed from parent
    setFieldValue(t) {
      t && typeof t == "object" ? t.length >= 0 ? this.fieldValueInt = [].concat(JSON.parse(JSON.stringify(t))) : this.fieldValueInt = { ...JSON.parse(JSON.stringify(t)) } : this.fieldValueInt = t;
    },
    // as above but specific for multiline text input field
    setInputValue(t) {
      !t || typeof t == "string" || typeof t == "number" ? this.fieldValueInt = t : this.fieldValueInt = { ...this.fieldValueInt, ...JSON.parse(JSON.stringify(t)) };
    },
    /**
     * called by chips input autocomplete
     * @param {Object} event - the spread object emitted
     * @property {string} event.value - the string in the input field
     */
    fetchAutocomplete({ value: t }) {
      this.fetchingData = !0, this.textInput = t, this.$emit("fetch-autocomplete", {
        value: t,
        name: this.field.name,
        source: this.formFieldXAttrs.source,
        equivalent: this.formFieldXAttrs.equivalent
      });
    },
    /**
     * called from subform - already contains all the information to pass
     * to parent (see above for details)
     * @param {Object} autocompleteInformation
     */
    subFormFetchAutocomplete(t) {
      const e = t.parentFields || [];
      e.unshift(this.field.name), this.$emit("fetch-autocomplete", {
        ...t,
        parentFields: e
      });
    },
    /**
     * function getting label from all possible label structures (lang object (--> get
     // correct lang) or simple string)
     * @param {string|Object} value - the language string or object - if object it contains
     * all the languages e.g. { de: '', en: '' }
     * @returns {string}
     */
    getLabel(t) {
      return this.getLangLabel(t, this.language, !0);
    },
    // functionality for multiline text input with language tabs
    setActiveTab() {
      const t = this.availableLocales.filter((e) => !!this.fieldValueInt[e]);
      return !t.length || this.fieldValueInt[this.language] ? this.language : t[0];
    },
    // function for mulitline text input to set drop down field correctly
    setMultilineDropDown(t) {
      this.$set(this.fieldValueInt, "type", t.source ? t : null), this.emitCompletedInputValues();
    },
    // prevent default action for everything except multiline
    onEnter(t) {
      this.fieldType !== "multiline" && (t.preventDefault(), this.emitCompletedInputValues());
    },
    /**
     * function to trigger event informing parent that input on that specific input field was completed
     */
    emitCompletedInputValues() {
      JSON.stringify(this.fieldValueInt) !== JSON.stringify(this.originalFieldValueInt) && (this.originalFieldValueInt = JSON.parse(JSON.stringify(this.fieldValueInt)), this.$emit("input-complete", this.fieldValueInt));
    },
    fetchBoxData() {
      this.$emit("fetch-info-data");
    }
  }
};
var u = function() {
  var n;
  var e = this, l = e._self._c;
  return l("div", [e.fieldType !== "date" && e.fieldType !== "chips" && e.fieldType !== "chips-below" && e.fieldType !== "group" && e.fieldType !== "boolean" ? l(e.fieldElement, e._b({ key: e.fieldKey, tag: "component", attrs: { id: e.fieldKey, label: e.labelInt, "show-label": e.fieldProps.showLabel !== void 0 ? e.fieldProps.showLabel : e.showLabel, placeholder: e.placeholderInt, tabs: e.fieldType === "multiline" ? e.fieldProps.tabs || e.tabs : !1, "tab-labels": e.fieldType === "multiline" ? e.fieldProps.tabLabels || e.tabs.map((i) => e.getI18nTerm(i)) : !1, "tabs-legend": e.fieldType === "multiline" ? e.fieldProps.tabsLegend || e.getI18nTerm("form.textTabsLegend") : !1, "active-tab": e.fieldType === "multiline" ? e.activeTab : !1, list: e.fieldType === "autocomplete" ? (n = e.dropDownList) != null && n.length ? e.dropDownList : e.fieldProps.list || [] : !1, "is-loading": e.autocompleteLoading, input: e.fieldValueInt, "field-type": e.isNumberField ? "number" : e.fieldProps.fieldType || "text", invalid: e.invalid || e.fieldProps.invalid, required: e.required || e.fieldProps.required, "error-message": e.errorMessage || e.fieldProps.errorMessage, "validation-texts": e.fieldProps.validationTexts ? e.fieldProps.validationTexts[e.isNumberField ? "text" : e.fieldType] || e.fieldProps.validationTexts : e.validationTexts[e.isNumberField ? "text" : e.fieldType], "show-error-icon": e.showErrorIcon, clearable: e.clearable, "min-length": e.field.minLength || e.fieldProps.minLength, "max-length": e.field.maxLength || e.fieldProps.maxLength, min: typeof e.formFieldXAttrs.min < "u" ? e.formFieldXAttrs.min : e.fieldProps.min, max: typeof e.formFieldXAttrs.max < "u" ? e.formFieldXAttrs.max : e.fieldProps.max, decimals: e.allowedDecimals, "decimal-separator": e.fieldProps.decimalSeparator || e.language === "de" ? "," : ".", "assistive-text": e.assistiveTextInt }, on: { keydown: function(i) {
    return !i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : e.onEnter.apply(null, arguments);
  }, blur: e.emitCompletedInputValues, input: function(i) {
    return e.setInputValue(i);
  }, "fetch-dropdown-entries": function(i) {
    return e.$emit("fetch-autocomplete", {
      value: i,
      name: e.field.name,
      source: e.formFieldXAttrs.source
    });
  } }, scopedSlots: e._u([{ key: "label-addition", fn: function() {
    return [e._t("label-addition", null, { fieldName: e.field.name }), e.fieldType === "multiline" && e.field.items && e.field.items.properties && e.field.items.properties.type ? l("BaseDropDown", { staticClass: "base-form-field-creator__multiline-dropdown", attrs: { id: e.fieldKey, "selected-option": e.fieldValueInt && e.fieldValueInt.type && e.fieldValueInt.type.source ? e.fieldValueInt.type : e.textTypeDefault, options: e.textTypeOptions, label: e.getI18nTerm("form.texttype"), language: e.language, "value-prop": "source" }, on: { "value-selected": e.setMultilineDropDown } }) : e._e()];
  }, proxy: !0 }, { key: "pre-input-field", fn: function() {
    return [e._t("pre-input-field", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [e._t("input-field-addition-before", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [e._t("input-field-inline-before", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [e._t("input-field-addition-after", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [e._t("post-input-field", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("remove-icon")];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e._t("below-input", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "drop-down-entry", fn: function({ item: i }) {
    return [e.fieldType === "autocomplete" ? [e._t("drop-down-entry", null, { fieldName: e.field.name, option: i })] : e._e()];
  } }], null, !0) }, "component", e.fieldProps, !1)) : e.fieldType === "date" ? l("fieldset", { staticClass: "base-form-field-creator__date-fieldset" }, [l("div", { staticClass: "base-form-field-creator__date-field-wrapper" }, [e.dateType === "single" || e.dateType.includes("date") ? l("BaseDateInput", e._b({ key: e.fieldKey + "_date", staticClass: "base-form-field-creator__date-field", attrs: { id: e.fieldKey, label: e.labelInt, "show-label": e.fieldProps.showLabel !== void 0 ? e.fieldProps.showLabel : e.showLabel, placeholder: e.placeholderInt, "range-separator": e.fieldProps.rangeSeparator || e.getI18nTerm("form.until"), format: e.formFieldXAttrs.date_format || e.fieldProps.format, type: e.dateType.includes("timerange") ? e.dateType.includes("daterange") ? "daterange" : "single" : e.dateType, "date-format-labels": e.fieldProps.dateFormatLabels || {
    date: e.getI18nTerm("form.date"),
    month: e.getI18nTerm("form.month"),
    year: e.getI18nTerm("form.year")
  }, "format-tabs-legend": e.fieldProps.formatTabsLegend || e.getI18nTerm("form.dateTabsLegend"), language: e.language, invalid: e.invalid || e.fieldProps.invalid, required: e.required || e.fieldProps.required, "error-message": e.errorMessage || e.fieldProps.errorMessage }, on: { "value-validated": e.emitCompletedInputValues }, scopedSlots: e._u([{ key: "label-addition", fn: function() {
    return [e._t("label-addition", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "pre-input-field", fn: function() {
    return [e._t("pre-input-field", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [e._t("input-field-addition-before", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [e._t("input-field-inline-before", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [e._t("input-field-addition-after", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [e._t("post-input-field", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("remove-icon")];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e._t("below-input", null, { fieldName: e.field.name })];
  }, proxy: !0 }], null, !0), model: { value: e.fieldValueInt, callback: function(i) {
    e.fieldValueInt = i;
  }, expression: "fieldValueInt" } }, "BaseDateInput", e.fieldProps, !1)) : e._e(), e.dateType.includes("timerange") ? l("BaseDateInput", e._b({ key: e.fieldKey + "_time", class: [
    "base-form-field-creator__date-field",
    { "base-form-field-creator__date-field--spacing": e.dateType.includes("date") }
  ], attrs: { id: e.fieldKey, label: e.dateType !== "timerange" && e.field.properties.time_from.title ? e.field.properties.time_from.title : e.labelInt, "show-label": !e.dateType.includes("date"), placeholder: e.placeholderInt.time || e.placeholderInt, "range-separator": e.fieldProps.rangeSeparator || e.getI18nTerm("form.until"), invalid: e.invalid || e.fieldProps.invalid, required: e.required || e.fieldProps.required, "error-message": e.errorMessage || e.fieldProps.errorMessage, type: "timerange" }, on: { "value-validated": e.emitCompletedInputValues }, scopedSlots: e._u([{ key: "label-addition", fn: function() {
    return [e._t("label-addition", null, { fieldName: `${e.field.name}-time` })];
  }, proxy: !0 }, { key: "pre-input-field", fn: function() {
    return [e._t("pre-input-field", null, { fieldName: `${e.field.name}-time` })];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [e._t("input-field-addition-before", null, { fieldName: `${e.field.name}-time` })];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [e._t("input-field-inline-before", null, { fieldName: `${e.field.name}-time` })];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [e._t("input-field-addition-after", null, { fieldName: `${e.field.name}-time` })];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [e._t("post-input-field", null, { fieldName: `${e.field.name}-time` })];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("remove-icon")];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e._t("below-input", null, { fieldName: `${e.field.name}-time` })];
  }, proxy: !0 }], null, !0), model: { value: e.fieldValueInt, callback: function(i) {
    e.fieldValueInt = i;
  }, expression: "fieldValueInt" } }, "BaseDateInput", e.fieldProps, !1)) : e._e()], 1)]) : e.fieldType === "chips" || e.fieldType === "chips-below" ? l(e.fieldElement, e._b({ key: e.fieldKey, ref: e.fieldType + e.fieldKey, tag: "component", attrs: { id: e.fieldKey, placeholder: e.placeholderInt, label: e.labelInt, "show-label": e.fieldProps.showLabel !== void 0 ? e.fieldProps.showLabel : e.showLabel, list: e.dropDownList.length ? e.dropDownList : e.fieldProps.list || [], "allow-dynamic-drop-down-entries": e.formFieldXAttrs.dynamic_autosuggest || !!e.fieldProps.allowDynamicDropDownEntries, "allow-multiple-entries": !e.isChipsSingleSelect, "allow-unknown-entries": e.formFieldXAttrs.allow_unknown_entries || !!e.fieldProps.allowUnknownEntries, draggable: !!e.fieldProps.draggable || !e.isChipsSingleSelect, "hoverbox-content": e.hoverBoxData || e.fieldProps.hoverBoxData, sortable: e.formFieldXAttrs.sortable || !!e.fieldProps.sortable, "is-loading": e.autocompleteLoading, "sort-text": e.fieldProps.sortText || e.sortText, "sort-name": e.fieldProps.sortName || e.isContributorOrEquivalent, language: e.formFieldXAttrs.set_label_language || e.fieldType === "chips-below" ? e.language : "", "drop-down-no-options-info": e.fieldProps.dropDownNoOptionsInfo || e.getI18nTerm("form.noMatch"), "additional-prop-options": e.fieldType === "chips-below" ? e.secondaryDropdown : !1, "additional-prop-placeholder": e.fieldType === "chips-below" ? e.fieldProps.additionalPropPlaceholder || e.getI18nTerm("form.selectRoles") : !1, "additional-property-name": e.fieldType === "chips-below" ? e.fieldProps.additionalPropertyName || "roles" : !1, "additional-prop-required": e.fieldType === "chips-below" ? e.formFieldXAttrs.additional_prop_required : null, invalid: e.invalid || e.fieldProps.invalid, required: e.field.required || e.required || e.fieldProps.required, "error-message": e.errorMessage || e.fieldProps.errorMessage, "validation-texts": e.validationTexts.chips || e.fieldProps.validationTexts.chips, "show-error-icon": e.showErrorIcon, "identifier-property-name": e.fieldProps.identifierPropertyName || e.identifierPropertyName, "label-property-name": e.fieldProps.labelPropertyName || e.labelPropertyName, "assistive-text": e.assistiveTextInt }, on: { "selected-changed": e.emitCompletedInputValues, "fetch-dropdown-entries": e.fetchAutocomplete, input: function(i) {
    e.textInput = i;
  }, "hoverbox-active": e.fetchBoxData }, scopedSlots: e._u([{ key: "drop-down-entry", fn: function({ item: i }) {
    return [e._t("drop-down-entry", function() {
      return [l("span", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: {
        value: e.getLabel(i[e.labelPropertyName]),
        interpretTextAsHtml: e.fieldProps.interpretChipsLabelAsHtml
      }, expression: `{
            value: getLabel(item[labelPropertyName]),
            interpretTextAsHtml: fieldProps.interpretChipsLabelAsHtml,
          }` }] }), l("span", { staticClass: "base-form-field-creator__chips-dropdown-second" }, [e._v(" " + e._s(i.additional) + " ")]), l("span", { staticClass: "base-form-field-creator__chips-dropdown-third" }, [e._v(" " + e._s(i.source_name) + " ")])];
    }, { fieldName: e.field.name, option: i })];
  } }, { key: "no-options", fn: function() {
    return [e.formFieldXAttrs.dynamic_autosuggest && !e.fieldInput ? l("span", [e._v(" " + e._s(e.getI18nTerm("form.startTyping")) + " ")]) : !e.formFieldXAttrs.dynamic_autosuggest && e.textInput ? l("span", [e._v(" " + e._s(e.getI18nTerm("form.noMatch")) + " ")]) : e.fieldInput && !e.fetchingData && !e.autocompleteLoading ? l("span", [e._v(" " + e._s(e.getI18nTerm("form.noResult")) + " ")]) : l("span", [e._v(" " + e._s(e.getI18nTerm("form.fetchingResults")) + " ")])];
  }, proxy: !0 }, { key: "label-addition", fn: function() {
    return [e._t("label-addition", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "pre-input-field", fn: function() {
    return [e._t("pre-input-field", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [e._t("input-field-addition-before", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [e._t("input-field-inline-before", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [e._t("input-field-addition-after", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [e._t("post-input-field", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("default", null, { fieldName: e.field.name })];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e._t("below-input", null, { fieldName: e.field.name })];
  }, proxy: !0 }], null, !0), model: { value: e.fieldValueInt, callback: function(i) {
    e.fieldValueInt = i;
  }, expression: "fieldValueInt" } }, "component", e.fieldProps, !1)) : e.fieldType === "group" ? l("div", { key: e.fieldKey, staticClass: "base-form-field-creator__field-array" }, [e.formFieldXAttrs.show_label ? l("div", { staticClass: "base-form-field-creator__field-array-label" }, [e._v(" " + e._s(`${e.labelInt}:`) + " ")]) : e._e(), l("div", { key: e.fieldKey, staticClass: "base-form-field-creator__subform-wrapper" }, [l("BaseForm", e._b({ staticClass: "base-form-field-creator__subform", attrs: { "form-field-json": e.groupFormFields, "value-list": e.fieldValueInt, "form-id": e.fieldKey + "_" + e.field.name, "field-props": e.fieldProps, "drop-down-lists": e.fieldGroupDropDownLists }, on: { "values-changed": e.setInputValue, "input-complete": function(i) {
    return e.$emit("input-complete", i);
  }, "fetch-autocomplete": e.subFormFetchAutocomplete }, scopedSlots: e._u([{ key: "label-addition", fn: function({ fieldName: i, groupNames: r }) {
    return [e._t("label-addition", null, { fieldName: i, groupNames: (r || []).concat(e.field.name) })];
  } }, { key: "pre-input-field", fn: function({ fieldName: i, groupNames: r }) {
    return [e._t("pre-input-field", null, { fieldName: i, groupNames: (r || []).concat(e.field.name) })];
  } }, { key: "input-field-addition-before", fn: function({ fieldName: i, groupNames: r }) {
    return [e._t("input-field-addition-before", null, { fieldName: i, groupNames: (r || []).concat(e.field.name) })];
  } }, { key: "input-field-inline-before", fn: function({ fieldName: i, groupNames: r }) {
    return [e._t("input-field-inline-before", null, { fieldName: i, groupNames: (r || []).concat(e.field.name) })];
  } }, { key: "input-field-addition-after", fn: function({ fieldName: i, groupNames: r }) {
    return [e._t("input-field-addition-after", null, { fieldName: i, groupNames: (r || []).concat(e.field.name) })];
  } }, { key: "post-input-field", fn: function({ fieldName: i, groupNames: r }) {
    return [e._t("post-input-field", null, { fieldName: i, groupNames: (r || []).concat(e.field.name) })];
  } }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("remove-icon")];
  }, proxy: !0 }, { key: "below-input", fn: function({ fieldName: i, groupNames: r }) {
    return [e._t("below-input", null, { fieldName: i, groupNames: (r || []).concat(e.field.name) })];
  } }, { key: "drop-down-entry", fn: function({ option: i, fieldName: r, groupNames: o }) {
    return [e._t("drop-down-entry", null, { fieldName: r, groupNames: (o || []).concat(e.field.name), option: i })];
  } }], null, !0) }, "BaseForm", e.fieldGroupParams, !1))], 1)]) : e.fieldType === "boolean" ? [l("BaseToggle", e._b({ staticClass: "base-form-field-creator__toggle", attrs: { name: e.fieldKey, label: e.labelInt, "bind-slot-to-state": e.fieldProps.bindSlotToState || !0 }, on: { clicked: e.emitCompletedInputValues }, model: { value: e.fieldValueInt, callback: function(i) {
    e.fieldValueInt = i;
  }, expression: "fieldValueInt" } }, "BaseToggle", e.fieldProps, !1), [e.formFieldXAttrs.subtext && e.formFieldXAttrs.subtext.value ? l("BaseLink", { attrs: { "identifier-property-value": e.formFieldXAttrs.subtext.source || "", url: e.formFieldXAttrs.subtext.url || "", value: e.formFieldXAttrs.subtext.value } }) : e._e()], 1)] : e._e()], 2);
}, p = [], m = /* @__PURE__ */ s(
  f,
  u,
  p,
  !1,
  null,
  "0730e003",
  null,
  null
);
const g = m.exports;
export {
  g as default
};
//# sourceMappingURL=BaseFormFieldCreator.vue.es.js.map
