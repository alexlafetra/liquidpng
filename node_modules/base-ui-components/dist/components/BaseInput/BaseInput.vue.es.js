import d from "vue-click-outside";
import o from "../BaseIcon/BaseIcon.vue.es.js";
import { createId as p } from "../../utils/utils.es.js";
import h from "../../mixins/i18n.es.js";
import "./BaseInput.vue.es2.js";
import c from "../../_virtual/_plugin-vue2_normalizer.es.js";
const m = {
  name: "BaseInput",
  directives: {
    ClickOutside: d
  },
  components: {
    BaseIcon: o,
    BaseLoader: () => import("../BaseLoader/BaseLoader.vue.es.js").then((e) => e.default || e)
  },
  mixins: [h],
  model: {
    prop: "input",
    event: "input"
  },
  props: {
    /**
     * input field settable from outside
     */
    input: {
      type: [String, Number],
      default: ""
    },
    /** label for input field, required for usability purposes, handle
     * showing of label with property `showLabel`
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * defines if input label should be visible
     */
    showLabel: {
      type: Boolean,
      default: !0
    },
    /**
     * if field is occurring more then once - set an `id`
     * **caveat**: in case a custom input is used with the `input` slot it is important to
     * assign the same id to the input element
     */
    id: {
      type: String,
      default: ""
    },
    /**
     * set a placeholder for the input field
     */
    placeholder: {
      type: String,
      default: "Enter Text Here"
    },
    /**
     * mark as required field
     */
    required: {
      type: Boolean,
      default: !1
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * add an error message to be displayed below form field if field is invalid
     */
    errorMessage: {
      type: String,
      default: ""
    },
    /**
     * define if error icon should be shown
     */
    showErrorIcon: {
      type: Boolean,
      default: !0
    },
    /**
     * specify input type
     * @values text, number, password, email, url, search
     *
     */
    fieldType: {
      type: String,
      default: "text",
      validator: (e) => ["text", "number", "password", "email", "url", "search"].includes(e)
    },
    /**
     * specify the id of a linked drop down list
     */
    dropDownListId: {
      type: String,
      default: ""
    },
    /**
     * specify a linked list option (e.g. drop down)
     *   (will be used in `aria-activedescendant` attribute)
     */
    linkedListOption: {
      type: [Number, String],
      default: null
    },
    /**
     * option to hide input field from outside (required for chips input)
     */
    hideInputField: {
      type: Boolean,
      default: !1
    },
    /**
     * set input field in active state from outside
     * the `.sync` modifier can be used on this prop
     */
    isActive: {
      type: Boolean,
      default: null
    },
    /**
     * option to have the border of the input field not displayed
     */
    showInputBorder: {
      type: Boolean,
      default: !0
    },
    /**
     * define if standard form field styling should be
     * used (otherwise no border, no box shadow)
     */
    useFormFieldStyling: {
      type: Boolean,
      default: !0
    },
    /**
     * if `true` a remove icon (or custom icon if slot `remove-icon` is used) will be shown allowing to remove
     * all input at once
     */
    clearable: {
      type: Boolean,
      default: !1
    },
    /**
     * if `true` space is reserved for a loader that can be activated
     * with the `isLoading` prop
     */
    loadable: {
      type: Boolean,
      default: !1
    },
    /**
     * show spinner to indicate that something is loading
     * (for dynamically fetched entries that need to do backend requests)
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * turn off input fade out if it interferes with other styling (e.g. with custom input)
     */
    useFadeOut: {
      type: Boolean,
      default: !0
    },
    /**
     * specify additional input field styling
     */
    inputClass: {
      type: String,
      default: ""
    },
    /**
     * set a language (ISO 639-1)
     */
    language: {
      type: String,
      default: "",
      validator: (e) => !e || e.length === 2
    },
    /**
     * use this prop to deactivate automatic setting of focus as soon as input element
     * becomes active - this might require external handling of focus setting!
     */
    setFocusOnActive: {
      type: Boolean,
      default: !0
    },
    /**
     * set `true` if input field should be disabled
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * set min length of characters
     */
    minLength: {
      type: Number,
      default: null
    },
    /**
     * set max length of characters
     */
    maxLength: {
      type: Number,
      default: null
    },
    /**
     * set number of decimals (fieldType=number)<br>
     * Note: -1 is used for endless decimals
     */
    decimals: {
      type: Number,
      default: null
    },
    /**
     * set decimal separator character, e.g. ',' for german
     */
    decimalSeparator: {
      type: String,
      default: "."
    },
    /**
     * set minimum value to accept
     */
    min: {
      type: Number,
      default: null
    },
    /**
     * set maximum value to accept
     */
    max: {
      type: Number,
      default: null
    },
    /**
     * define validation messages
     * currently just for type number
     */
    validationTexts: {
      type: Object,
      default: () => ({
        min: "Value must be greater than or equal to {value}.",
        max: "Value must be less than or equal to {value}.",
        minLength: "Text must be at least {value} character(s) long.",
        maxLength: "Text cannot be longer than {value} characters."
      }),
      // checking if all necessary properties are part of the provided object
      validator: (e) => ["min", "max", "minLength", "maxLength"].every((t) => Object.keys(e).includes(t))
    },
    /**
     * provide assistive text for screen readers
     * **loaderActive**: if `loadable` is set `true` this text is read
     *  as soon as the loader is appearing (`isLoading` is set true)
     */
    assistiveText: {
      type: Object,
      default: () => ({
        loaderActive: "loading."
      })
    }
  },
  data() {
    return {
      isActiveInt: !1,
      inputInt: "",
      previousInput: "",
      errorMessageInt: "",
      invalidInt: ""
    };
  },
  computed: {
    /**
     * check if an id was provided (to handle label input connection), if not create one
     * @returns {String|string}
     */
    idInt() {
      return this.id || p();
    },
    /**
     * determines if label row should be shown
     * @returns {Boolean|boolean}
     */
    showLabelRow() {
      const e = this.$slots["label-addition"], t = !!e && !!e.length && e.some((n) => {
        var i;
        return n.tag || ((i = n.text) == null ? void 0 : i.trim());
      });
      return this.showLabel || t;
    },
    /**
     * determines if remove icon should be shown
     * @returns {boolean}
     */
    showRemoveIcon() {
      return this.clearable && !!this.inputInt;
    },
    inputListeners() {
      return {
        // add all the listeners from the parent
        ...this.$listeners,
        // for number fields: filter characters except numbers, decimals, negative values, e
        input: (e) => {
          let { value: t } = e.target;
          if (this.errorMessageInt = "", this.invalidInt = !1, this.fieldType === "number") {
            const n = this.decimals ? `\\${this.decimalSeparator}` : "", i = new RegExp(`[^e0-9${n}\\+-]`, "g"), a = this.decimals && this.decimals !== +"-1" ? `{0,${this.decimals}}` : "*", s = this.allowNegativeNumber ? "-?" : "", u = this.decimals && this.decimals !== +"-1" ? "-" : "", r = new RegExp(`^((${s}[0-9]*${n}?([0-9]${a})(e(${u}|\\+)?[0-9]*)?)|-)$`, "g");
            if (t = t.replace(",", this.decimalSeparator), t = t.replace(".", this.decimalSeparator), t = t.replace(i, ""), t = this.removeMultipleChars(t, this.decimalSeparator), t = this.removeMultipleChars(t, "e"), this.inputInt = t, this.decimals && !Number.isNaN(Number(t)) && (t = this.roundDecimals(t), this.inputInt = t), t !== "" && !t.match(r)) {
              this.inputInt = this.previousInput;
              return;
            }
            if (this.min && t && Number(this.stringToFloat(t)) < this.min) {
              this.errorMessageInt = this.validationTexts.min.replace("{value}", this.min.toString()), this.invalidInt = !0;
              return;
            }
            if (this.max && Number(this.stringToFloat(t)) > this.max) {
              this.errorMessageInt = this.validationTexts.max.replace("{value}", this.max.toString()), this.invalidInt = !0;
              return;
            }
            if (Number(this.stringToFloat(t)) === 1 / 0 && (t = 0, this.inputInt = t), this.inputIsNaN(t))
              return;
            this.previousInput = t, t = this.stringToFloat(t);
          }
          if (this.fieldType !== "number") {
            if (this.minLength && t && t.length < this.minLength) {
              this.errorMessageInt = this.validationTexts.minLength.replace("{value}", this.minLength.toString()), this.invalidInt = !0;
              return;
            }
            if (this.maxLength && t.length > this.maxLength) {
              this.errorMessageInt = this.validationTexts.maxLength.replace("{value}", this.maxLength.toString()), this.invalidInt = !0;
              return;
            }
          }
          this.$emit("input", t);
        },
        blur: (e) => {
          const { value: t } = e.target;
          this.fieldType === "number" && (t === "" || Number.isNaN(Number(this.stringToFloat(t))) ? (this.inputInt = "", this.previousInput = "") : (this.inputInt = this.translateFloat(Number(this.stringToFloat(t))), this.previousInput = this.inputInt)), this.$emit("blur", e);
        }
      };
    },
    /**
     * find and store the input element associated with this component in a variable
     */
    inputElement() {
      if (window) {
        if (this.$refs && this.$refs.input)
          return this.$refs.input;
        const e = document.getElementById(this.idInt);
        if (e)
          return e;
        console.warn("BaseInput: you did not assign the same id to the BaseInputComponent and the input element!");
      }
      return null;
    },
    /**
     * determines if a negative number|float is allowed
     * @returns {boolean}
     */
    allowNegativeNumber() {
      return this.min === null || this.min < 0;
    }
  },
  watch: {
    /**
     * watch input prop to sync with internal inputInt variable
     */
    input: {
      handler(e) {
        const t = this.fieldType === "number" ? this.translateFloat(e) : e;
        t !== this.inputInt && (this.inputInt = t, this.previousInput = t, this.triggerInputEvent());
      },
      immediate: !0
    },
    /**
     * if an external input element is used changes in inputInt need to be propagated to
     * parent manually
     * @param {string} val
     */
    inputInt(e) {
      let t = e;
      if (this.fieldType === "number") {
        if (this.inputIsNaN(t))
          return;
        t = this.stringToFloat(t);
      }
      t !== this.input && this.$emit("input", t);
    },
    /**
     * keep externally set active variable and internal active variable in sync
     * @param {boolean} val
     */
    isActive: {
      handler(e) {
        e !== this.isActiveInt && (this.isActiveInt = e);
      },
      immediate: !0
    },
    /**
     * keep externally set active variable and internal active variable in sync
     * @param {boolean} val
     */
    isActiveInt(e) {
      this.inputElement && e && this.setFocusOnActive && this.inputElement.focus(), this.$emit("update:is-active", e);
    },
    /**
     * keep externally set errorMessage variable and internal errorMessage variable in sync
     * @param {string} val
     */
    errorMessage: {
      handler(e) {
        e !== this.errorMessageInt && (this.errorMessageInt = e);
      },
      immediate: !0
    },
    /**
     * keep externally set invalid variable and internal invalid variable in sync
     * @param {boolean} val
     */
    invalid: {
      handler(e) {
        e !== this.invalidInt && (this.invalidInt = e);
      },
      immediate: !0
    },
    /**
     * keep externally set invalid variable and internal invalid variable in sync
     * @param {boolean} val
     */
    invalidInt(e) {
      e !== this.invalid && this.$emit("update:invalid", e);
    }
  },
  mounted() {
    this.max && Number(this.stringToFloat(this.input)) > this.max && (this.inputInt = this.max), this.isActiveInt && this.inputElement && this.inputElement.focus();
  },
  methods: {
    /**
     * in general input field active styling is handled via focusin and
     * clicked-outside, however for special case iOS touch  devices have
     * up and down arrows that do not trigger any event other than blur and will
     * cause the dropdowns of input fields to remain open
     * @param {FocusEvent} event - the native blur event
     */
    onInputBlur(e) {
      e.relatedTarget && e.relatedTarget.tagName === "INPUT" && (!e.relatedTarget.id || e.relatedTarget.id !== e.target.id) && this.setFieldState(!1);
    },
    /**
     * special event triggered when tab was used on clear input button
     * @param {KeyboardEvent} event
     */
    blurInput(e) {
      this.setFieldState(!1), this.$emit("keydown", e);
    },
    /**
     * function triggered if click event or focus event happened inside the
     * 'input-frame' element
     * @param {FocusEvent|MouseEvent} event the native event
     */
    clickedInside(e) {
      this.disabled || (this.setFieldState(!0), this.$emit("click-input-field", e));
    },
    /**
     * triggered when click happened outside of 'input-frame' element
     * @param {Event} event
     */
    clickedOutsideInput(e) {
      this.setFieldState(!1), this.$emit("clicked-outside", e);
    },
    /**
     * triggered on clear input button click and removes input and returns focus
     * to input field
     */
    removeInput() {
      this.inputInt = "", this.inputElement && this.inputElement.focus();
    },
    /**
     * set the active input field state (used for visual active indication)
     * @param {boolean} val - the value to be set
     */
    setFieldState(e) {
      this.isActiveInt = e;
    },
    handleInputTab(e) {
      (!this.showRemoveIcon || e.shiftKey) && this.setFieldState(!1);
    },
    /**
     * replace dot with decimalSeparator
     *
     * @param {number} value
     * @returns {string}
     */
    translateFloat(e) {
      return e == null ? "" : e.toString().replace(".", this.decimalSeparator);
    },
    /**
     * replace decimalSeparator with dot
     *
     * @param {string} value
     * @returns {number}
     */
    stringToFloat(e) {
      return e ? Number(e.toString().replace(this.decimalSeparator, ".")) : "";
    },
    /**
     * check if input would not be a valid number
     *
     * @param {string} value
     * @returns {boolean}
     */
    inputIsNaN(e) {
      const t = this.decimalSeparator, n = new RegExp(`^(-0|-?(([0-9]*\\${t}([0]*)?)?|(\\${t}([0-9]*)?)?))$`, "g");
      return e.length && (e.toString().match(n) || Number.isNaN(this.stringToFloat(e)));
    },
    /**
     * trigger input event
     * e.g. to validate input changes from parent
     */
    triggerInputEvent() {
      setTimeout(() => {
        this.inputElement && (this.inputElement.value = this.inputInt, this.inputElement.dispatchEvent(new Event("input")));
      }, 0);
    },
    /**
     * crop and round decimals if needed
     * eg allowed decimals: 2 <br>
     *   * 12.5e-2 => 0.125 => 0.12
     *   * 0.01e-1 => 0.001 => 0
     * @param value
     * @returns {string}
     */
    roundDecimals(e) {
      const t = e.split(this.decimalSeparator);
      return t[1] && t[1].length > this.decimals ? this.translateFloat(Number(Number(e).toFixed(this.decimals))) : e;
    },
    /**
     * remove multiple given character except first occurrence
     * @param {String} value
     * @param {String} char
     * @returns {string}
     */
    removeMultipleChars(e, t) {
      const n = new RegExp(`\\${t}`, "g");
      return e.replace(n, (i, a, s) => s.indexOf(i) === a ? i : "");
    }
  }
};
var f = function() {
  var t = this, n = t._self._c;
  return n("div", { staticClass: "base-input" }, [n("div", { class: ["base-input__label-row", { hide: !t.showLabelRow }], on: { click: function(i) {
    i.stopPropagation();
  } } }, [n("label", { class: ["base-input__label", { hide: !t.showLabel }], attrs: { for: t.idInt } }, [t._v(" " + t._s(t.getLangLabel(t.label)) + " ")]), n("div", { staticClass: "base-input__label-spacer" }), t._t("label-addition")], 2), n("div", { directives: [{ name: "click-outside", rawName: "v-click-outside", value: t.clickedOutsideInput, expression: "clickedOutsideInput" }], class: [
    "base-input__input-frame",
    { "base-input__input-frame__border": t.showInputBorder },
    { "base-input__input-frame__disabled": t.disabled },
    { "base-input__input-frame__invalid": t.invalidInt }
  ], on: { focusin: t.clickedInside, click: t.clickedInside } }, [n("div", { class: [
    "base-input__input-container",
    {
      "base-input__input-container__is-active": t.isActiveInt && t.useFormFieldStyling
    }
  ] }, [t._t("pre-input-field"), n("div", { class: [
    "base-input__input-line-container",
    { "base-input__input-line-container__wrap": !t.hideInputField }
  ] }, [t._t("input-field-addition-before"), n("div", { staticClass: "base-input__input-line" }, [t._t("input-field-inline-before"), n("div", { class: [
    "base-input__input-wrapper",
    {
      "base-input__input-wrapper__fade-out": t.useFadeOut && !t.isActiveInt && !t.hideInputField
    }
  ] }, [t._t("input", function() {
    return [(t.fieldType === "number" ? "text" : t.fieldType) === "checkbox" ? n("input", t._g({ directives: [{ name: "model", rawName: "v-model", value: t.inputInt, expression: "inputInt" }], ref: "input", class: [
      t.inputClass,
      "base-input__input",
      { "base-input__input__hidden": t.hideInputField }
    ], attrs: { id: t.idInt, placeholder: t.placeholder, list: t.dropDownListId || !1, disabled: t.disabled, "aria-disabled": t.disabled.toString(), "aria-activedescendant": t.linkedListOption, "aria-describedby": t.idInt, "aria-required": t.required.toString(), required: t.required, "aria-invalid": t.invalidInt.toString(), minlength: t.minLength, maxlength: t.maxLength, inputmode: t.fieldType === "number" && t.allowNegativeNumber ? "decimal" : null, enterkeyhint: "done", autocomplete: "off", type: "checkbox" }, domProps: { checked: Array.isArray(t.inputInt) ? t._i(t.inputInt, null) > -1 : t.inputInt }, on: { keydown: function(i) {
      return !i.type.indexOf("key") && t._k(i.keyCode, "tab", 9, i.key, "Tab") ? null : t.handleInputTab.apply(null, arguments);
    }, blur: t.onInputBlur, change: function(i) {
      var a = t.inputInt, s = i.target, u = !!s.checked;
      if (Array.isArray(a)) {
        var r = null, l = t._i(a, r);
        s.checked ? l < 0 && (t.inputInt = a.concat([r])) : l > -1 && (t.inputInt = a.slice(0, l).concat(a.slice(l + 1)));
      } else
        t.inputInt = u;
    } } }, t.inputListeners)) : (t.fieldType === "number" ? "text" : t.fieldType) === "radio" ? n("input", t._g({ directives: [{ name: "model", rawName: "v-model", value: t.inputInt, expression: "inputInt" }], ref: "input", class: [
      t.inputClass,
      "base-input__input",
      { "base-input__input__hidden": t.hideInputField }
    ], attrs: { id: t.idInt, placeholder: t.placeholder, list: t.dropDownListId || !1, disabled: t.disabled, "aria-disabled": t.disabled.toString(), "aria-activedescendant": t.linkedListOption, "aria-describedby": t.idInt, "aria-required": t.required.toString(), required: t.required, "aria-invalid": t.invalidInt.toString(), minlength: t.minLength, maxlength: t.maxLength, inputmode: t.fieldType === "number" && t.allowNegativeNumber ? "decimal" : null, enterkeyhint: "done", autocomplete: "off", type: "radio" }, domProps: { checked: t._q(t.inputInt, null) }, on: { keydown: function(i) {
      return !i.type.indexOf("key") && t._k(i.keyCode, "tab", 9, i.key, "Tab") ? null : t.handleInputTab.apply(null, arguments);
    }, blur: t.onInputBlur, change: function(i) {
      t.inputInt = null;
    } } }, t.inputListeners)) : n("input", t._g({ directives: [{ name: "model", rawName: "v-model", value: t.inputInt, expression: "inputInt" }], ref: "input", class: [
      t.inputClass,
      "base-input__input",
      { "base-input__input__hidden": t.hideInputField }
    ], attrs: { id: t.idInt, placeholder: t.placeholder, list: t.dropDownListId || !1, disabled: t.disabled, "aria-disabled": t.disabled.toString(), "aria-activedescendant": t.linkedListOption, "aria-describedby": t.idInt, "aria-required": t.required.toString(), required: t.required, "aria-invalid": t.invalidInt.toString(), minlength: t.minLength, maxlength: t.maxLength, inputmode: t.fieldType === "number" && t.allowNegativeNumber ? "decimal" : null, enterkeyhint: "done", autocomplete: "off", type: t.fieldType === "number" ? "text" : t.fieldType }, domProps: { value: t.inputInt }, on: { keydown: function(i) {
      return !i.type.indexOf("key") && t._k(i.keyCode, "tab", 9, i.key, "Tab") ? null : t.handleInputTab.apply(null, arguments);
    }, blur: t.onInputBlur, input: function(i) {
      i.target.composing || (t.inputInt = i.target.value);
    } } }, t.inputListeners))];
  }, null, {
    id: t.idInt
  })], 2), t.showRemoveIcon ? n("button", { staticClass: "base-input__remove-icon-wrapper", on: { keydown: function(i) {
    return !i.type.indexOf("key") && t._k(i.keyCode, "tab", 9, i.key, "Tab") ? null : t.blurInput.apply(null, arguments);
  }, click: function(i) {
    return i.stopPropagation(), t.removeInput.apply(null, arguments);
  } } }, [t._t("remove-icon", function() {
    return [n("BaseIcon", { staticClass: "base-input__remove-icon", attrs: { name: "remove", title: "Clear input" } })];
  })], 2) : t._e(), t.loadable ? n("div", { staticClass: "base-input__loader" }, [n("BaseLoader", { attrs: { hide: !t.isLoading, "text-on-loader-show": t.assistiveText.loaderActive } })], 1) : t._e(), t._t("input-field-addition-after")], 2)], 2), t.showErrorIcon && t.invalidInt ? n("div", { staticClass: "base-input__error-icon-wrapper" }, [t._t("error-icon", function() {
    return [n("BaseIcon", { staticClass: "base-input__error-icon", attrs: { name: "attention" } })];
  })], 2) : t._e(), t._t("post-input-field")], 2)]), n("div", [t._t("below-input")], 2), t.invalidInt && t.errorMessageInt ? n("div", { staticClass: "base-input__invalid-message" }, [t._v(" " + t._s(t.getLangLabel(t.errorMessageInt)) + " ")]) : t._e()]);
}, b = [], g = /* @__PURE__ */ c(
  m,
  f,
  b,
  !1,
  null,
  "bc4b71b8",
  null,
  null
);
const k = g.exports;
export {
  k as default
};
//# sourceMappingURL=BaseInput.vue.es.js.map
