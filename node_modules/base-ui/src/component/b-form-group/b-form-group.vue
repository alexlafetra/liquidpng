<template>
    <div
        :class="{
            'b-form-group-block': block,
            'b-form-group-label-horizontal': labelHorizontal,
            'has-error':hasError
        }"
        class="b-form-group form-group"
    >
        <div :class="labelWrapClass" class="b-form-group-label-wrap">
            <slot name="labelLeft"></slot>
            <label>
                {{ currentLabel }}
                <span v-if="hasStar||required" class="required-star">*</span>
            </label>
            <slot name="labelRight"></slot>
        </div>

        <div
            ref="warp"
            :class="inputWrapClass"
            :style="`--item-width:${itemWidth}`"
            :valid-message="message"
            class="b-form-group-input-wrap">
            <slot></slot>
        </div>
    </div>
</template>

<script>
import _ from 'underscore';

import {getText} from '../../util/i18n';
import {isBoolean, isString} from '../../util/check';
import {filterEmpty, getSlotInstance, evalProp, checkNotNull} from '../../util/object-util';

export default {
    name: 'BFormGroup',

    props: {
        label: {
            type: String,
            default: ''
        },
        labelKey: {
            type: String,
            default: ''
        },
        block: {
            type: Boolean,
            default: false
        },

        labelHorizontal: {
            type: Boolean,
            default: false
        },

        labelWrapClass: {
            type: [String, Array, Object],
            default: ''
        },

        inputWrapClass: {
            type: [String, Array, Object],
            default: ''
        },

        hasStar: {
            type: Boolean,
            default: false
        },

        decorator: {
            type: Object,
            default: () => ({})
        },

        trigger: {
            type: String,
            default: 'change'
        }
    },
    data() {
        return {
            hasError: false,
            itemWidth: '256px',
            message: '',
            childInstance: null,
            elm: null
        };
    },
    computed: {
        currentLabel() {
            const {label, labelKey} = this;
            return label || getText({vm: this, key: labelKey, defaultText: labelKey});
        },

        needValid() {
            const {decorator: {def} = {}} = this;
            return !!def?.rules;
        },
        needSingleValid() {
            const {decorator: {def} = {}} = this;
            const {singleValid = true} = def || {};
            return singleValid;
        },

        required() {
            const {decorator: {def, record} = {}} = this;
            const required = def?.rules?.required;
            return evalProp(required, record);
        },
        field() {
            const {decorator: {def} = {}} = this;
            return def?.field;
        }
    },
    watch: {
        'decorator.def': function (newValue, oldValue) {
            if (!_.isEqual(newValue, oldValue)) {
                this.offEvents();
                this.resetValid();
                this.$nextTick(() => {
                    this.addEvents();
                });
            }
        }
    },
    mounted() {
        this.addEvents();
        const {width} = this.$refs.warp.getBoundingClientRect();
        this.itemWidth = `${width}px`;
    },

    methods: {
        offEvents() {
            const {childInstance, elm, trigger} = this;
            if (childInstance) childInstance.$off(trigger, this.nextTickValid);
            if (elm) elm.removeEventListener(trigger, this.nextTickValid);
        },
        addEvents() {
            const {trigger, needValid, $scopedSlots: {default: defaultslot}} = this;
            if (!defaultslot) return;
            const children = filterEmpty(defaultslot());
            if (!children[0]) return;
            const childInstance = getSlotInstance(children[0]);
            this.childInstance = childInstance;
            if (needValid) {
                if (childInstance) {
                    childInstance.$on(trigger, this.nextTickValid);
                } else {
                    const {elm} = children[0];
                    this.elm = elm;
                    elm.addEventListener(trigger, this.nextTickValid);
                }
            }
        },

        nextTickValid() {
            const {needSingleValid} = this;
            this.$nextTick(() => {
                needSingleValid ? this.valid() : this.resetValid();// eslint-disable-line
            });
        },

        resetValid() {
            this.message = '';
            this.hasError = false;
        },

        valid() {
            if (!this.decorator) return;
            const {decorator: {def, record, value} = {}} = this;
            const {
                field = '',
                labelKey = '',
                label = labelKey && getText({vm: this, key: labelKey, defaultText: labelKey}),
                rules: {
                    required = false,
                    selectable = false,
                    name = label,
                    messageKey = '',
                    message = messageKey && getText({vm: this, key: messageKey, defaultText: messageKey})
                } = {}
            } = def || {};

            const nameString = evalProp(name);
            const messageString = evalProp(message);

            // check required
            const isRequired = evalProp(required, record);
            if (isRequired && !checkNotNull(value)) {
                const selectString = labelKey
                    ? getText({vm: this, key: 'requireSelect', defaultText: 'requireSelect'}) : '请选择';
                const inputString = labelKey
                    ? getText({vm: this, key: 'requireInput', defaultText: 'requireInput'}) : '请输入';
                this.message = messageString || `${selectable ? selectString : inputString} ${nameString}`;
                this.hasError = true;
                return !this.hasError;// eslint-disable-line
            }

            // check customized rule
            const validate = def?.rules?.validate;
            if (validate) {
                const validateRes
                    = evalProp(validate, {value, field, isRequired, record, def, bf: this.$parent, ctx: this});
                if (isBoolean(validateRes) && !validateRes) {
                    this.message = messageString;
                    this.hasError = true;
                    return !this.hasError;// eslint-disable-line

                }
                if (isString(validateRes)) {
                    this.message = validateRes;
                    this.hasError = true;
                    return !this.hasError;// eslint-disable-line

                }
            }

            this.hasError = false;
            return !this.hasError;// eslint-disable-line

        }

    }
};
</script>
