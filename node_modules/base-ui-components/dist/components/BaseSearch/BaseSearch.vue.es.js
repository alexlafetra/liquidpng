import { createId as a } from "../../utils/utils.es.js";
import { useAnnouncer as r } from "../../composables/useAnnouncer.es.js";
import { ref as l, watch as p } from "vue";
import "./BaseSearch.vue.es2.js";
import "./BaseSearch.vue.es3.js";
import d from "../../_virtual/_plugin-vue2_normalizer.es.js";
const u = {
  name: "BaseSearch",
  components: {
    BaseIcon: () => import("../BaseIcon/BaseIcon.vue.es.js").then((t) => t.default || t),
    BaseChipsInputField: () => import("../BaseChipsInputField/BaseChipsInputField.vue.es.js").then((t) => t.default || t),
    BaseInput: () => import("../BaseInput/BaseInput.vue.es.js").then((t) => t.default || t),
    BaseDateInput: () => import("../BaseDateInput/BaseDateInput.vue.es.js").then((t) => t.default || t)
  },
  model: {
    prop: "input",
    event: "input"
  },
  props: {
    /**
     * set input value from outside
     *   for type `daterange` this needs to be an object with
     *   `date_from` and `date_to` properties!
     */
    input: {
      type: [String, Object],
      default: ""
    },
    /**
     * if input type is `chips` this is the prop to
     * pass selected options (chips).
     *  you may use the `.sync` modifier on this prop
     */
    selectedChips: {
      type: Array,
      default: () => []
    },
    /**
     * placeholder to show for input; either just a string or an object with
     * different text for each search type (`text`, `chips`, `date`)
     */
    placeholder: {
      type: [String, Object],
      default: "Search your works and events"
    },
    /**
     * label connected with input (will not be visible but for usability!)
     */
    label: {
      type: String,
      default: "Search"
    },
    /**
     * define if the magnifier glass (in front of input field) should be shown
     */
    showPreInputIcon: {
      type: Boolean,
      default: !0
    },
    /**
     * specify the id of a linked drop down list
     */
    dropDownListId: {
      type: String,
      default: ""
    },
    /**
     * specify a field id for identification of the input field
     * if none is specified an internal id will be assigned
     */
    id: {
      type: String,
      default: ""
    },
    /**
     * specify the type of input field
     * @values text, chips, controlled, date, daterange, chipssingle
     */
    type: {
      type: String,
      default: "text",
      validator: (t) => ["text", "chips", "chipssingle", "controlled", "date", "daterange"].includes(t)
    },
    /**
     * specify a linked list option (e.g. drop down)
     *   (will be used in `aria-activedescendant` attribute)
     */
    linkedListOption: {
      type: [Number, String],
      default: null
    },
    /**
     * if `true` space is reserved for a loader that can be activated
     * with the 'isLoading' prop
     */
    loadable: {
      type: Boolean,
      default: !1
    },
    /**
     * is loading indicator - showing loader if `true`
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * set the language (ISO 639-1)
     */
    language: {
      type: String,
      default: "en",
      validator: (t) => !t || t.length === 2
    },
    /**
     * specify the object property that should be used as identifier (only needed
     * for type `chips`
     */
    identifierPropertyName: {
      type: String,
      default: "id"
    },
    /**
     * specify the object property that should be used as value to be displayed (only needed
     * for type `chips`
     */
    labelPropertyName: {
      type: String,
      default: "label"
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field.
     * for an example see [BaseInput](BaseInput)
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * define if error icon should be shown
     * for an example see [BaseInput](BaseInput)
     */
    showErrorIcon: {
      type: Boolean,
      default: !0
    },
    /**
     * if `true` a remove icon will be shown allowing to remove
     * all input at once.
     * for an example see [BaseInput](BaseInput)
     */
    clearable: {
      type: Boolean,
      default: !0
    },
    /**
     * set active state from outside
     */
    isActive: {
      type: Boolean,
      default: !1
    },
    /**
     * use this prop to deactivate automatic setting of focus as soon as input element
     * becomes active - this might require external handling of focus setting!
     */
    setFocusOnActive: {
      type: Boolean,
      default: !0
    },
    /**
     * this prop gives the option to add assistive text for screen readers
     * properties:
     *
     * **selectedOption**: text read when a selected option is focused (currently only
     *  working for type chips)
     * **loaderActive**: text that is announced when results are being fetched (prop
     *  `isLoading` is set `true`)
     * **results**: provide text that should be announced when the search has
     *  yielded results (or not).
     *
     *  Caveat: `results` has a watcher attached to trigger the
     *    announcement so make sure the property values are reset after filling them
     *    by using update:assistive-text or resetting it manually (after a timeout)
     */
    assistiveText: {
      type: Object,
      default: () => ({
        selectedOption: "",
        loaderActive: "loading.",
        results: ""
      })
    },
    /**
     * use this prop to set a delay in ms before date input calender is displayed
     */
    dateFieldDelay: {
      type: Number,
      default: 0
    }
  },
  emits: ["input", "update:selected-chips", "update:is-active", "update:assistive-text"],
  setup(t, { emit: e }) {
    const n = l(null), { announcement: i } = r(n);
    return p(i, (s) => {
      s !== t.assistiveText.results && e("update:assistive-text", {
        ...t.assistiveText,
        results: s
      });
    }), {
      search: n,
      // need to just export the announcement text because setting it in setup function
      // did not work in nuxt (respectively the watcher on assistiveText did not work)
      announcement: i
    };
  },
  data() {
    return {
      /**
       * internal handling of the input active state
       * @type {boolean}
       */
      isActiveInt: !1,
      /**
       * internal handling of text input --> for 'chips' and 'text'
       * (separated from dateInputInt to preserve the input when switching type)
       * @type {string}
       */
      textInputInt: "",
      /**
       * internal handling of date input (separated from textInputInt to preserve
       * the input when switching type)
       * @type {string|Object}
       */
      dateInputInt: "",
      /**
       * internal handling of selected chips for type 'chips'
       * @type {Array}
       */
      selectedChipsInt: []
    };
  },
  computed: {
    /**
     * compute and import only the component necessary for the respective type selected
     * @returns {null|(function(): Promise<HTMLElement>)|string}
     */
    inputComponent() {
      return this.type === "text" ? "BaseInput" : this.isFieldTypeChips ? "BaseChipsInputField" : this.type === "date" || this.type === "daterange" ? "BaseDateInput" : null;
    },
    /**
     * compute the inputInt used for BaseInput v-model
     * this can either be a string or an object - also this is used to
     * convert dates between 'daterange' and 'date'
     */
    inputInt: {
      /**
       * set either textInputInt or dateInputInt depending on the type
       * @param {string|{date_to: string, date_from: string}} val - depending on the type
       * this is a date string, text string or an Object for 'daterange' with the following
       * properties:
       * @property {string} val.date_from
       * @property {string} val.date_to
       */
      set(t) {
        this.type === "date" ? (this.dateInputInt = t, this.$emit("input", this.dateInputInt)) : this.type === "daterange" ? (this.dateInputInt = { ...t }, this.$emit("input", this.dateInputInt)) : (this.textInputInt = t, this.$emit("input", this.textInputInt));
      },
      /**
       * get inputInt according to search type
       * @returns {string|{date_to: string, date_from: string}}
       */
      get() {
        return this.type === "date" ? this.dateInputInt.date_from || this.dateInputInt : this.type === "daterange" ? typeof this.dateInputInt == "object" ? this.dateInputInt : {
          date_from: this.dateInputInt,
          date_to: ""
        } : this.textInputInt;
      }
    },
    /**
     * to easily access the type needed for BaseDateInput in case type
     * is 'date' or 'daterange'
     * @returns {string|boolean}
     */
    dateFieldType() {
      return this.type === "date" ? "single" : this.type === "daterange" ? "daterange" : !1;
    },
    /**
     * compute adaptions necessary for BaseDateInput since this component currently
     * only has 3 languages to choose from
     * @returns {string}
     */
    languageInt() {
      return this.type === "date" || this.type === "daterange" ? ["de", "en", "fr"].includes(this.language) ? this.language : "en" : this.language;
    },
    /**
     * determine if type is 'chips'
     * @returns {boolean}
     */
    isFieldTypeChips() {
      return this.type.includes("chips") || this.type === "controlled";
    },
    /**
     * internally used id - eiter provided by props or created internally with utils function
     * @returns {string}
     */
    idInt() {
      return this.id || a();
    },
    placeholderInt() {
      return typeof this.placeholder == "string" ? this.placeholder : this.type.includes("date") ? this.placeholder.date : this.type === "controlled" || this.type === "chipssingle" ? this.placeholder.chips : this.placeholder[this.type];
    }
  },
  watch: {
    /**
     * watch input prop to sync with inputInt
     * @param {string|{date_from: string, date_to: string}} val
     */
    input: {
      handler(t) {
        t ? t !== this.inputInt && (this.inputInt = t) : (this.textInputInt = "", this.dateInputInt = this.type === "daterange" ? {
          date_from: "",
          date_to: ""
        } : "");
      },
      immediate: !0
    },
    /**
     * watch inputInt to sync with parent input
     * @param {string|{date_from: string, date_to: string}} val
     */
    inputInt(t) {
      t !== this.input && this.$emit("input", t);
    },
    /**
     * watch selectedChips prop to sync with selectedChipsInt
     * @param {Object[]} val
     */
    selectedChips: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.selectedChipsInt) && (this.selectedChipsInt = [...t]);
      },
      immediate: !0
    },
    /**
     * watch selectedChipsInt to sync with selectedChips prop provided by parent
     * @param {Object[]} val
     */
    selectedChipsInt(t) {
      JSON.stringify(t) !== JSON.stringify(this.selectedChips) && this.$emit("update:selected-chips", t);
    },
    /**
     * sync internal active state with parent
     */
    isActive: {
      handler(t) {
        t !== this.isActiveInt && (this.isActiveInt = t);
      },
      immediate: !0
    },
    isActiveInt(t) {
      t !== this.isActive && this.$emit("update:is-active", t);
    },
    /**
     * inserting this component in Nuxt only options API watcher on prop
     * is working (in setup this is not working)
     */
    assistiveText: {
      handler(t) {
        this.announcement = t.results;
      },
      deep: !0
    }
  },
  methods: {
    onEnter(t) {
      window.visualViewport.height < window.innerHeight && t.target.id === this.idInt && t.target.blur();
    }
  }
};
var o = function() {
  var e = this, n = e._self._c;
  return n("form", { ref: "search", staticClass: "base-search", attrs: { action: ".", role: "search" }, on: { submit: function(i) {
    i.preventDefault();
  }, keydown: function(i) {
    if (!i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter"))
      return null;
    i.preventDefault();
  } } }, [n(e.inputComponent, e._g({ tag: "component", staticClass: "base-search__input", attrs: { id: e.idInt, "selected-list": e.selectedChipsInt, "is-active": e.isActiveInt, type: e.dateFieldType, "show-label": !1, "use-form-field-styling": !1, "show-input-border": !1, label: e.label, placeholder: e.placeholderInt, "linked-list-option": e.linkedListOption, "drop-down-list-id": e.dropDownListId || (!1).toString(), "is-loading": e.isLoading, clearable: e.clearable, invalid: e.invalid, "show-error-icon": e.showErrorIcon, language: e.languageInt, "allow-unknown-entries": e.type === "chips", loadable: e.loadable, "chips-editable": e.type === "chips", "label-property-name": e.isFieldTypeChips ? e.labelPropertyName : !1, "identifier-property-name": e.isFieldTypeChips ? e.identifierPropertyName : !1, "set-focus-on-active": e.setFocusOnActive, "add-selected-entry-directly": !0, "assistive-text": e.type.includes("date") ? void 0 : {
    selectedOption: e.assistiveText.selectedOption,
    loaderActive: e.assistiveText.loaderActive
  }, "is-active-delay": e.dateFieldDelay, "allow-multiple-entries": e.isFieldTypeChips ? e.type !== "chipssingle" : !1, "chips-removable": e.type !== "chipssingle", "input-class": "base-search__input-field", "field-type": "search", enterkeyhint: "search" }, on: { "update:selectedList": function(i) {
    e.selectedChipsInt = i;
  }, "update:selected-list": function(i) {
    e.selectedChipsInt = i;
  }, "update:isActive": function(i) {
    e.isActiveInt = i;
  }, "update:is-active": function(i) {
    e.isActiveInt = i;
  }, keydown: function(i) {
    return !i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : e.onEnter.apply(null, arguments);
  } }, scopedSlots: e._u([{ key: "pre-input-field", fn: function() {
    return [e._t("pre-input-field")];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [e._t("input-field-addition-before")];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [n("div", { class: [e.dateFieldType && e.showPreInputIcon ? "base-search__spacing-date" : "base-search__spacing"] }), e._t("input-field-inline-before", function() {
      return [e.showPreInputIcon ? n("BaseIcon", { class: [
        "base-search__magnifier-icon",
        { "base-search__magnifier-icon__date": !!e.dateFieldType },
        { "base-search__magnifier-icon__active": e.isActiveInt }
      ], attrs: { name: "magnifier" } }) : e._e()];
    })];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [e._t("input-field-addition-after")];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [e._t("post-input-field"), n("div", { class: { "base-search__spacing": e.dateFieldType } })];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("remove-icon")];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e._t("below-input")];
  }, proxy: !0 }], null, !0), model: { value: e.inputInt, callback: function(i) {
    e.inputInt = i;
  }, expression: "inputInt" } }, e.$listeners))], 1);
}, c = [], f = /* @__PURE__ */ d(
  u,
  o,
  c,
  !1,
  null,
  "341bd9ee",
  null,
  null
);
const b = f.exports;
export {
  b as default
};
//# sourceMappingURL=BaseSearch.vue.es.js.map
