import o from "../../directives/cleanDomNodes.es.js";
import r from "../../directives/InsertTextAsHtml.es.js";
import "./BaseLink.vue.es2.js";
import a from "../../_virtual/_plugin-vue2_normalizer.es.js";
const n = {
  name: "BaseLink",
  components: {
    BaseIcon: () => import("../BaseIcon/BaseIcon.vue.es.js").then((e) => e.default || e),
    BaseTooltipBox: () => import("../BaseTooltipBox/BaseTooltipBox.vue.es.js").then((e) => e.default || e),
    BaseLoader: () => import("../BaseLoader/BaseLoader.vue.es.js").then((e) => e.default || e)
  },
  directives: {
    cleanDomNodes: o,
    InsertTextAsHtml: r
  },
  props: {
    /**
     * specify a query parameter name for type `chip` links
     */
    chipQueryName: {
      type: String,
      default: "chip-link"
    },
    /**
     * specify external link target
     * @values _blank, _self
     */
    externalLinkTarget: {
      type: String,
      default: "_blank",
      validator: (e) => e === "_blank" || e === "_self"
    },
    /**
     * specify the object property that should be used as identifier
     */
    identifierPropertyName: {
      type: String,
      default: "source"
    },
    /**
     * specify the internal identifier to route to
     */
    identifierPropertyValue: {
      type: [Number, String],
      default: ""
    },
    /**
     * specify an internal path to link, only for type chip links
     */
    path: {
      type: String,
      default: ""
    },
    /**
     * specify how a link element should be rendered
     * this needs to be a valid vue link component (e.g. `RouterLink`, `NuxtLink`) and vue-router is necessary
     */
    renderLinkAs: {
      type: String,
      default: "RouterLink"
    },
    /**
     * add a space " " after an element
     * useful for link-type tooltip in lists
     */
    spaceAfter: {
      type: Boolean,
      default: !1
    },
    /**
     * specify texts for the title tag depending on a link type (especially helpful to provide language-specific text)
     * this needs to be an object with the following properties
     * (if you don't want to display any specific text, leave an empty string):
     *
     *     **chip**: Text is shown on hover of a chip link and gets merged with the type and value attributes.
     *     **tooltip**: Text is shown on hover of a tooltip link.
     *     **type**: Text for a single chip type.
     *       This needs to be an object containing properties matching the different chip types.
     */
    titleText: {
      type: Object,
      default: () => ({
        chip: "Open {type} {value} in search",
        tooltip: "Show more information",
        type: {
          artists: "artist",
          keywords: "keyword"
        }
      }),
      // checking if all necessary properties are part of the provided object
      validator: (e) => ["chip", "tooltip", "type"].every((t) => Object.keys(e).includes(t))
    },
    /**
     * specify tooltip content
     * Prop must be either set true or an Object[] to render a type tooltip link.
     * **Object[]**:
     *   - `[{ label: 'label', value: 'value', altTitle?: 'altTitle',  url: '#' }]` to render a content list
     *   - any other structure in combination with the slot `#tooltip`
     * **Boolean**: use the slot `#tooltip` to customize the content
     */
    tooltip: {
      type: [Boolean, Array],
      default: !1
    },
    /**
     * async tooltip content, e.g. source, id where to fetch data from
     * if set, event `@tooltip-clicked` with this object will be emitted
     */
    tooltipAsync: {
      type: Array,
      default: () => []
    },
    /**
     * additional tooltip styles
     * **caveat**: properties `top`, `left`, `right` will be overwritten due position calculation
     */
    tooltipStyles: {
      type: Object,
      default: () => ({})
    },
    /**
     * specify how the tooltipBox component is rendered on mobile resolutions
     *
     * *box*: component is rendered directly at the info icon
     * *modal*: component is rendered as a modal popup
     * *fullscreen*: component is rendered as ap popup with max height and width
     */
    tooltipTypeOnMobile: {
      type: String,
      default: "box",
      validator: (e) => ["box", "fullscreen", "modal"].includes(e)
    },
    /**
     * specify a threshold value in px for the [BaseTooltipBox](BaseTooltipBox) top position calculation
     *
     * Note: The value can also be set globally with the CSS variable `--base-tooltip-box-threshold-top`.
     *       The property will be overwritten by the CSS variable.
     */
    tooltipThresholdTop: {
      type: Number,
      default: 0
    },
    /**
     * used in combination with property `identifierPropertyValue` to render a type `chip` element.
     * `type` identifies a source type for chip click-event e.g.: keyword | skill | object
     */
    type: {
      type: String,
      default: ""
    },
    /**
     * external url to link to
     * supported protocols: `http://`, `https://`, `mailto:`, `tel:`
     */
    url: {
      type: String,
      default: ""
    },
    /**
     * value of the entry
     */
    value: {
      type: String,
      default: ""
    },
    /**
     *  use this property to set the title attribute
     *  also for link types other than `chip` and `tooltip`
     *
     * if `interpretTextAsHtml` is set `true` for type `chip` and `tootlip`
     *  add a html-free version of `value` here to be used for the `title`
     *  attribute and with assistive technologies
     */
    altTitle: {
      type: String,
      default: ""
    },
    /**
     * set additional attributes directly on the link element,
     *  this can be HTML link element native attributes or framework
     *  specific props (e.g. `aria-current-value` to set the aria-current
     *  attribute, for more possibilities check out the
     *  [Vue-Router documentation](https://v3.router.vuejs.org/api/)
     */
    additionalAttributes: {
      type: Object,
      default: () => ({})
    },
    /**
     * set true to render link `value` as html
     *
     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use
     *    this prop on trusted content and never on user-provided content.
     */
    interpretTextAsHtml: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      isLoading: !1,
      scrollResizeTimeout: null,
      showTooltip: !1
    };
  },
  computed: {
    altTitleInt() {
      return this.altTitle || this.value;
    },
    /**
     * object added as value to `[chipQueryName]` query param when a chip is clicked
     * @returns {Object}
     */
    chipObj() {
      const e = {};
      return e[this.identifierPropertyName] = this.identifierPropertyValue, e.type = this.type, e.value = this.altTitleInt, e;
    },
    /**
     * check if an url is set and includes a protocol
     * e.g. 'http://', 'https://', 'mailto:' or 'tel:'
     *
     * @returns {boolean}
     */
    hasValidUrl() {
      return !!(this.url && (this.url.match(/^([a-z][a-z0-9+\-.]*:\/\/)/) || this.url.match(/^mailto:/) || this.url.match(/^tel:/)));
    },
    /**
     * check if the link is type `chip`
     * @returns {boolean}
     */
    isChip() {
      return !!(this.identifierPropertyValue && this.type);
    },
    /**
     * check if the link is type `external`
     * @returns {boolean}
     */
    isExternal() {
      return this.hasValidUrl;
    },
    /**
     * check if the link is type `internal`
     * @returns {boolean}
     */
    isInternal() {
      return !!(this.identifierPropertyValue && !this.type);
    },
    /**
     * check if vue router is available
     * @returns {boolean}
     */
    isRouterAvailable() {
      return !!this.$router;
    },
    /**
     * check if the link is type `tooltip`
     * @returns {boolean}
     */
    isTooltip() {
      return !!(this.tooltip || this.tooltip.length || this.tooltipAsync.length);
    },
    /**
     * render component with a specific tag
     * @returns {'a' | 'router-link' | 'span'}
     */
    renderAs() {
      return this.isExternal ? "a" : this.isInternal || this.isChip ? this.isRouterAvailable ? this.renderLinkAs : "a" : "span";
    },
    /**
     * link attributes (href, target, to) to bind to the component
     * depending on link type and router availability
     * @returns {Object}
     */
    linkAttributes() {
      const e = this.isRouterAvailable ? "to" : "href", t = {};
      return this.isExternal && (t.href = this.url, t.target = this.externalLinkTarget), this.isInternal && (t[e] = this.identifierPropertyValue), this.isChip && (t[e] = `${this.path}?${this.chipQueryName}=${JSON.stringify(this.chipObj)}`), {
        // add attributes set from outside
        ...this.additionalAttributes,
        ...t
      };
    },
    /**
     * build the title attribute depending on the current link type
     * @returns {null|string}
     */
    title() {
      return this.isTooltip ? this.altTitle || this.titleText.tooltip : this.isChip ? this.titleText.chip.replace("{type}", this.titleText.type[this.type] ? this.titleText.type[this.type] : "").replace("{value}", this.altTitleInt).replace(/\s+/g, " ") : this.altTitle ? this.altTitle : null;
    }
  },
  watch: {
    tooltip(e) {
      e && (this.isLoading = !1, this.showTooltip = !0);
    }
  },
  mounted() {
    window.addEventListener("scroll", this.scrollResizeHandler), window.addEventListener("resize", this.scrollResizeHandler);
  },
  destroyed() {
    window.removeEventListener("scroll", this.scrollResizeHandler), window.removeEventListener("resize", this.scrollResizeHandler);
  },
  methods: {
    /**
     * handle click events for different link types
     */
    clickHandler() {
      this.isTooltip && this.tooltipClicked();
    },
    /**
     * close an open tooltip
     */
    closeTooltip() {
      this.showTooltip && (this.showTooltip = !1);
    },
    /**
     * handle tooltip click event
     */
    async tooltipClicked() {
      if (this.tooltip && this.$slots.tooltip || this.tooltip.length) {
        this.showTooltip = !this.showTooltip;
        return;
      }
      this.tooltipAsync.length && (this.isLoading = !0, this.$emit("tooltip-clicked", this.tooltipAsync));
    },
    /**
     * intercept scroll/resize event and close the tooltip
     */
    scrollResizeHandler() {
      this.scrollResizeTimeout && (clearTimeout(this.scrollResizeTimeout), this.scrollResizeTimeout = null), this.scrollResizeTimeout = setTimeout(() => {
        this.showTooltip && this.closeTooltip();
      }, 100);
    }
  }
};
var p = function() {
  var t = this, i = t._self._c;
  return i(t.renderAs, t._b({ directives: [{ name: "clean-dom-nodes", rawName: "v-clean-dom-nodes" }], tag: "component", class: [
    "base-link",
    {
      "base-link--chip": t.isChip,
      "base-link--internal": t.isInternal,
      "base-link--external": t.isExternal,
      "base-link--tooltip": t.isTooltip,
      "base-link--active": t.showTooltip,
      "base-link--space-after": t.spaceAfter
    }
  ], attrs: { "aria-controls": t.isTooltip ? `tooltipBox-${t._uid}` : null, "aria-expanded": t.isTooltip ? t.showTooltip.toString() : null, "aria-label": t.isChip || t.isTooltip ? t.title : null, tabindex: t.isTooltip ? 0 : null, title: t.title }, on: { keyup: function(l) {
    return !l.type.indexOf("key") && t._k(l.keyCode, "enter", 13, l.key, "Enter") ? null : t.clickHandler.apply(null, arguments);
  }, click: t.clickHandler } }, "component", t.linkAttributes, !1), [t.isTooltip ? t._e() : [t._t("label", function() {
    return [i("span", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: t.value, interpretTextAsHtml: t.interpretTextAsHtml }, expression: "{ value, interpretTextAsHtml }" }], class: { "no-clean": t.interpretTextAsHtml } })];
  }, { label: t.value })], t.isTooltip ? [i("span", { staticClass: "base-link__label" }, [t._t("label", function() {
    return [i("span", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: t.value, interpretTextAsHtml: t.interpretTextAsHtml }, expression: "{ value, interpretTextAsHtml }" }], class: { "no-clean": t.interpretTextAsHtml } })];
  }, { label: t.value })], 2), i("span", { ref: "icon", staticClass: "base-link__icon" }, [i("BaseIcon", { directives: [{ name: "show", rawName: "v-show", value: !t.isLoading, expression: "!isLoading" }], attrs: { name: "information" } })], 1), t.isLoading ? i("span", { staticClass: "base-link__loader" }, [t.isLoading ? i("BaseLoader") : t._e()], 1) : t._e(), t.showTooltip ? i("BaseTooltipBox", { attrs: { id: `tooltipBox-${t._uid}`, "attach-to": t.$refs.icon, "modal-on-mobile": !1, role: "tooltip", styles: t.tooltipStyles, "threshold-top": t.tooltipThresholdTop, "type-on-mobile": t.tooltipTypeOnMobile }, on: { close: function(l) {
    t.showTooltip = !t.showTooltip;
  } } }, [t._t("tooltip", function() {
    return [t.tooltip.label ? i("span", { staticClass: "base-tooltip__label" }, [t._v(" " + t._s(t.tooltip.label) + " ")]) : t._e(), t._l(t.tooltip, function(l, s) {
      return i("div", { key: s, staticClass: "base-tooltip__row" }, [t._v(" " + t._s(l.label) + ": "), l.url ? [i("a", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: l.value, interpretTextAsHtml: t.interpretTextAsHtml }, expression: "{ value: item.value, interpretTextAsHtml }" }], staticClass: "base-link--external", attrs: { href: l.url, title: l.altTitle || void 0 } }, [t._v(" " + t._s(l.value) + " ")])] : [i("span", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: l.value, interpretTextAsHtml: t.interpretTextAsHtml }, expression: "{ value: item.value, interpretTextAsHtml }" }] })]], 2);
    })];
  }, { item: t.tooltip })], 2) : t._e()] : t._e()], 2);
}, u = [], h = /* @__PURE__ */ a(
  n,
  p,
  u,
  !1,
  null,
  "77449154",
  null,
  null
);
const T = h.exports;
export {
  T as default
};
//# sourceMappingURL=BaseLink.vue.es.js.map
