import h from "vue-click-outside";
import m from "vue2-datepicker";
import { createId as f, debounce as c, capitalizeString as p } from "../../utils/utils.es.js";
import b from "vue2-datepicker/locale/en";
import Y from "vue2-datepicker/locale/de";
import g from "vue2-datepicker/locale/fr";
import D from "../BaseInput/BaseInput.vue.es.js";
import F from "../BaseIcon/BaseIcon.vue.es.js";
import "./BaseDateInput.vue.es2.js";
import "./BaseDateInput.vue.es3.js";
import I from "../../_virtual/_plugin-vue2_normalizer.es.js";
const $ = {
  name: "BaseDateInput",
  components: {
    BaseInput: D,
    BaseIcon: F,
    BaseSwitchButton: () => import("../BaseSwitchButton/BaseSwitchButton.vue.es.js").then((i) => i.default || i),
    DatePicker: m
  },
  directives: {
    ClickOutside: h
  },
  model: {
    prop: "input",
    event: "selected"
  },
  props: {
    /**
     * select date or datetime or a range
     */
    type: {
      type: String,
      default: "single",
      validator(i) {
        return ["daterange", "datetime", "single", "timerange"].includes(i);
      }
    },
    /**
     * input field settable from outside.
     *   attention: if this is an object it needs to contain all the
     *   properties (e.g. date_from, time_to) already otherwise only
     *   a string will be returned
     */
    input: {
      type: [Object, String, Date],
      required: !0
    },
    /** label for input field, required for usability purposes, handle
     * showing of label with property showLabel
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * defines if input label should be visible
     */
    showLabel: {
      type: Boolean,
      default: !0
    },
    /**
     * set a placeholder for the input field (object with date and time attribute respectively)
     */
    placeholder: {
      type: [Object, String],
      default: () => ({ date: "Select Date", time: "Select Time" })
    },
    /**
     * define the range separator
     */
    rangeSeparator: {
      type: String,
      default: "â€“"
    },
    /**
     * specify date format.
     *
     *  **date_year**: display tabs that allow for toggle between only choosing year
     *   or complete date
     *  **date_month_year**: display tabs that allow for toggle between choosing only year,
     *   year and month or complete date
     */
    format: {
      type: String,
      default: "day",
      validator(i) {
        return ["day", "month", "year", "date_year", "date_month_year"].includes(i);
      }
    },
    /**
     * specify labels displayed instead of 'DD.MM.YYYY' and 'YYYY'
     *   should have the form `{ date: 'xxx', month: 'zzz', year: 'yyy' }`
     */
    dateFormatLabels: {
      type: Object,
      default: () => ({ date: "DD.MM.YYYY", month: "MM.YYYY", year: "YYYY" }),
      validator(i) {
        const t = Object.keys(i);
        return t.includes("date") && t.includes("year");
      }
    },
    /**
     * a legend for the date format switch buttons
     */
    formatTabsLegend: {
      type: String,
      default: "Switch between date formats"
    },
    /**
     * set calendar language (ISO 639-1).
     * **caveat**: currently only `en`, `de` and `fr` are supported
     *  @values de, en, fr
     */
    language: {
      type: String,
      default: "en",
      validator: (i) => ["de", "en", "fr"].includes(i)
    },
    /**
     * set id
     */
    id: {
      type: [Number, String],
      default: ""
    },
    /**
     * define if standard form field styling should be
     * used (otherwise no border, no box shadow)
     */
    useFormFieldStyling: {
      type: Boolean,
      default: !0
    },
    /**
     * option to have the border of the input field not displayed
     */
    showInputBorder: {
      type: Boolean,
      default: !0
    },
    /**
     * mark as required field (currently only used for aria-required)
     */
    required: {
      type: Boolean,
      default: !1
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field
     * for an example see [BaseInput](BaseInput)
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * set `true` if input field should be disabled
     * for an example see [BaseInput](BaseInput)
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * add an error message to be displayed below form field if field is invalid
     * for an example see [BaseInput](BaseInput)
     */
    errorMessage: {
      type: String,
      default: ""
    },
    /**
     * define if error icon should be shown
     * for an example see [BaseInput](BaseInput)
     */
    showErrorIcon: {
      type: Boolean,
      default: !0
    },
    /**
     * if `true` a remove icon will be shown allowing to remove
     * all input at once
     * for an example see [BaseInput](BaseInput)
     */
    clearable: {
      type: Boolean,
      default: !1
    },
    /**
     * specify additional input field styling
     */
    inputClass: {
      type: String,
      default: ""
    },
    /**
     * use this prop to deactivate automatic setting of focus as soon as input element
     * becomes active - this might require external handling of focus setting!
     */
    setFocusOnActive: {
      type: Boolean,
      default: !0
    },
    /**
     * in order to be able to set input field active state from outside
     */
    isActive: {
      type: Boolean,
      default: !1
    },
    /**
     * use this prop to set a delay in ms before calender is displayed
     */
    isActiveDelay: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      /**
       * internal input representation with all possible values for
       * date and time
       * @typedef {Object} inputInt
       * @property {string} inputInt.date - attribute a single date or datetime date is stored in
       * @property {string} inputInt.date_from - storing daterange from
       * @property {string} inputInt.date_to - storing daterange to
       * @property {string} inputInt.time - storing the time for datetime type
       * @property {string} inputInt.time_from - storing timerange from
       * @property {string} inputInt.time_to - storing timerange to
       */
      inputInt: {
        date: "",
        date_from: "",
        date_to: "",
        time: "",
        time_from: "",
        time_to: ""
      },
      /**
       * variable for toggling format between date and year for date_year format
       * @type {string}
       */
      dateFormatInt: "",
      /**
       * variable to store the date when switching from date to year in order to be
       * able to restore exact date when switching back
       * @type {inputInt}
       */
      tempDateStore: {},
      /**
       * to steer closing of datepicker from input field once date is selected
       * @type {boolean}
       */
      fromOpen: !1,
      /**
       * to steer closing of datepicker to input field once date is selected
       * @type {boolean}
       */
      toOpen: !1,
      /**
       * variable to keep active state in sync with potential parent prop
       * (this is needed as independent variable from toOpen and fromOpen for example in
       * BaseAdvancedSearchRow to keep dropdown open even if datepicker is closed)
       */
      isActiveInt: !1,
      /**
       * variable to steer if input fade out of from field should be shown
       * @type {boolean}
       */
      useFadeOutFrom: !1,
      /**
       * variable to steer if input fade out of to field should be shown
       * @type {boolean}
       */
      useFadeOutTo: !1,
      /**
       * variable to steer if icons should be shown (becoming false if not enough
       * space)
       * @type {boolean}
       */
      showIcons: !0,
      /**
       * variable to store icon size which is calculated in the beginning and might be
       * hidden later
       * @type {number}
       */
      iconSize: 24,
      /**
       * Resize Observer to trigger fade out calculations when component is resized
       * @type {?ResizeObserver}
       */
      resizeObserver: null,
      /**
       * function needs to be triggered when date switch is populated
       * @type {?ResizeObserver}
       */
      labelAdditionsObserver: null,
      /**
       * datepicker localisations
       *   using object fixes problem of missing localisation files in rollup-esm-build
       */
      lang: {
        de: Y,
        en: b,
        fr: g
      },
      /**
       * variable to set css class according to label elements wrapping or not
       * @type {boolean}
       */
      wrapLabelRow: !1
    };
  },
  computed: {
    internalId() {
      return this.id || f();
    },
    /**
     * this is the format we want to store computed based on what
     * was specified in format and what date toggle tabs (via dateFormatInt) might say
     * TODO: check if this is still needed with custom input
     * @returns {string}
     */
    datePickerValueFormat() {
      return this.format === "year" || this.dateFormatInt === "YYYY" ? "Y" : this.format === "month" || this.dateFormatInt === "MM.YYYY" ? "MM.Y" : "DD.MM.Y";
    },
    /**
     * if the format is settable this.format is date_year and can not be
     * used directly for the date picker component
     * @returns {string}
     */
    minDateView() {
      return this.isSwitchableFormat && this.dateFormatInt === "YYYY" ? "year" : this.isSwitchableFormat && this.dateFormatInt === "MM.YYYY" ? "month" : this.isSwitchableFormat && this.dateFormatInt === "DD.MM.YYYY" ? "day" : this.format;
    },
    /**
     * compute the properties of the object provided in input prop
     * @returns {string[]}
     */
    inputProperties() {
      return typeof this.input == "object" ? Object.keys(this.input) : [];
    },
    /**
     * check if input is just a single date or an object
     * @returns {boolean}
     */
    isInputTypeString() {
      return typeof this.input == "string" || !this.inputProperties.length;
    },
    /**
     * handle input for the 'from' input field
     */
    inputFrom: {
      /**
       * get back the appropriate inputInt attribute value
       * @returns {string} - a date in the format DD.MM.YYYY
       */
      get() {
        return this.isFromTimeField ? this.inputInt.time_from : this.parseToDateDisplay(this.inputInt.date || this.inputInt.date_from);
      },
      /**
       * also assign them again accordingly
       * @param {string} val - the value provided by the input element
       * @param {string} oldValue - the previous value of inputFrom
       */
      set(i, t) {
        let e = i;
        this.isFromTimeField ? this.inputInt.time_from = e : (e = this.parseToDateStorage(i), this.inputProperties.includes("date_from") ? this.inputInt.date_from = e : this.inputInt.date = e), e !== t && this.emitData();
      }
    },
    /**
     * as above - if there is only a single time field get value from 'time' variable
     * if it is a range use 'time_to''
     */
    inputTo: {
      /**
       * get back the appropriate inputInt attribute value
       * @returns {string}
       */
      get() {
        return this.isToTimeField ? this.inputInt.time || this.inputInt.time_to : this.parseToDateDisplay(this.inputInt.date_to);
      },
      /**
       * also assign them again accordingly
       * @param {string} val - the value provided by the input element
       * @param {string} oldValue - the previous value of inputTo
       */
      set(i, t) {
        let e = i;
        this.isToTimeField ? this.inputProperties.includes("time_from") ? this.inputInt.time_to = e : this.inputInt.time = e : (e = this.parseToDateStorage(e), this.inputInt.date_to = e), e !== t && this.emitData();
      }
    },
    /**
     * determine if the initially provided date is a year or a full date
     * (used to set the correct date display format and date/year switch button)
     * @returns {boolean}
     */
    isDateFormatYear() {
      return this.isInputTypeString && this.inputInt.date && /^(-?[0-9]{1,4}|-[0-9]{0,4})$/.test(this.inputInt.date) || this.inputProperties.some((i) => !!i.includes("date") && this.inputInt[i] && /^(-?[0-9]{1,4}|-[0-9]{0,4})$/.test(this.inputInt[i]));
    },
    isDateFormatMonth() {
      return this.isInputTypeString && this.inputInt.date && /^(-?[0-9]{1,4}|-[0-9]{0,4})-[0-1]?[0-9]$/.test(this.inputInt.date) || this.inputProperties.some((i) => !!i.includes("date") && this.inputInt[i] && /^(-?[0-9]{1,4}|-[0-9]{0,4})-[0-1]?[0-9]$/.test(this.inputInt[i]));
    },
    /**
     * check if format switch tabs should be shown
     * @returns {boolean}
     */
    isSwitchableFormat() {
      return this.format === "date_month_year" || this.format === "date_year";
    },
    /**
     * return the format options for date, month, year switches
     * @returns {[{label: string, value: string}]}
     */
    tabSwitchOptions() {
      const i = [
        { label: this.dateFormatLabels.date, value: "DD.MM.YYYY" },
        { label: this.dateFormatLabels.year, value: "YYYY" }
      ];
      return this.format === "date_month_year" && i.splice(1, 0, {
        label: this.dateFormatLabels.month,
        value: "MM.YYYY"
      }), i;
    },
    /**
     * determine if the from field is a time field
     * @returns {boolean}
     */
    isFromTimeField() {
      return this.type === "timerange";
    },
    /**
     * determine if the to field is a time field
     * @returns {boolean}
     */
    isToTimeField() {
      return this.type === "datetime" || this.type === "timerange";
    },
    /**
     * compute an object that takes component $listeners and manipulate them for custom
     * needs
     * @returns {Object}
     */
    inputListeners() {
      return {
        // add all the listeners from the parent
        ...this.$listeners,
        // stop these BaseInput originating events to substitute them with the
        // correct events in search container element
        "clicked-outside": (i) => {
          i.stopPropagation();
        },
        // need to stop the event triggered in original BaseInput and only trigger
        // when component isActiveInt has changed
        "update:is-active": () => {
        },
        // stop BaseInput input event since BaseDateInput will propagate their own
        input: () => {
        }
      };
    },
    /**
     * compute an object that takes component $listeners and manipulate them for custom
     * needs
     * @returns {Object}
     */
    dateInputListeners() {
      return {
        // add all the listeners from the parent
        ...this.$listeners,
        // stop native input event here and emit own event (in inputInt watcher)
        // with just the values
        input: () => {
        }
      };
    },
    /**
     * check if label-addition slot exists is filled
     */
    labelRowSlotsHaveData() {
      const i = this.$slots["label-addition"];
      return !!i && !!i.length && i.some((t) => {
        var e;
        return t.tag || ((e = t.text) == null ? void 0 : e.trim());
      });
    },
    /**
     * determines if label row should be shown
     * @returns {Boolean|boolean}
     */
    showLabelRow() {
      return this.showLabel || this.isSwitchableFormat || this.labelRowSlotsHaveData;
    }
  },
  watch: {
    inputInt: {
      handler() {
        this.$emit("input", this.getInputData());
      },
      deep: !0
    },
    /**
     * watch format and set correct dateFormat
     */
    format: {
      handler(i) {
        if (i === "year") {
          this.dateFormatInt = "YYYY";
          return;
        }
        if (i === "month") {
          this.dateFormatInt = "MM.YYYY";
          return;
        }
        this.dateFormatInt = "DD.MM.YYYY";
      },
      immediate: !0
    },
    /**
     * watch input set from outside and set internal inputInt accordingly as well as
     * set the correct display format
     */
    input: {
      handler(i) {
        if (JSON.stringify(i) !== JSON.stringify(this.getInputData())) {
          const t = this.type === "datetime";
          this.inputFrom = t ? i.date : i.date ?? i.date_from ?? i.time ?? i.time_from ?? i ?? "", this.inputTo = t ? i.time : i.date_to ?? i.time_to ?? "", this.isSwitchableFormat && (this.isDateFormatYear ? this.dateFormatInt = "YYYY" : this.isDateFormatMonth ? this.dateFormatInt = "MM.YYYY" : this.dateFormatInt = "DD.MM.YYYY");
        }
      },
      // to not need to do extra assignment in created()
      immediate: !0
    },
    /**
     * in order to allow user to restore previous date after switching
     * from date to year and back store in temp variable (but only if previous date was full date
     * (check necessary for starting with year where format is switched to 'YYYY'
     * but no previous full date avaliable))
     * @param {string} val - the changed dateFormatInt value
     * @param {string} old - the previous value
     */
    dateFormatInt(i, t) {
      !this.isDateFormatYear && t === "DD.MM.YYYY" ? this.tempDateStore = { ...this.inputInt } : !this.isDateFormatYear && i === "YYYY" && t === "MM.YYYY" && (this.tempDateStore ? Object.keys(this.inputInt).filter((e) => !!e.includes("date")).forEach((e) => {
        !this.monthAndYearIdent(
          // check if the positive dates are identical
          this.removeYearMinusFromStorageDate(this.inputInt[e], t),
          /^-/.test(this.tempDateStore[e]) ? this.tempDateStore[e].replace("-", "") : this.tempDateStore[e]
          // and also check if the operator in front of year is identical
        ) && this.isNegativeStorageDate(this.inputInt[e], t) === /^-/.test(this.tempDateStore[e]) && this.$set(this.tempDateStore, e, this.inputInt[e]);
      }) : this.tempDateStore = { ...this.inputInt }), this.convertDate(t), this.emitData();
    },
    /**
     * watch for changes in input field active variable to keep in sync with parent
     * @param {boolean} val - the changed internal is active variable
     */
    isActiveInt(i) {
      this.$emit("update:is-active", i);
    },
    /**
     * also adjust internal variable when active state changes from outside
     * @param {boolean} val - the changed isActive prop
     */
    isActive: {
      handler(i) {
        i !== this.isActiveInt && (this.isActiveInt = i, this.fromOpen = i), i || (this.fromOpen = !1, this.toOpen = !1);
      },
      immediate: !0
    }
  },
  mounted() {
    this.$refs.baseIcon && (this.iconWidth = this.$refs.baseIcon.$el.clientWidth), this.initObservers();
  },
  updated() {
    (this.fromOpen || this.toOpen) && this.$nextTick(() => {
      [...this.$el.querySelectorAll(
        'div, a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])'
      )].filter((t) => !t.hasAttribute("disabled")).filter((t) => t.className.includes("mx-")).forEach((t) => {
        t.setAttribute("tabindex", -1);
      });
    });
  },
  beforeDestroy() {
    this.resizeObserver && this.resizeObserver.disconnect(), this.labelAdditionsObserver && this.labelAdditionsObserver.disconnect();
  },
  methods: {
    /**
     * since the complete datepicker lies within the BaseInput, the BaseInput click event
     *  is triggered also when a date is picked from the date picker - this leads to the undesired
     *  side effect that the date picker pop up is reopened when a date was selected there
     *  therefore we only allow the click event to pass on when the user clicks on the input field
     *  DIRECTLY
     * @param {PointerEvent} event - the native click event
     */
    onInputClick(i) {
      i.target.tagName !== "INPUT" && i.stopPropagation();
    },
    /**
     * in general input field active styling is handled via focusin and
     * clicked-outside, however for special case iOS touch  devices have
     * up and down arrows that do not trigger any event other than blur and will
     * cause the dropdowns of input fields to remain open
     * @param {FocusEvent} event - the native blur event
     * @param {string} origin - did event emit from 'from' or 'to' date field
     */
    onInputBlur(i, t) {
      var a, n, l, o;
      const e = (a = i.relatedTarget) != null && a.parentElement ? i.relatedTarget.parentElement.getElementsByTagName("input") : null;
      i.relatedTarget && (i.relatedTarget.tagName === "INPUT" && (!((n = i.relatedTarget) != null && n.id) || i.relatedTarget.id !== i.target.id) || ((l = i.relatedTarget) == null ? void 0 : l.className) === "base-input__remove-icon-wrapper" && e && ((o = e[0]) == null ? void 0 : o.id) !== i.target.id) && (this[`${t}Open`] = !1);
    },
    initObservers() {
      const i = new ResizeObserver(c(50, () => {
        this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData) && this.calcLabelAdditionsWidth(), this.calcFadeOut(["From", "To"]);
      }));
      if (i.observe(this.$refs.baseDateInput), this.resizeObserver = i, this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {
        const t = new ResizeObserver(c(50, (e, a) => {
          e[0].contentRect.width > 0 && (this.calcLabelAdditionsWidth(this.$refs.baseDateInput.clientWidth), a.disconnect());
        }));
        t.observe(this.$refs.labelAdditions), this.labelAdditionsObserver = t;
      }
    },
    /**
     * transform the date to the correct display format
     * @param {string} dateString - the date string in YYYY-MM-DD format
     */
    parseToDateDisplay(i) {
      if (!i)
        return "";
      const t = this.isNegativeStorageDate(i), e = t ? this.removeYearMinusFromStorageDate(i) : i;
      return this.addYearMinusToDateDisplay(
        e.split("-").reverse().join("."),
        t
      );
    },
    /**
     * transform the date to the correct storage format
     * @param {string} dateString - the date string in DD.MM.YYYY format
     */
    parseToDateStorage(i) {
      return i ? i.split(".").reverse().join("-") : "";
    },
    /**
     * checks done on keydown events
     * a) tab key needs separate handling and only needs to set input field close when
     * there is no clearable button (or shift key was used for going to previous field)
     * b) prevent user from entering chars other than number or period (date) or colon (time)
     * and not more characters than the date format requires
     * @param {KeyboardEvent} event - the keydown event
     * @param {string} origin - is event coming from 'from' or 'to' field in title case
     */
    handleInputKeydown(i, t) {
      let e = i.target.value;
      const { key: a } = i, n = this.isTimeInputField(t), l = n ? ":" : "\\.";
      let o = !1;
      (this.dateFormatInt === "DD.MM.YYYY" && /^\d{2}\.\d{2}\.\d{0,4}$/.test(e) || this.dateFormatInt === "MM.YYYY" && /^\d{2}\.\d{0,4}$/.test(e) || this.dateFormatInt === "YYYY" && /^\d{0,4}$/.test(e)) && (o = !0);
      const s = new RegExp(`([0-9${o ? "-" : ""}]|${l}|Backspace|Delete|Tab|Enter|ArrowRight|ArrowLeft)`), r = new RegExp(`([0-9]|${l})`);
      let d = n ? 5 : this.dateFormatInt.length;
      !n && this.isNegativeDisplayDate(e) && (d += 1), (!s.test(a) || r.test(a) && e.length >= d && document.activeElement.selectionEnd - document.activeElement.selectionStart === 0 || !n && a === "." && (this.dateFormatInt === "YYYY" || e.charAt(e.length - 1) === ".") || n && a === ":" && e.charAt(e.length - 1) === ":") && !(["c", "v", "x"].includes(a) && i.ctrlKey) && i.preventDefault(), a === "Enter" && (this.checkDateValidity(t), e = this[`input${t}`]), (a === "Enter" || a === "Tab" && (i.shiftKey || !this.clearable || !e)) && (this[`${t.charAt(0).toLowerCase()}${t.slice(1)}Open`] = !1);
    },
    /**
     * this function is triggered with the input event - it checks the length of the value and
     * adds the '.' (date) or (':') or '0' in the correct places or removes '-' that was added at
     * a wrong position if necessary
     * @param {InputEvent} event - the input event
     * @param {string} origin - is event coming from 'from' or 'to' field in title case
     */
    checkDate(i, t) {
      let e = i.target.value;
      if (e === this[`input${t}`])
        return;
      const a = this.isTimeInputField(t), n = a ? ":" : ".";
      if (e && i.inputType !== "deleteContentBackward") {
        if (e !== "-" && !this.isNegativeDisplayDate(e) && (e = e.replace("-", "")), (!a && this.dateFormatInt === "DD.MM.YYYY" && /^(\d{2}$|\d{2}\.\d{2})$/.test(e) || (this.dateFormatInt === "MM.YYYY" || a) && /^\d{2}$/.test(e)) && (e = `${e}${n}`), new RegExp(`^[1-9]${a ? ":" : "\\."}$`).test(e))
          e = `0${e}`;
        else if (/^\d{2}\.\d\.$/.test(e)) {
          const [o, s, r] = e.split(".");
          e = `${o}.0${s}.${r}`;
        }
      }
      this[`input${t}`] = e;
    },
    /**
     * this function is triggered with the blur event on the input and does a last check on the
     * validity of the value
     * @param {string} origin - is event coming from 'from' or 'to' field in title case
     */
    checkDateValidity(i) {
      const t = this.isTimeInputField(i);
      let e = this.removeYearMinusFromDisplayDate(this[`input${i}`]);
      if (e) {
        const n = t ? 5 : this.dateFormatInt.length, l = t ? ":" : ".", o = t ? 2 : this.dateFormatInt.split(".").length;
        if (e.split(l).length > o && (e = e.replaceAll(".", "")), o > e.split(l).length && (n !== 4 && /^\d{3}/.test(e) && (e = `${e.slice(0, 2)}${l}${e.slice(2, e.length)}`), this.dateFormatInt === "DD.MM.YYYY" && n !== 4 && /^\d{2}\.\d{3}/.test(e) && (e = `${e.slice(0, 5)}.${e.slice(5, e.length)}`)), e.length !== n) {
          if (t) {
            if (/^\d{1,2}:?$/.test(e)) {
              const [s] = e.split(":");
              e = `${s}:00`;
            }
            if (/^\d:\d{1,2}$/.test(e)) {
              const [s, r] = e.split(":");
              e = `0${s}:${r}`;
            }
            if (/^\d{2}:\d$/.test(e)) {
              const [s, r] = e.split(":");
              e = `${s}:0${r}`;
            }
          } else {
            if (this.dateFormatInt === "DD.MM.YYYY" && /^\d{1,2}\.\d{1,2}\.?(\d{0,3})$/.test(e)) {
              const s = (/* @__PURE__ */ new Date()).getFullYear(), [r, d, u] = e.split(".");
              u ? e = `${r}.${d}.${u.padStart(4, "0")}` : e = `${r}.${d}.${s}`;
            }
            if (this.dateFormatInt === "MM.YYYY" && /^\d{1,2}\.?(\d{0}|\d{2})$/.test(e)) {
              const s = (/* @__PURE__ */ new Date()).getFullYear(), [r, d] = e.split("."), u = s.toString().slice(0, 2);
              e = `${r}.${d > (s + 10).toString().slice(2, 4) ? Number(u - 1) : u}${d || s.toString().slice(2, 4)}`;
            }
            if (this.dateFormatInt === "DD.MM.YYYY" && /^[1-9]\.\d{1,2}\.\d{4}$/.test(e)) {
              const [s, r, d] = e.split(".");
              e = `0${s}.${r}.${d}`;
            }
            if (["DD.MM.YYYY", "MM.YYYY"].includes(this.dateFormatInt) && /^\d{2}?\.?[1-9]\.\d{4}$/.test(e)) {
              const [s, r, d] = e.split(".").reverse();
              e = `${d}.0${r}.${s}`;
            }
            this.dateFormatInt === "YYYY" && (e = `${e.padStart(4, "0")}`);
          }
          e.length !== n && (e = "");
        }
        if (t) {
          if (Number.isNaN(Date.parse(`1212-12-12T${e}`))) {
            let [s, r] = e.split(":");
            /^([0-1][0-9]|2[0-4])$/.test(s) || (s = "00"), /^[0-5][0-9]$/.test(r) || (r = "00");
            const d = `${s}:${r}`;
            e = Number.isNaN(Date.parse(`1212-12-12T${d}`)) ? "" : d;
          }
        } else {
          if (Number.isNaN(Date.parse(this.parseToDateStorage(e)))) {
            const [r, d, u] = e.split(".").reverse();
            this.dateFormatInt === "DD.MM.YYYY" && (/^(0[1-9]|[1-2][0-9]|3[0-1])/.test(u) || (e = `01.${d}.${r}`)), this.dateFormatInt !== "YYYY" && (/^(0[1-9]|1[0-2])/.test(d) || (e = `${u ? `${u}.` : ""}01.${r}`));
          }
          const s = this.getDateString(this.convertToDate(this.parseToDateStorage(e)));
          Number.isNaN(Date.parse(this.parseToDateStorage(s))) ? e = "" : e = s;
        }
        this[`input${i}`] = this.addYearMinusToDateDisplay(
          e,
          this.isNegativeDisplayDate(this[`input${i}`])
        ), this.calcFadeOut([i]);
      }
      const a = this.getInputData();
      this.$emit("value-validated", a);
    },
    /**
     * a function to have the time picker close automatically as soon as minutes
     * are selected
     * @param {string} origin - is it from the 'from' or 'to' part of the picker
     * @param {any} time - the selected time (not needed here but passed by event)
     * @param {string} type - was 'hour' or 'minute' selected
     */
    closeTimePicker(i, t, e) {
      if (e === "minute") {
        const a = p(i);
        this.checkDateValidity(a), this[`${i}Open`] = !1, this.calcFadeOut([a]);
      }
    },
    /**
     * function triggered on datepicker 'pick' event, handling date picker closing
     * and date validation
     *  caveat: this event is just triggered for DATE picker - not time!
     * @param origin
     */
    datePicked(i) {
      this[`${i}Open`] = !1, this.checkDateValidity(p(i));
    },
    /**
     * handle click outside event and adjust input active variable accordingly
     * @param {MouseEvent} event - the event provided by the click outside directive
     */
    clickedOutside(i) {
      this.isActiveInt = !1, this.$emit("clicked-outside", i);
    },
    /**
     * handle click inside the component and adjust input active variable accordingly
     * @param {MouseEvent} event - event triggered by mouse click
     */
    clickedInside(i) {
      this.isActiveInt = !0, this.$emit("click-input-field", i);
    },
    /**
     * data emit function, transforming data before emit event
     */
    emitData() {
      const i = this.getInputData();
      this.$emit("selected", i);
    },
    /**
     * convert function triggered on format tab switch
     */
    convertDate(i) {
      Object.entries(this.inputInt).filter(([t]) => !!t.includes("date")).forEach(([t, e]) => {
        const a = this.removeYearMinusFromStorageDate(e, i);
        if (a) {
          if (this.minDateView === "year") {
            this.$set(this.inputInt, t, this.addYearMinusToDateStorage(
              this.convertToDate(a).getFullYear().toString(),
              this.isNegativeStorageDate(e, i)
            ));
            return;
          }
          let n;
          const l = this.tempDateStore ? this.tempDateStore[t] : null, o = !!l && /^-/.test(l), s = this.isNegativeStorageDate(e, i), r = o ? l.replace("-", "") : l;
          this.minDateView === "month" ? n = !!r && (!this.isDateFormatYear && this.monthAndYearIdent(r, a) || new Date(r).getFullYear().toString() === a) && o === s : n = !!r && (this.isDateFormatYear && new Date(r).getFullYear().toString() === a && o === this.isNegativeStorageDate(e, i) || this.isDateFormatMonth && this.monthAndYearIdent(r, a) && o === s);
          const d = n ? r : a;
          this.$set(
            this.inputInt,
            t,
            this.addYearMinusToDateStorage(
              this.getDateString(this.convertToDate(d)),
              // use the original dates here before minus was removed, depending on which date was used
              n ? o : s
            )
          );
        }
      });
    },
    /**
     * if input was just a single string return that otherwise
     * only return the properties provided by external input
     * if input is empty set value to empty string instead of null (default vue2-datepicker)
     * @returns {string | Object}
     */
    getInputData() {
      if (this.isInputTypeString)
        return this.inputInt.date !== null ? this.inputInt.date : "";
      const i = {};
      return this.inputProperties.forEach((t) => this.$set(i, t, this.inputInt[t] !== null ? this.inputInt[t] : "")), i;
    },
    /**
     * convert a value to a date in local time at zero hours
     *
     * @param {string} value - the date string stored in db (format YYYY-MM-DD) - this needs to
     *  be a positive date value!! (remove minus from negative years before applying this function)
     * @returns {Date} - (e.g. Fri Jul 30 2021 00:00:00 GMT+0200 (Central European Summer Time))
     */
    convertToDate(i) {
      return /* @__PURE__ */ new Date(`${i}T00:00:00.000`);
    },
    /**
     * a function to convert a date to a string in the format YYYY-MM-DD
     *
     * @param {Date} date in format
     * @returns {string} - returns a string in format YYYY-MM-DD
     */
    getDateString(i) {
      let t = `${i.getFullYear().toString().padStart(4, "0")}`;
      if (this.dateFormatInt !== "YYYY") {
        const e = (i.getMonth() + 1).toString();
        t = `${t}-${e.length < 2 ? "0" : ""}${e}`;
      }
      if (this.dateFormatInt === "DD.MM.YYYY") {
        const e = i.getDate().toString();
        t = `${t}-${e.length < 2 ? "0" : ""}${e}`;
      }
      return t;
    },
    /**
     * compare 2 dates for identical month and year values respectively
     *  these dates need to be positive values (remove the minus from the date
     *  before applying this function)
     * @param {string} date1 - a string in YYYY-MM-DD format
     * @param {string} date2 - a string in YYYY-MM-DD format
     * @returns {boolean}
     */
    monthAndYearIdent(i, t) {
      const e = this.convertToDate(i), a = this.convertToDate(t), n = e.getMonth(), l = a.getMonth(), o = e.getFullYear(), s = a.getFullYear();
      return n === l && o === s;
    },
    /**
     * check for a negative year in the date that is displayed
     * @param {string} date - date string in the format DD.MM.YYYY
     * @returns {boolean}
     */
    isNegativeDisplayDate(i) {
      return i ? this.dateFormatInt === "MM.YYYY" ? /^\d{0,2}\.-\d{0,4}$/.test(i) : this.dateFormatInt === "YYYY" ? /^-\d{0,4}$/.test(i) : /^\d{0,2}\.\d{0,2}\.-\d{0,4}$/.test(i) : !1;
    },
    /**
     * check if year is negative in the stored date
     * @param {string} date - a date string in the format YYYY-MM-DD
     * @param {string} [format=undefined] - in case not the current format (this.dateFormatInt) should
     *  be used for evaluation provide it with this param
     * @returns {boolean}
     */
    isNegativeStorageDate(i, t = void 0) {
      if (!i)
        return !1;
      const e = t || this.dateFormatInt;
      return e === "MM.YYYY" ? /^-\d{0,4}-\d{0,2}$/.test(i) : e === "YYYY" ? /^-\d{0,4}$/.test(i) : /^-\d{0,4}-\d{0,2}-\d{0,2}$/.test(i);
    },
    /**
     * since minus has to be temporarily removed for some actions add it again
     *  after with this function (for displayed date)
     * @param {string} date - date in the format DD.MM.YYYY
     * @param {boolean} [isNegative=true] - optionally do not add minus when calling this
     *  function
     * @returns {string}
     */
    addYearMinusToDateDisplay(i, t = !0) {
      if (t) {
        const [e, a, n] = i.split(".").reverse();
        return `${n !== void 0 ? `${n}.` : ""}${a !== void 0 ? `${a}.` : ""}-${e}`;
      }
      return i;
    },
    /**
     * since minus has to be temporarily removed for some actions add it again
     *  after with this function (for stored date)
     * @param {string} date - date in the format YYYY-MM-DD
     * @param {boolean} [isNegative=true] - optionally do not add minus when calling this
     *  function
     * @returns {string}
     */
    addYearMinusToDateStorage(i, t = !0) {
      return t ? `-${i}` : i;
    },
    /**
     * remove the minus from the date since some functions (especially Date() ) can
     *  not cope with negative dates (for displayed date)
     * @param {string} date - the date string in format DD.MM.YYYY
     * @returns {string}
     */
    removeYearMinusFromDisplayDate(i) {
      return this.isNegativeDisplayDate(i) ? i.replace("-", "") : i;
    },
    /**
     * remove the minus from the date since some functions (especially Date()) can
     *  not cope with negative dates (for stored date)
     * @param {string} date - the date string in format YYYY-MM-DD
     * @param {string} [format=undefined] - in case not the currently selected format should be used
     *  for date evaluation provide the format with this param
     * @returns {string}
     */
    removeYearMinusFromStorageDate(i, t = void 0) {
      return this.isNegativeStorageDate(i, t) ? i.replace("-", "") : i;
    },
    isTimeInputField(i) {
      return this.type === "timerange" || this.type === "datetime" && i.toLowerCase() === "to";
    },
    /**
     * function to calculate if fade out in the input fields should be shown, needs to be
     * recalculated after resize or if input changes
     */
    calcFadeOut(i) {
      i.forEach((t) => {
        if (this.$refs[`input${t}`]) {
          const e = this.$refs[`input${t}`].value, a = e || this.$refs[`input${t}`].getAttribute("placeholder");
          if (a) {
            const n = document.createElement("span");
            n.setAttribute("class", "hide"), n.innerHTML = a, document.body.appendChild(n);
            const l = n.offsetWidth;
            document.body.removeChild(n);
            const o = this.$refs[`input${t}`].offsetWidth;
            l > o ? e && this.showIcons ? this.showIcons = !1 : this[`useFadeOut${t}`] = !0 : l <= o && (this[`useFadeOut${t}`] ? this[`useFadeOut${t}`] = !1 : !this.showIcons && l + this.iconWidth <= o && (this.showIcons = !0));
          }
        }
      });
    },
    /**
     * function to correctly style the date format switch buttons and prevent
     * overlay with label
     */
    calcLabelAdditionsWidth() {
      const i = this.$refs.baseDateInput.clientWidth, t = this.showLabel ? Number(getComputedStyle(this.$refs.label)["margin-right"].replace("px", "")) : 0, e = this.showLabel ? this.$refs.label.clientWidth : 0, a = i - e - t - this.$refs.labelAdditions.clientWidth;
      this.wrapLabelRow = a < 0;
    },
    /**
     * add delay before value is set
     *
     * @param {String} origin - is event originating from 'from' or 'to' field
     * @param {boolean} value
     */
    isActiveHandler(i, t) {
      if (!t) {
        this[`${i}Open`] = t, this.isActiveInt = this.fromOpen || this.toOpen, this.checkDateValidity(p(i));
        return;
      }
      setTimeout(() => {
        this[`${i}Open`] = t, this.isActiveInt = this.fromOpen || this.toOpen;
      }, this.isActiveDelay);
    }
  }
};
var y = function() {
  var t = this, e = t._self._c;
  return e("div", { ref: "baseDateInput", staticClass: "base-date-input" }, [t.showLabelRow ? e("div", { class: [
    "base-date-input__label-row",
    { "base-date-input__label-row--visible": t.showLabel }
  ] }, [t.showLabel ? e("legend", { ref: "label", staticClass: "base-date-input__label", on: { click: function(a) {
    a.preventDefault();
  } } }, [t._v(" " + t._s(t.label) + " ")]) : t._e(), e("div", { class: [
    "base-date-input__label-additions",
    { "base-date-input__label-additions--switch-height": t.isSwitchableFormat },
    { "base-date-input__label-additions--wrap": t.wrapLabelRow }
  ] }, [e("div", { ref: "labelAdditions", class: [
    "base-date-input__label-additions-inner",
    { "base-date-input__label-additions-inner--switch": t.isSwitchableFormat },
    { "base-date-input__label-additions-inner--no-label-switch": t.isSwitchableFormat && !t.showLabel }
  ] }, [t._t("label-addition"), t.isSwitchableFormat ? e("BaseSwitchButton", { staticClass: "base-date-input__switch-buttons", attrs: { options: t.tabSwitchOptions, label: t.formatTabsLegend, "active-tab": t.dateFormatInt }, model: { value: t.dateFormatInt, callback: function(a) {
    t.dateFormatInt = a;
  }, expression: "dateFormatInt" } }) : t._e()], 2)])]) : t._e(), e("div", { directives: [{ name: "click-outside", rawName: "v-click-outside", value: t.clickedOutside, expression: "clickedOutside" }], staticClass: "base-date-input__field-wrapper", on: { click: t.clickedInside } }, [t._t("pre-input-field"), e("div", { staticClass: "base-date-input__input-fields" }, [t._t("input-field-addition-before"), e("div", { staticClass: "base-date-input__input-line" }, [t._t("input-field-inline-before"), e("BaseInput", t._g({ staticClass: "base-date-input__input-wrapper", attrs: { id: `input-${t.internalId}-from`, label: t.label, "show-label": !1, "is-active": t.fromOpen, "use-form-field-styling": t.useFormFieldStyling, "show-input-border": t.showInputBorder, clearable: t.clearable, required: t.required, invalid: t.invalid, disabled: t.disabled, "show-error-icon": t.showErrorIcon, "error-message": t.errorMessage, "input-class": t.inputClass, "set-focus-on-active": t.setFocusOnActive, "use-fade-out": t.useFadeOutFrom }, on: { "update:is-active": function(a) {
    return t.isActiveHandler("from", a);
  } }, scopedSlots: t._u([{ key: "input", fn: function() {
    return [e("div", { staticClass: "base-date-input__datepicker" }, [e("DatePicker", { attrs: { placeholder: t.isFromTimeField ? t.placeholder.time : t.placeholder.date, clearable: !1, "append-to-body": !1, lang: t.lang[t.language], open: t.fromOpen, type: t.isFromTimeField ? "time" : t.minDateView, format: t.isFromTimeField ? "HH:mm" : t.datePickerValueFormat, "value-type": t.isFromTimeField ? "format" : t.datePickerValueFormat, "input-class": "base-date-input__datepicker-input" }, on: { pick: function(a) {
      return t.datePicked("from");
    }, change: function(a) {
      t.isFromTimeField && t.closeTimePicker("from", ...arguments, a);
    } }, nativeOn: { click: function(a) {
      return a.preventDefault(), t.onInputClick.apply(null, arguments);
    } }, scopedSlots: t._u([{ key: "input", fn: function() {
      return [e("input", t._g({ ref: "inputFrom", class: ["base-date-input__input", t.inputClass], attrs: { id: `input-${t.internalId}-from`, placeholder: t.isFromTimeField ? t.placeholder.time ?? t.placeholder : t.placeholder.date ?? t.placeholder, type: "text", "aria-describedby": t.label + "-" + t.internalId, "aria-required": t.required.toString(), "aria-invalid": t.invalid.toString(), required: t.required, disabled: t.disabled, "aria-disabled": t.disabled, enterkeyhint: "done", autocomplete: "off" }, domProps: { value: t.inputFrom }, on: { input: function(a) {
        return t.checkDate(a, "From");
      }, keydown: function(a) {
        return t.handleInputKeydown(a, "From");
      }, blur: function(a) {
        return t.onInputBlur(a, "from");
      } } }, t.dateInputListeners))];
    }, proxy: !0 }, { key: "icon-calendar", fn: function() {
      return [e("div", { staticClass: "base-date-input__icon-wrapper" })];
    }, proxy: !0 }]), model: { value: t.inputFrom, callback: function(a) {
      t.inputFrom = a;
    }, expression: "inputFrom" } })], 1)];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [t.showIcons ? e("BaseIcon", { ref: "baseIcon", staticClass: "base-date-input__date-icon", attrs: { name: t.isFromTimeField ? "clock" : "calendar-many" }, on: { click: function(a) {
      a.stopPropagation(), t.fromOpen = !t.fromOpen;
    } } }) : t._e()];
  }, proxy: !0 }]), model: { value: t.inputFrom, callback: function(a) {
    t.inputFrom = a;
  }, expression: "inputFrom" } }, t.inputListeners)), t.type === "daterange" || t.type === "timerange" ? e("span", { staticClass: "base-date-input__separator" }, [t._v(t._s(t.rangeSeparator))]) : t._e(), t.type !== "single" ? e("BaseInput", t._g({ staticClass: "base-date-input__input-wrapper", attrs: { id: `input-${t.internalId}-to`, label: t.label, "show-label": !1, "is-active": t.toOpen, "use-form-field-styling": t.useFormFieldStyling, "show-input-border": t.showInputBorder, clearable: t.clearable, required: t.required, invalid: t.invalid, disabled: t.disabled, "show-error-icon": t.showErrorIcon, "error-message": t.errorMessage, "set-focus-on-active": t.setFocusOnActive, "use-fade-out": t.useFadeOutTo }, on: { "update:is-active": function(a) {
    return t.isActiveHandler("to", a);
  } }, scopedSlots: t._u([{ key: "input", fn: function() {
    return [e("div", { staticClass: "base-date-input__datepicker" }, [e("DatePicker", { attrs: { placeholder: t.isToTimeField ? t.placeholder.time : t.placeholder.date, clearable: !1, "append-to-body": !1, lang: t.lang[t.language], open: t.toOpen, type: t.isToTimeField ? "time" : t.minDateView, format: t.isToTimeField ? "HH:mm" : t.datePickerValueFormat, "value-type": t.isToTimeField ? "format" : t.datePickerValueFormat, "input-class": "base-date-input__datepicker-input" }, on: { pick: function(a) {
      return t.datePicked("to");
    }, change: function(a) {
      t.isToTimeField && t.closeTimePicker("to", ...arguments, a);
    } }, nativeOn: { click: function(a) {
      return a.preventDefault(), t.onInputClick.apply(null, arguments);
    } }, scopedSlots: t._u([{ key: "input", fn: function() {
      return [e("input", t._g({ ref: "inputTo", class: ["base-date-input__input", t.inputClass], attrs: { id: `input-${t.internalId}-to`, placeholder: t.isToTimeField ? t.placeholder.time ?? t.placeholder : t.placeholder.date ?? t.placeholder, type: "text", "aria-describedby": t.label + "-to-" + t.internalId, "aria-required": t.required.toString(), "aria-invalid": t.invalid.toString(), required: t.required, disabled: t.disabled, "aria-disabled": t.disabled, enterkeyhint: "done", autocomplete: "off" }, domProps: { value: t.inputTo }, on: { input: function(a) {
        return t.checkDate(a, "To");
      }, keydown: function(a) {
        return t.handleInputKeydown(a, "To");
      }, blur: function(a) {
        return t.onInputBlur(a, "to");
      } } }, t.dateInputListeners))];
    }, proxy: !0 }, { key: "icon-calendar", fn: function() {
      return [e("div", { staticClass: "base-date-input__icon-wrapper" })];
    }, proxy: !0 }], null, !1, 3653295570), model: { value: t.inputTo, callback: function(a) {
      t.inputTo = a;
    }, expression: "inputTo" } })], 1)];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [t.showIcons ? e("BaseIcon", { staticClass: "base-date-input__date-icon", attrs: { name: t.isToTimeField ? "clock" : "calendar-many" }, on: { click: function(a) {
      a.stopPropagation(), t.toOpen = !t.toOpen;
    } } }) : t._e()];
  }, proxy: !0 }], null, !1, 2854381090), model: { value: t.inputTo, callback: function(a) {
    t.inputTo = a;
  }, expression: "inputTo" } }, t.inputListeners)) : t._e()], 2)], 2), t._t("post-input-field")], 2), e("div", { staticClass: "base-date-input__below" }, [t._t("below-input")], 2)]);
}, v = [], _ = /* @__PURE__ */ I(
  $,
  y,
  v,
  !1,
  null,
  "6e138743",
  null,
  null
);
const B = _.exports;
export {
  B as default
};
//# sourceMappingURL=BaseDateInput.vue.es.js.map
