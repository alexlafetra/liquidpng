<!-- @author Kyles Light -->
<!-- @email kuilin@yangqianguan.com -->
<!-- @date 2018-07-03 15:47:19.191 -->
<!-- @desc generated by yqg-cli@0.2.2 -->

<template>

    <div class="b-select-cascader">
        <div
            v-b-click-outside="closeMenu"
            :class="{'disabled': disabled, 'b-resettable': canBeReset}"
            class="b-select">
            <b-input
                ref="input"
                :name="name"
                :value="hint"
                :disabled="disabled"
                :placeholder="placeholder"
                type="text"
                @input="onInput"
                @focus="onInput"
                @keydown="handleKeyDown">
                <i
                    slot="right"
                    :class="{'b-select-icon-active': menuOpen}"
                    class="b-right-icon b-icon-arrow-bottom"
                    @click="reset"></i>
            </b-input>

            <b-popper :visible="menuOpen">
                <b-select-cascader-menu
                    v-if="showSelectMenu"
                    ref="menu"
                    :list="list"
                    :value="selectedList"
                    :search-text="hint"
                    :enable-emit-list="options.enableEmitList"
                    @choose="choose"/>

                <div v-else>
                    <b-select-menu
                        ref="menu"
                        :map="filterMap"
                        :value="searchText"
                        @choose="chooseFilter"/>
                </div>
            </b-popper>
        </div>
    </div>

</template>

<script type="text/babel">

import KeyCodeMap from '../../util/keyCodeMap';
import BSelectMenu from '../b-select/b-select-menu.vue';

import {
    getSelectedListFromSingleValue,
    getSelectedListFromListValue,
    getValueFilterMap
} from './helper/helper';
import BSelectCascaderMenu from './b-select-cascader-menu.vue';
import {escapeRegExp} from '../../util/RegExp';

export default {
    name: 'BSelectCascader',

    components: {BSelectCascaderMenu, BSelectMenu},

    model: {
        prop: 'value',
        event: 'change'
    },

    props: {
        value: {
            type: null,
            required: true
        },
        list: {
            type: Array,
            required: true
        },
        options: {
            type: Object,
            default: () => ({})
        },
        name: {
            type: String,
            default: ''
        },
        placeholder: {
            type: String,
            default: ''
        },
        disabled: {
            type: Boolean,
            default: false
        },
        enableReset: {
            type: Boolean,
            default: true
        },
        enableSelectNonLeaf: {
            type: Boolean,
            default: false
        }
    },

    data() {
        return {
            menuOpen: false,
            searchText: null,
            selectedList: [],
            originFilterMap: {}
        };
    },

    computed: {
        filterMap() {
            const {originFilterMap, searchText} = this;
            if (!searchText) return originFilterMap;

            const selectedReg = new RegExp(escapeRegExp(searchText), 'i');
            return Object.entries(originFilterMap)
                .filter(pair => selectedReg.test(pair[1]))
                .reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {});
        },

        canBeReset() {
            const {enableReset, selectedText, disabled} = this;
            return !disabled && enableReset && !!selectedText;
        },

        selectedText() {
            const {selectedList} = this;

            return selectedList.filter(({label}) => !!label).map(({label}) => label).join('/');
        },

        hint() {
            const {searchText, selectedText} = this;
            return searchText === null ? selectedText : searchText;
        },

        showSelectMenu() {
            return !this.searchText;
        }
    },

    watch: {
        value(val) {
            this.updateInnerState(this.list, val);
        },

        list(val) {
            this.updateInnerState(val, this.value);
        }
    },

    mounted() {
        this.updateInnerState(this.list, this.value);
    },

    methods: {
        updateInnerState(list, value) {
            const {options: {enableEmitList = false}} = this;
            const selectedList = enableEmitList
                ? getSelectedListFromListValue(list, value)
                : getSelectedListFromSingleValue(list, value);

            this.selectedList = selectedList;
            this.originFilterMap = getValueFilterMap(list, enableEmitList);
        },

        onInput(value) {
            this.searchText = value;
            this.openMenu();
        },

        openMenu() {
            this.menuOpen = true;
        },

        closeMenu() {
            const {$refs: {input}} = this;
            this.searchText = null;

            if (this.menuOpen && input) {
                this.menuOpen = false;
                input.blur();
            }
        },

        reset() {
            const {disabled} = this;
            if (disabled) return;

            this.$emit('change', null);
            this.closeMenu();
        },

        choose(selectedList, {confirm}) {
            const vm = this;
            const {options: {enableEmitList = false}, enableSelectNonLeaf} = vm;

            const leafItem = selectedList[selectedList.length - 1];

            // if is leaf item or confirm close, close menu
            const closeFlag = !leafItem.children || !leafItem.children.length || (enableSelectNonLeaf && confirm);

            if (closeFlag) {
                vm.closeMenu();
            }

            if (enableEmitList && closeFlag) {
                vm.$emit('change', selectedList.map(({value}) => (value)));
                return;
            }

            // when enableEmitList is false, emit change only if closeFlag is true
            if (closeFlag) {
                vm.$emit('change', leafItem.value);
            }
        },

        chooseFilter(value) {
            try {
                this.choose(JSON.parse(value), {confirm: true});
            } catch (err) {
                // ignore err
            }

            this.searchText = null;
        },

        handleKeyDown(TargetValue, {keyCode}) {
            const vm = this;
            const {$refs: {menu}, menuOpen, selectedText} = vm;

            switch (keyCode) {
                case KeyCodeMap.up:
                case KeyCodeMap.down: {
                    if (!menuOpen) {
                        vm.searchText = selectedText;
                        vm.openMenu();
                    }
                    if (menu) menu.handleKeyDown(keyCode);

                    break;
                }
                case KeyCodeMap.left:
                case KeyCodeMap.right: {
                    if (menu) menu.handleKeyDown(keyCode);
                    break;
                }
                case KeyCodeMap.tab:
                case KeyCodeMap.esc: {
                    vm.closeMenu();
                    break;
                }
                case KeyCodeMap.enter: {
                    if (!menuOpen) {
                        vm.searchText = selectedText;
                        vm.openMenu();
                    }
                    if (menu) menu.handleKeyDown(keyCode);

                    break;
                }
                default: // ignore
            }
        }
    }
};

</script>

