import { createId as s } from "../../utils/utils.es.js";
import o from "../../directives/InsertTextAsHtml.es.js";
import "./BaseChip.vue.es2.js";
import a from "../../_virtual/_plugin-vue2_normalizer.es.js";
const r = {
  name: "BaseChip",
  components: {
    BaseHoverBox: () => import("../BaseHoverBox/BaseHoverBox.vue.es.js"),
    BaseIcon: () => import("../BaseIcon/BaseIcon.vue.es.js")
  },
  directives: {
    insertTextAsHtml: o
  },
  model: {
    prop: "entry",
    event: "value-changed"
  },
  props: {
    /**
     * pass the text for the chip
     */
    entry: {
      type: String,
      required: !0
    },
    /**
     * set if entry is a linked data entry and displayed with grey background
     */
    isLinked: {
      type: Boolean,
      default: !0
    },
    /**
     * if a hover box is associated with the chip add all relevant properties here
     * (see [BaseHoverBox](BaseHoverBox) for details)
     *
     * **CAVEAT**: this prop is deprecated and will be removed in the next major version!
     * Usage not recommended!
     * Have a look into [BaseTooltipBox](BaseTooltipBox) for implementing a similar functionality
     */
    hoverBoxContent: {
      type: Object,
      default: () => ({})
    },
    /**
     * set chip active (set color)
     */
    chipActive: {
      type: Boolean,
      default: !1
    },
    /**
     * flag to specify if chip can be removed
     */
    isRemovable: {
      type: Boolean,
      default: !0
    },
    /**
     * add some custom text styling
     */
    textStyling: {
      type: Object,
      default: () => ({})
    },
    /**
     * define true if chip should be editable on click
     *
     * **Caveat**: chips can not show `hoverBoxContent` as soon as it is editable
     * respectively - if both are set `true` edit functionality takes precedent - chip will
     *  not be draggable, `hoverBoxContent` will not be shown!
     */
    editable: {
      type: Boolean,
      default: !1
    },
    /**
     * text read when a chip is focused - currently only available with prop
     *  `editable` true
     */
    assistiveText: {
      type: String,
      default: ""
    },
    /**
     * if necessary chip text can be rendered as html
     *  this feature is currently only available if the chip is not editable
     *
     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use
     *    this prop on trusted content and never on user-provided content.
     */
    interpretTextAsHtml: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      /**
       * internal represenation of string provided by parent
       * @type {string}
       */
      entryInt: "",
      /**
       * handle showing of HoverBox
       * @type {boolean}
       */
      showInfoBox: !1
    };
  },
  computed: {
    hoverBoxEnabled() {
      return this.isLinked && !!Object.keys(this.hoverBoxContent).length;
    },
    internalId() {
      return s();
    }
  },
  watch: {
    entry: {
      handler(t) {
        t !== this.entryInt && (this.entryInt = t);
      },
      immediate: !0
    }
  },
  methods: {
    /**
     * update the internal text variable if chip is editable and
     * inform parent
     * @param {KeyboardEvent} event
     */
    updateText(t) {
      const e = t.target.innerText;
      this.editable && e !== this.entryInt && (this.entryInt = e, this.$emit("value-changed", this.entryInt));
    },
    clickAction(t) {
      this.editable || (t.stopPropagation(), this.$emit("clicked"), this.isLinked && (this.$emit("hoverbox-active", !0), this.$refs.hoverBox.setPosition(t), this.showInfoBox = !this.showInfoBox));
    },
    moveBox(t) {
      this.hoverBoxEnabled && this.showInfoBox && this.$refs.hoverBox.setPosition(t);
    },
    hideBox() {
      this.hoverBoxEnabled && (this.$emit("hoverbox-active", !1), this.showInfoBox = !1);
    },
    onMouseDown(t) {
      this.$emit("mouse-down", t);
    },
    removeClicked() {
      this.$emit("remove-entry", this.entryInt);
    }
  }
};
var l = function() {
  var e = this, n = e._self._c;
  return n("div", { class: [
    "base-chip",
    { "base-chip__removable": e.isRemovable },
    { "base-chip__linked": e.isLinked },
    { "base-chip__active": e.chipActive }
  ] }, [n("div", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: e.entryInt, interpretTextAsHtml: e.interpretTextAsHtml && !e.editable }, expression: "{ value: entryInt, interpretTextAsHtml: interpretTextAsHtml && !editable }" }], ref: "chipText", staticClass: "base-chip__text", style: e.textStyling, attrs: { contenteditable: e.editable ? "true" : !1, "aria-labelledby": e.assistiveText ? `${e.internalId}_aria-label` : !1, enterkeyhint: "search" }, on: { blur: e.updateText, keydown: function(i) {
    return !i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : (i.preventDefault(), e.updateText.apply(null, arguments));
  }, click: function(i) {
    return i.stopPropagation(), e.clickAction.apply(null, arguments);
  }, mousedown: e.onMouseDown, mousemove: e.moveBox, mouseleave: e.hideBox } }), e.assistiveText ? n("span", { staticClass: "hide", attrs: { id: `${e.internalId}_aria-label` } }, [e._v(" " + e._s(e.assistiveText) + " ")]) : e._e(), e.isRemovable ? n("BaseIcon", { staticClass: "base-chip__icon", attrs: { name: "remove" }, nativeOn: { click: function(i) {
    return i.stopPropagation(), e.removeClicked.apply(null, arguments);
  } } }) : e._e(), n("base-hover-box", e._b({ ref: "hoverBox", class: { "base-chip__hover-box__hidden": !e.hoverBoxEnabled || !e.showInfoBox } }, "base-hover-box", e.hoverBoxContent, !1))], 1);
}, h = [], c = /* @__PURE__ */ a(
  r,
  l,
  h,
  !1,
  null,
  "139a945d",
  null,
  null
);
const v = c.exports;
export {
  v as default
};
//# sourceMappingURL=BaseChip.vue.es.js.map
