import m from "../../directives/InsertTextAsHtml.es.js";
import b from "../BaseBox/BaseBox.vue.es.js";
import g from "../BaseIcon/BaseIcon.vue.es.js";
import "./BaseImageBox.vue.es2.js";
import c from "../../_virtual/_plugin-vue2_normalizer.es.js";
const x = {
  name: "BaseImageBox",
  components: {
    BaseBox: b,
    BaseIcon: g,
    BaseCheckmark: () => import("../BaseCheckmark/BaseCheckmark.vue.es.js").then((t) => t.default || t),
    BaseImage: () => import("../BaseImage/BaseImage.vue.es.js").then((t) => t.default || t),
    BaseImageGrid: () => import("../BaseImageGrid/BaseImageGrid.vue.es.js").then((t) => t.default || t)
  },
  directives: {
    insertTextAsHtml: m
  },
  props: {
    /**
     * The title of the item in question (max 2 lines), also used as img alt text
     */
    title: {
      type: String,
      default: "No title"
    },
    /**
     * specify a separate title to display on title hover and for the
     *  image alt text. Useful for example if `interpretTextAsHtml` is
     *  set `true` and the `title` contains HTML
     */
    altTitle: {
      type: String,
      default: ""
    },
    /**
     * Text displayed directly below title (max two lines; max 3 lines with title)
     */
    subtext: {
      type: String,
      default: ""
    },
    /**
     * specify a separate subtext to display on subtext hover. Useful for example
     *  if `interpretTextAsHtml` is set `true` and the `subtext` contains HTML
     */
    altSubtext: {
      type: String,
      default: ""
    },
    /**
     * should the title be displayed or box only display the image
     */
    showTitle: {
      type: Boolean,
      default: !0
    },
    /**
     * should the title be displayed on box hover
     */
    showTitleOnHover: {
      type: Boolean,
      default: !1
    },
    /**
     * define the number of rows before the title is truncated with ...
     *
     * **auto**: If subtext is defined, the title is displayed in one row, otherwise in two rows.
     * **1**: Title is displayed in one row.
     */
    titleRows: {
      type: [String, Number],
      default: "auto",
      validator: (t) => ["auto", 1].includes(t)
    },
    /**
     * define a url to a single image
     *
     * data variants to render a single image using `src` or `srcset` for a responsive image:
     * **src**: `'path'`
     * **srcset**: `{ '640w': 'path' }`
     */
    imageUrl: {
      type: [String, Object],
      default: null
    },
    /**
     * define up to 4 image url to be displayed in a grid
     *
     * array variants to render a single image using `src` or `srcset` for a responsive image:
     * **src**: `['path']`
     * **srcset**: `[{ '640w': 'path' }]`
     */
    images: {
      type: Array,
      default: () => []
    },
    /**
     * display shadow overlays at the top and bottom of the image
     * to make text easier to read
     */
    imageShadow: {
      type: Boolean,
      default: !0
    },
    /**
     * define the margin (left, bottom, right) between the image footer and the image
     * @values large, small
     */
    imageFooterMargin: {
      type: String,
      default: "large",
      validator: (t) => ["large", "small"].includes(t)
    },
    /**
     * descriptive element displayed at bottom of box (e.g. item type like "Bilderserie")
     */
    description: {
      type: String,
      default: null
    },
    /**
     * descriptive element displayed at bottom of box (e.g. item type like "Bilderserie")
     */
    additional: {
      type: String,
      default: null
    },
    /**
     * set optional icon
     * e.g. for items without image
     */
    icon: {
      type: String,
      default: ""
    },
    /**
     * set optional icon size
     */
    iconSize: {
      type: String,
      default: "xxlarge",
      validator: (t) => ["small", "medium", "large", "xlarge", "xxlarge"].includes(t)
    },
    /**
     * display play icon
     * e.g. for Video, Audio files
     */
    playIcon: {
      type: Boolean,
      default: !1
    },
    /**
     * determines if the box should be selectable and the checkbox is displayed
     */
    selectable: {
      type: Boolean,
      default: !1
    },
    /**
     * set prop true if box can be dragged - used solely for styling purposes
     */
    draggable: {
      type: Boolean,
      default: !1
    },
    /**
     * set select status (checkbox checked) from outside
     */
    selected: {
      type: Boolean,
      default: !1
    },
    /**
     * specify the size of the box
     */
    boxSize: {
      type: Object,
      default: () => ({ width: "auto", height: "auto" })
    },
    /**
     * specify any text that should be displayed instead of an image;
     * each array element on new line
     */
    boxText: {
      type: Array,
      default: () => []
    },
    /**
     * specify lazy image loading
     */
    lazyload: {
      type: Boolean,
      default: !1
    },
    /**
     * specify position of image
     */
    imageFirst: {
      type: Boolean,
      default: !1
    },
    /**
     * specify if header should be centered horizontally
     * (aligned left otherwise)
     */
    centerHeader: {
      type: Boolean,
      default: !1
    },
    /**
     * define html element that should be rendered
     */
    renderElementAs: {
      type: String,
      default: "div"
    },
    /**
     * if element is rendered as vue link component, specify a value for the `to` attribute
     * can either be a string or a `vue-router` Location object (= object with `path` property
     * and optional `params` or `query` object)
     * (this needs vue-router)
     */
    linkTo: {
      type: [String, Object],
      default: "",
      validator: (t) => typeof t == "string" || t instanceof Object && Object.keys(t).includes("path")
    },
    /**
     * if necessary box text (`title`, `subtext`, `boxText`) can
     *  be rendered as html
     *
     *  *tip*: do not forget to set prop `altTitle` and/or `altSubtext` if the
     *    title text or subtext contains html - otherwise the complete html will
     *    be displayed on text hover and for image alt text
     *
     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use
     *    this prop on trusted content and never on user-provided content.
     */
    interpretTextAsHtml: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      /**
       * internal variable for selection status
       */
      selectedInt: !1,
      /**
       * needed to set text height and line-clamp correctly after resize
       */
      boxTextStyle: {},
      /**
       * steer displaying of image in case of display error
       */
      displayImage: !0,
      /**
       * timeout variable to only do height calculations after certain time
       */
      resizeTimeout: null
    };
  },
  computed: {
    /**
     * compute the alt title used for title hover and image alt description
     *  from specific prop `altTitle` or use the regular title
     * @returns {string}
     */
    altTitleInt() {
      return this.altTitle || this.title;
    },
    /**
     * compute the alt subtext used for subtext hover
     *  from specific prop `altSubtext` or use the regular subtext
     * @returns {string}
     */
    altSubtextInt() {
      return this.altSubtext || this.subtext;
    },
    // determine if a shadow at the top of the image should be visible
    imageShadowTop() {
      return this.selectable && this.hasImages && !this.showTitle || this.selectable && this.hasImages && this.imageFirst;
    },
    // determine if a shadow at the bottom of the image should be visible
    imageShadowBottom() {
      return this.imageShadow && !this.icon && (!this.showTitleOnHover || this.showTitleOnHover && this.additional);
    },
    // determine if there is one or more images to display
    hasImages() {
      return !!(this.imageUrl || this.images && this.images.length);
    }
  },
  watch: {
    // TODO: could probably just be added to boxSelect method?
    selectedInt(t) {
      t !== this.selected && this.$emit("select-triggered", t);
    },
    selected(t) {
      this.selectedInt !== t && (this.selectedInt = t);
    },
    boxText() {
      this.calcTextHeight();
    }
  },
  mounted() {
    this.selectedInt = this.selected, window && window.addEventListener("resize", this.resizeTriggered), this.$nextTick(() => {
      this.calcTextHeight();
    });
  },
  destroyed() {
    window.removeEventListener("resize", this.resizeTriggered);
  },
  methods: {
    boxSelect() {
      this.selectable ? this.selectedInt = !this.selectedInt : this.$emit("clicked");
    },
    resizeTriggered() {
      this.resizeTimeout && (clearTimeout(this.resizeTimeout), this.resizeTimeout = null), this.resizeTimeout = setTimeout(() => {
        this.calcTextHeight();
      }, 500);
    },
    calcTextHeight() {
      if (!this.imageUrl && this.boxText.length && this.$refs.baseBox && this.$refs.boxText) {
        let t = 0;
        if (this.$refs.headerBox) {
          const r = this.$refs.headerBox, _ = r.clientHeight, d = r.offsetTop;
          t = _ + 2 * d;
        }
        const e = this.$refs.boxText, a = this.$refs.boxTextInner[0] || this.$refs.boxTextInner, s = this.$refs.baseBox.$el.clientHeight, i = window.getComputedStyle(a, null).getPropertyValue("line-height").replace("px", ""), n = window.getComputedStyle(e, null).getPropertyValue("margin-bottom").replace("px", "");
        let o = s - t - n;
        this.description && (o -= i);
        const l = Math.floor(o / i);
        this.boxTextStyle = {
          height: `${i * l}px`,
          "-webkit-line-clamp": l
        };
      }
    },
    /**
     * get single src
     *
     * @param {string|object} data
     * @returns {string}
     */
    src(t) {
      return typeof t == "string" ? t : Object.entries(t).slice(-1)[0][1];
    },
    /**
     * get srcset
     *
     * @param {array} data
     * @returns {array}
     */
    srcset(t) {
      return typeof t == "object" ? [t] : [];
    }
  }
};
var h = function() {
  var e = this, a = e._self._c;
  return a("BaseBox", { ref: "baseBox", attrs: { "box-size": e.boxSize, "render-element-as": e.renderElementAs, "additional-attributes": e.linkTo ? { to: e.linkTo } : {}, "box-ratio": "100" }, on: { clicked: e.boxSelect } }, [a("div", { class: [
    "base-image-box",
    { "base-image-box--hover": (e.playIcon || e.showTitleOnHover) && !e.selectable },
    { "base-image-box--hover-show-title": e.showTitleOnHover && !e.selectable },
    { "base-image-box--selectable": e.selectable },
    { "base-image-box--draggable": e.draggable },
    // needs to be after selectable
    { "base-image-box--selected": e.selectable && e.selectedInt }
  ] }, [e.showTitle ? a("div", { ref: "headerBox", class: [
    "base-image-box__header",
    { "base-image-box__header--bottom": e.imageFirst },
    { "base-image-box__header--center-text": e.centerHeader },
    { "base-image-box__header--separator-top": !e.hasImages && !e.imageShadow && e.imageFirst },
    { "base-image-box__header--separator-bottom": !e.hasImages && !e.imageShadow && !e.imageFirst }
  ] }, [a("div", { staticClass: "base-image-box__header__row" }, [a("div", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: e.title, interpretTextAsHtml: e.interpretTextAsHtml }, expression: "{ value: title, interpretTextAsHtml }" }], class: [
    "base-image-box__header__text",
    "base-image-box__header__text--bold",
    { "base-image-box__header__text--2-lines": !e.subtext && e.titleRows === "auto" }
  ], attrs: { title: e.altTitleInt } }), e.$slots["title-right"] ? a("div", { staticClass: "base-image-box__header__row__additional" }, [e._t("title-right")], 2) : e._e()]), e.subtext ? a("div", { staticClass: "base-image-box__header__row" }, [a("div", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: e.subtext, interpretTextAsHtml: e.interpretTextAsHtml }, expression: "{ value: subtext, interpretTextAsHtml }" }], staticClass: "base-image-box__header__text", attrs: { title: e.altSubtextInt } })]) : e._e()]) : e._e(), a("div", { class: [
    "base-image-box__body",
    { "base-image-box__body__shadow--top": e.imageShadowTop },
    { "base-image-box__body__shadow--bottom": e.imageShadowBottom },
    { "base-image-box__body__shadow--height-1-3": e.imageShadow && e.imageFirst },
    { "base-image-box__body__shadow--height-1-2": e.imageShadow && !e.imageFirst }
  ] }, [(e.imageUrl || e.images.length) && e.displayImage ? [e.imageUrl || e.images && e.images.length === 1 ? a("BaseImage", { ref: "image", class: ["base-image-box__body__image"], attrs: { alt: e.altTitleInt, lazyload: e.lazyload, src: e.images && e.images.length === 1 ? e.src(e.images[0]) : e.src(e.imageUrl), srcset: e.images && e.images.length === 1 ? e.srcset(e.images[0]) : e.srcset(e.imageUrl) }, on: { error: function(s) {
    e.displayImage = !1;
  } } }) : e._e(), e.images && e.images.length > 1 ? a("BaseImageGrid", { attrs: { alt: e.altTitleInt, images: e.images, lazyload: e.lazyload } }) : e._e()] : e._e(), e.icon || e.$slots.icon ? a("div", { class: [
    "base-image-box__body__icon",
    "base-image-box__icon",
    "base-image-box__icon--" + e.iconSize
  ] }, [e._t("icon", function() {
    return [a("BaseIcon", { class: [
      "base-image-box__icon",
      "base-image-box__icon--" + e.iconSize
    ], attrs: { name: e.icon } })];
  }, { icon: e.icon })], 2) : e._e(), e.playIcon ? a("BaseIcon", { class: [
    "base-image-box__body__icon",
    "base-image-box__icon",
    "base-image-box__icon--play",
    "base-image-box__icon--" + e.iconSize
  ], attrs: { name: "play" } }) : e._e(), !e.hasImages || !e.displayImage ? a("div", { ref: "boxText", staticClass: "base-image-box__body__text" }, [e._t("text", function() {
    return [a("div", { ref: "boxTextInner", staticClass: "base-image-box__body__text__inner", style: e.boxTextStyle }, e._l(e.boxText, function(s, i) {
      return a("div", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: s, interpretTextAsHtml: e.interpretTextAsHtml }, expression: "{ value: entry, interpretTextAsHtml }" }], key: i });
    }), 0)];
  }, { text: e.boxText })], 2) : e._e(), a("div", { class: [
    "base-image-box__body__footer",
    "base-image-box__body__footer--position-margin-" + e.imageFooterMargin,
    { "base-image-box__body__footer--invert": e.icon }
  ] }, [e.$slots["footer-left"] ? a("div", { staticClass: "base-image-box__body__footer__left" }, [e._t("footer-left")], 2) : e._e(), a("div", { staticClass: "base-image-box__body__footer__center" }, [e.showTitleOnHover ? a("div", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { interpretTextAsHtml: e.interpretTextAsHtml, value: e.title }, expression: "{ interpretTextAsHtml, value: title }" }], staticClass: "base-image-box__body__footer__title base-image-box__body__footer--bold", attrs: { title: e.altTitleInt } }) : e._e(), e.description ? a("div", { class: [
    "base-image-box__body__footer__text",
    { "base-image-box__body__footer__text--bold": !e.additional }
  ], attrs: { title: e.description } }, [e._v(" " + e._s(e.description) + " ")]) : e._e(), e.additional ? a("div", { class: [
    "base-image-box__body__footer__text",
    "base-image-box__body__footer__text--bold"
  ], attrs: { title: e.additional } }, [e._v(" " + e._s(e.additional) + " ")]) : e._e()]), e.$slots["footer-right"] || e.playIcon ? a("div", { staticClass: "base-image-box__body__footer__right" }, [e.playIcon ? a("BaseIcon", { class: [
    "base-image-box__icon",
    "base-image-box__icon--small",
    "base-image-box__icon--play"
  ], attrs: { name: "play" } }) : e._e(), e._t("footer-right")], 2) : e._e()])], 2), a("div", { staticClass: "base-image-box__features" }, [a("transition", { attrs: { name: "slide-fade" } }, [e.selectable ? a("BaseCheckmark", { staticClass: "base-image-box__checkbox", attrs: { checked: e.selectedInt, label: e.altTitleInt, "mark-style": "checkbox", "check-box-size": "large" }, on: { clicked: e.boxSelect } }) : e._e()], 1)], 1)])]);
}, u = [], f = /* @__PURE__ */ c(
  x,
  h,
  u,
  !1,
  null,
  "da1aaa42",
  null,
  null
);
const w = f.exports;
export {
  w as default
};
//# sourceMappingURL=BaseImageBox.vue.es.js.map
