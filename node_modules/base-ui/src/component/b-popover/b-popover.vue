<template>
    <div>
        <transition @after-leave="doDestroy">
            <span
                v-show="!disabled && showPopper"
                ref="popover"
                :class="{'in-dialog': isInBDialog||!isInContent}"
                class="b-popover-wrap">
                <slot></slot>
            </span>
        </transition>
        <slot name="reference"></slot>
    </div>
</template>

<script>

import {createPopper} from '@popperjs/core';
import BDialog from '../b-dialog';
import {isValidPlacement} from './helper/helper';

const on = (element, event, handler) => {
    if (element && event && handler) {
        element.addEventListener(event, handler, false);
    }
};

const off = (element, event, handler) => {
    if (element && event && handler) {
        element.removeEventListener(event, handler, false);
    }
};

export default {
    name: 'BPopover',

    props: {
        disabled: {
            type: Boolean,
            default: false
        },

        visible: {
            type: Boolean,
            default: false
        },

        placement: {
            type: String,
            validator: isValidPlacement,
            default: 'bottom-start'
        }
    },
    data() {
        return {
            popperJS: null,
            showPopper: false,
            appendedToBody: false,
            popperOptions: {
                placement: 'bottom',
                // strategy: 'fixed',
                computeStyle: {
                    gpuAcceleration: false
                }
            },
            referenceElm: {},
            popper: {},
            isInContent: true
        };
    },
    computed: {
        isInBDialog() {
            const vm = this;

            let isInDialog = false;
            const rec = ({$parent}) => {
                if (!$parent) return;

                if ($parent.$options.name === BDialog.name) {
                    isInDialog = true;
                    return;
                }

                rec($parent);
            };

            rec(vm);

            return isInDialog;
        }
    },
    watch: {
        showPopper() {
            this.updatePopper();
        },

        visible(value) {
            this.showPopper = value;
        },

        disabled(value) {
            if (value) {
                this.showPopper = false;
            }
        }
    },

    created() {
        const {placement, popperOptions} = this;
        this.popperOptions = Object.assign(popperOptions, {placement});
    },

    mounted() {
        this.referenceElm = this.$slots.reference ? this.$slots.reference[0].elm : this.$parent.$el;
        this.popper = this.$slots.default[0].elm;
        if (this.$slots.reference) {
            on(this.referenceElm, 'click', this.doShow);
        }
        on(document, 'click', this.handleDocumentClick);
        const content = document.querySelector('.b-layout-content');
        if (content) {
            this.isInContent = content.contains(this.$el);
        }
    },

    destroyed() {
        this.destroyPopper();
    },

    methods: {
        doShow() {
            this.showPopper = true;
        },

        doClose() {
            this.showPopper = false;
        },

        doDestroy() {
            if (this.showPopper) {
                return;
            }

            if (this.popperJS) {
                this.popperJS.destroy();
                this.popperJS = null;
            }
            if (this.appendedToBody) {
                this.appendedToBody = false;
                document.body.removeChild(this.popper.parentElement);
            }
        },

        destroyPopper() {
            off(this.referenceElm, 'click', this.doShow);
            off(document, 'click', this.handleDocumentClick);

            this.showPopper = false;
            this.doDestroy();
        },

        handleDocumentClick({target}) {
            if (!this.$el || !this.referenceElm
                || this.elementContains(this.$el, target)
                || this.elementContains(this.referenceElm, target)
                || !this.popper || this.elementContains(this.popper, target)
            ) {
                return;
            }
            this.showPopper = false;
        },

        elementContains(elm, otherElm) {
            if (typeof elm.contains === 'function') {
                return elm.contains(otherElm);
            }

            return false;
        },

        updatePopper() {
            if (this.popperJS) {
                this.popperJS.update();
                return;
            }
            this.createPopper();
        },

        createPopper() {
            this.$nextTick(() => {
                if (this.popperJS && this.popperJS.destroy) {
                    this.popperJS.destroy();
                }
                if (!this.appendedToBody) {
                    this.appendedToBody = true;
                    document.body.appendChild(this.popper.parentElement);
                }
                this.popperJS = createPopper(this.referenceElm, this.popper, this.popperOptions);
            });
        }

    }
};
</script>

<style lang="scss" scoped>
</style>
