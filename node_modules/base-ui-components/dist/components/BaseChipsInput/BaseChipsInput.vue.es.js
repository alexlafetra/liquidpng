import { createId as s, highlightText as l } from "../../utils/utils.es.js";
import o from "../../directives/InsertTextAsHtml.es.js";
import r from "../BaseIcon/BaseIcon.vue.es.js";
import { ref as a } from "vue";
import { useAnnouncer as p } from "../../composables/useAnnouncer.es.js";
import u from "../BaseChipsInputField/BaseChipsInputField.vue.es.js";
import d from "../../mixins/i18n.es.js";
import c from "../../mixins/navigateList.es.js";
import "./BaseChipsInput.vue.es2.js";
import h from "../../_virtual/_plugin-vue2_normalizer.es.js";
const f = {
  name: "BaseChipsInput",
  components: {
    BaseIcon: r,
    BaseDropDownList: () => import("../BaseDropDownList/BaseDropDownList.vue.es.js").then((e) => e.default || e),
    BaseChipsInputField: u
  },
  directives: {
    insertTextAsHtml: o
  },
  mixins: [
    d,
    c
  ],
  model: {
    prop: "selectedList",
    event: "selected-changed"
  },
  props: {
    /**
     * list of selectable options. needs to be a list with at least an identifier and a label
     *  (properties can be set via `identifierPropertyName` and `labelPropertyName`)
     */
    list: {
      type: Array,
      default: () => []
    },
    /**
     * list of already selected options, displayed as chips
     *  needs to be a list with at least an identifier and a label
     *  (properties can be set via `identifierPropertyName` and `labelPropertyName`)
     */
    selectedList: {
      type: Array,
      default: () => []
    },
    /**
     * specify input field type
     * @values text, search
     */
    inputType: {
      type: String,
      default: "text",
      validator: (e) => ["text", "search"].includes(e)
    },
    /**
     * input field label
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * define if label should be visible
     */
    showLabel: {
      type: Boolean,
      default: !0
    },
    /**
     * input field placeholder
     */
    placeholder: {
      type: String,
      default: null
    },
    /**
     * message displayed when no selectable options are available
     */
    dropDownNoOptionsInfo: {
      type: String,
      default: "No options available"
    },
    /**
     * define if the user can add an option that is not in the list
     */
    // can the user add Entries that are not available in the vocabulary (selectable list)
    allowUnknownEntries: {
      type: Boolean,
      default: !1
    },
    /**
     * define only a single or multiple options can be selected
     */
    // define if one or several entries can be selected from drop down menu
    allowMultipleEntries: {
      type: Boolean,
      default: !0
    },
    /**
     * define if selectable list options should be fetched every time or if the
     * list passed in the beginning is used
     */
    allowDynamicDropDownEntries: {
      type: Boolean,
      default: !1
    },
    /**
     * this prop was added because there was some action needed to be done before entry was added
     * so this is possible if entry is not added to `selectedList` directly but only in parent
     * component
     */
    addSelectedEntryDirectly: {
      type: Boolean,
      default: !0
    },
    /**
     * option to have the border of the input field not displayed
     */
    showInputBorder: {
      type: Boolean,
      default: !0
    },
    /**
     * if `true` a button with that functionality will be visible
     */
    sortable: {
      type: Boolean,
      default: !1
    },
    /**
     * define if chips should be draggable (currently only available for inline)
     */
    draggable: {
      type: Boolean,
      default: !1
    },
    /**
     * define if entries should always appear linked (-> with grey background)
     */
    alwaysLinked: {
      type: Boolean,
      default: !1
    },
    /**
     * set content for the info box activatable by click.
     * see [BaseHoverBox](BaseHoverBox) for more details
     */
    hoverboxContent: {
      type: Object,
      default: () => ({})
    },
    /**
     * show spinner to indicate that something is loading
     * (for dynamically fetched entries that need to do backend requests)
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * if sorting is enabled this will be the text shown in the button
     */
    sortText: {
      type: String,
      default: "Sort A â€“ Z"
    },
    /**
     * if `true` sorting will consider the last string in a label or if a comma is
     * present the string before the comma
     */
    sortName: {
      type: Boolean,
      default: !1
    },
    /**
     * set a language (ISO 639-1)
     */
    language: {
      type: String,
      default: ""
    },
    /**
     * set a chips text for adding a new chip.
     * (alternatively add a `form.Add` value to your localization files)
     * if allowUnknownEntries is true please add this in one form or another!
     */
    addNewChipText: {
      type: String,
      default: ""
    },
    /**
     if field is occuring more then once - set an id
     */
    id: {
      type: String,
      default: ""
    },
    /**
     * specify the object property that should be used as identifier
     */
    identifierPropertyName: {
      type: String,
      default: "id"
    },
    /**
     * specify the object property that should be used as value to be displayed
     */
    labelPropertyName: {
      type: String,
      default: "label"
    },
    /**
     * property for special case in component [BaseChipsBelow](BaseChipsBelow) - if `false` in this case chips will
     * not be displayed in the input field
     */
    displayChipsInline: {
      type: Boolean,
      default: !0
    },
    /**
     * mark as required field (currently only used for `aria-required` attribute)
     */
    required: {
      type: Boolean,
      default: !1
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field.
     * for an example see [BaseInput](BaseInput)
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * set `true` if input field should be disabled.
     * for an example see [BaseInput](BaseInput)
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * add an error message to be displayed below form field if field is invalid.
     * for an example see [BaseInput](BaseInput)
     */
    errorMessage: {
      type: String,
      default: ""
    },
    /**
     * define if error icon should be shown.
     * for an example see [BaseInput](BaseInput)
     */
    showErrorIcon: {
      type: Boolean,
      default: !1
    },
    /**
     * if `true` a remove icon (or a custom icon if slot `remove-icon` is used) will be shown allowing to remove
     * all input at once
     * for an example see [BaseInput](BaseInput)
     */
    clearable: {
      type: Boolean,
      default: !1
    },
    /**
     * specify additional input field styling
     */
    inputClass: {
      type: String,
      default: ""
    },
    /**
     * set `true` if chip should be editable on click
     *
     * **Caveat**: chips can not be both `draggable` AND `editable` and it can not show
     *  `hoverBoxContent` as soon as it is editable respectively - if both are set `true` edit
     *  functionality takes precedent - chip will not be draggable, `hoverBoxContent` will not
     *  be shown!
     */
    chipsEditable: {
      type: Boolean,
      default: !1
    },
    /**
     * set `true` if dropdown should be closed after selecting an option
     */
    closeDropdownOnOptionSelect: {
      type: Boolean,
      default: !1
    },
    /**
     * this prop gives the option to add assistive text for screen readers
     * properties:
     * **selectedOption**: text read when a selected option is focused (currently only
     *  working for editable chips)
     * **loaderActive**: text that is announced when results are being fetched (prop
     *  `isLoading` is set `true`)
     * **resultsRetrieved**: text that is announced when results were retrieved (drop down
     *  list changed)
     * **optionAdded**: text read when option was added to the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     * **optionToRemoveSelected**: text read when option is marked active for removal (by using
     *  backspace in empty input field). string {label} could be added to be replaced
     *  by the actual chip label (value in [`labelPropertyName`])
     * **optionRemoved**: text read when option was removed from the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     */
    assistiveText: {
      type: Object,
      default: () => ({
        selectedOption: "",
        loaderActive: "loading.",
        resultsRetrieved: "{number} options in drop down.",
        optionAdded: "option {label} added to selected list.",
        optionToRemoveSelected: "option {label} from selected list marked for removal. Press delete or backspace to remove.",
        optionRemoved: "option {label} removed."
      })
    },
    /**
     * define if selected options chips should come with a remove icon
     */
    chipsRemovable: {
      type: Boolean,
      default: !0
    },
    /**
     * define a default entry
     * will be added when component is mounted and selected list is initially empty
     * properties:
     * **label|*** `string`: the label of the default option - use the property name set via prop `labelPropertyName`
     * **id|*** `string?`: (optional) identifier of the default option - use the property name set via prop `identifierPropertyName`
     */
    defaultEntry: {
      type: [Object, null],
      default: null
    },
    /**
     * set this flag to `true` to highlight autocomplete option characters that match
     *  the current search input string
     *
     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use
     *    this prop on trusted content and never on user-provided content.
     */
    highlightStringMatch: {
      type: Boolean,
      default: !1
    },
    /**
     * if `highlightAutocompleteMatch` is set `true`
     *  provide tag names to style the matched characters
     *  (without '<' and '>', e.g. ['b'] for <b>)
     */
    highlightStringTags: {
      type: Array,
      default: () => []
    },
    /**
     * if necessary selected chip text can
     *  be rendered as v-html directive
     *
     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use
     *    this prop on trusted content and never on user-provided content.
     */
    interpretChipsLabelAsHtml: {
      type: Boolean,
      default: !1
    }
  },
  setup() {
    const e = a(null), { announcement: t } = p(e);
    return {
      chipsInput: e,
      announcement: t
    };
  },
  data() {
    return {
      /**
       * the current input field string
       * @type {string}
       */
      input: "",
      /**
       * internal representation of selected options list
       * @type {Object[]}
       */
      selectedListInt: [],
      /**
       * the currently active option, styled with grey background
       * (only if selected by keyboard)
       *
       * @type {number}
       */
      activeOptionIndex: 0,
      /**
       * the currently selected option after mouse click or keyboard enter
       *
       * @type {?Object}
       */
      selectedOption: null,
      /**
       * variable to store state of input field (for drop down handling)
       * @type {boolean}
       */
      chipsInputActive: !1,
      /**
       * the minimal width of the drop down element (calculated in js because ? )
       * TODO: above...
       * @type {string}
       */
      dropDownMinWidth: "100%",
      /**
       * the input element
       * @type {HTMLElement}
       */
      inputElem: null,
      /**
       * timeout for drop down options found announcer because otherwise
       * text not read if more than one character entered into input
       * @type {?number}
       */
      timeout: null
    };
  },
  computed: {
    /**
     * clean props from props not available in ChipsInputField component
     * (e.g. because they are only needed for drop down component)
     */
    chipsFieldInputProps() {
      const e = { ...this.$props, id: this.internalId };
      return delete e.dropDownNoOptionsInfo, delete e.allowDynamicDropDownEntries, delete e.addNewChipText, delete e.list, e;
    },
    /**
     * internal representation of options list, filtered for already selected entries
     * and also handling input string matching with options list in case of
     * no dynamic autocomplete fetching
     * @returns {Object[]}
     */
    listInt() {
      let e = [...this.list];
      return this.allowUnknownEntries && this.input && e.unshift({
        [this.labelPropertyName]: this.language ? { [this.language]: this.input } : this.input,
        // add an identifier here as well so this option can be recognized by the inputs
        // `aria-activedescendant` attribute
        [this.identifierPropertyName]: "createNew"
      }), this.selectedListInt && this.selectedListInt.length && (e = e.filter((t) => !this.selectedListInt.map((n) => n[this.identifierPropertyName] || n[this.labelPropertyName]).includes(t[this.identifierPropertyName] || t[this.labelPropertyName]))), this.input && !this.allowDynamicDropDownEntries ? e.filter((t) => this.getLangLabel(t[this.labelPropertyName]).toLowerCase().includes(this.input.toLowerCase())) : e;
    },
    /**
     * the currently active option object
     */
    activeOption: {
      /**
       * setter function of activeOption - will set active option index
       * @param {?Object} val - the active option (by hover or arrow key use)
       */
      set(e) {
        this.activeOptionIndex = this.listInt.indexOf(e);
      },
      /**
       * getter function for activeOption - determined by active option index
       * @returns {?Object}
       */
      get() {
        return this.listInt[this.activeOptionIndex];
      }
    },
    internalId() {
      return this.id || s();
    },
    /**
     * create an object out of prop `highlightStringTags` so it can be
     *  spread into the options of the `highlightText` function
     * @returns {{highlightTags: []}|{}}
     */
    highlightTags() {
      var e;
      return (e = this.highlightStringTags) != null && e.length ? { highlightTags: this.highlightStringTags } : {};
    }
  },
  watch: {
    /**
     * if the selected option changed (by click or keybord enter) add
     * it to the list of selected options
     * @param {?Object} val
     */
    selectedOption(e) {
      e && (this.addSelectedOption(e), this.inputElem && this.allowMultipleEntries && this.inputElem.focus());
    },
    listInt: {
      /**
       * watch listInt for changes to set the currently active option index
       * accordingly
       * @param {Object[]} val
       */
      handler(e) {
        e.length && !this.activeOption ? this.activeOptionIndex = 0 : !e.length && (!this.allowUnknownEntries || !this.input) && (this.activeOptionIndex = -1), this.chipsInputActive && !this.isLoading && !this.announcement && (this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.timeout = setTimeout(() => {
          this.chipsInputActive && this.assistiveText.resultsRetrieved && (e.length ? this.announcement = this.assistiveText.resultsRetrieved.replace("{number}", e.length) : this.announcement = this.dropDownNoOptionsInfo);
        }, 300));
      },
      immediate: !0
    },
    list: {
      /**
       * watch list to reset active option index
       * @param {Object[]} val
       */
      handler(e) {
        this.activeOptionIndex = e.length || this.allowUnknownEntries && this.input ? 0 : -1;
      },
      immediate: !0
    },
    selectedList: {
      /**
       * get changes to selectedListInt as soon as selectedList changes
       * @param {Object[]} val
       */
      handler(e) {
        this.selectedListInt = [...e];
      },
      immediate: !0
    },
    /**
     * watch for changes to selectedListInt and propagate to parent if necessary
     * @param {Object[]} val
     */
    selectedListInt(e) {
      JSON.stringify(e) !== JSON.stringify(this.selectedList) && this.updateParentSelectedList(e);
    },
    /**
     * input is watched for follow up actions needed after input
     * --> fetch autocomplete entries
     * --> inform parent of input (this however is not needed anymore since
     * $listeners from input are now propagated to parent anyways!)
     * @param {string} val
     */
    input(e) {
      this.allowDynamicDropDownEntries && this.$emit("fetch-dropdown-entries", { value: e, type: this.labelPropertyName });
    },
    /**
     * watching drop down active to do necessary actions once drop down opens
     * a) to fetch drop down entries for static drop downs on first show only
     * b) to calculate actual drop down width (TODO: do i need this?)
     * c) to inform parent of drop down state changes
     * @param {boolean} val
     */
    chipsInputActive(e) {
      e && !this.allowDynamicDropDownEntries && !this.listInt.length && this.$emit("fetch-dropdown-entries", { value: this.input, type: this.labelPropertyName }), e && (this.calcDropDownMinWidth(), this.activeOptionIndex = 0);
    }
  },
  mounted() {
    const e = this.$el.getElementsByTagName("input");
    e && e.length && ([this.inputElem] = e), this.defaultEntry && !this.selectedList.length && this.selectedListInt.push(this.defaultEntry);
  },
  methods: {
    /** CHIPS (ADDING) FUNCTIONALITIES */
    /**
     * method for adding a selected option to selected option list
     * (remove works via setter - does not need a separate method)
     *
     * @param {Object} selected
     */
    addSelectedOption(e) {
      const t = { ...e };
      this.allowUnknownEntries && t[this.identifierPropertyName] === "createNew" && delete t[this.identifierPropertyName], this.allowMultipleEntries ? this.selectedListInt.push(t) : (this.$set(this.selectedListInt, 0, t), this.chipsInputActive = !1), this.updateParentSelectedList(this.selectedListInt), this.assistiveText.optionAdded && (this.announcement = this.assistiveText.optionAdded.replace("{label}", t[this.labelPropertyName])), this.input = "", this.selectedOption = null, this.allowMultipleEntries || (this.chipsInputActive = !1, this.inputElem.blur()), setTimeout(() => {
        this.closeDropDown();
      }, 0);
    },
    /**
     * method for emitting selected list changes to parent
     * (called after adding or deleting an option to / from selected list)
     *
     * @param {Object[]} updatedList - the list that should be emitted in the event
     */
    updateParentSelectedList(e) {
      JSON.stringify(this.selectedList) !== JSON.stringify(e) && this.$emit("selected-changed", [...e]);
    },
    /** INPUT FIELD ACTIVE/INACTIVE HANDLING */
    /**
     * function triggered when input field was clicked
     */
    onInputFocus() {
      this.chipsInputActive = !0;
    },
    /**
     * function triggered when click-outside happened
     */
    onInputBlur() {
      this.chipsInputActive = !1, this.input && document.activeElement.id !== this.internalId && (this.input = "");
    },
    /** KEYBOARD FUNCTIONALITIES */
    /**
     * general function for checking key events like semicolon or tab
     * @param {KeyboardEvent} event - the keydown event
     */
    checkKeyEvent(e) {
      const { key: t } = e;
      ["Tab", "Enter", "Shift"].includes(t) || (this.chipsInputActive = !0), t === "Tab" && this.input && (!this.clearable || e.shiftKey && e.target.tagName === "INPUT" || this.clearable && !e.shiftKey && e.target.tagName !== "INPUT") && (this.input = "");
    },
    /**
     * triggered on keydown enter event and will add
     * a selected option
     */
    onEnter() {
      this.closeDropdownOnOptionSelect && !this.chipsInputActive || this.activeOption && this.addSelectedOption(this.activeOption);
    },
    /**
     * event for keydown arrow (up, down) key use
     *
     * @param {KeyboardEvent} event - the keydown event
     */
    onArrowKey(e) {
      this.listInt.length && (this.activeOption = this.navigate(
        this.listInt,
        e.key === "ArrowDown",
        this.activeOptionIndex,
        !0
      ));
    },
    /** OTHER FUNCTIONALITIES */
    hoverBoxActive(e, t) {
      this.$emit("hoverbox-active", { value: e, entry: t });
    },
    /**
     * calculate the minimum width of the drop down element by getting the
     * width of this element
     */
    calcDropDownMinWidth() {
      const e = this.$refs.baseInput;
      e && e.$el && e.$el.clientWidth && (this.dropDownMinWidth = `${e.$el.clientWidth}px`);
    },
    /**
     * close dropdown
     */
    closeDropDown() {
      this.closeDropdownOnOptionSelect && this.chipsInputActive && (this.chipsInputActive = !1, this.inputElem && this.inputElem.blur());
    },
    /**
     * function to highlight characters of a string
     * @param {string} word - the option that should be matched with query string
     * @returns {string} - the string to fill into v-html
     */
    highlight(e) {
      return l({
        word: e,
        queryString: this.input,
        // this is an empty object if prop `highlightStringTags` was not used
        ...this.highlightTags
      });
    }
  }
};
var y = function() {
  var t = this, n = t._self._c;
  return n("div", { ref: "chipsInput", staticClass: "base-chips-input" }, [n("BaseChipsInputField", t._g(t._b({ ref: "baseInput", attrs: { "input-type": t.inputType, "add-selected-entry-directly": !1, "selected-list": t.selectedListInt, "drop-down-list-id": t.internalId, "linked-list-option": t.activeOption ? t.activeOption[t.identifierPropertyName] : null, "is-active": t.chipsInputActive, loadable: t.allowDynamicDropDownEntries }, on: { "update:selectedList": function(i) {
    t.selectedListInt = i;
  }, "update:selected-list": function(i) {
    t.selectedListInt = i;
  }, "update:isActive": function(i) {
    t.chipsInputActive = i;
  }, "update:is-active": function(i) {
    t.chipsInputActive = i;
  }, keydown: [function(i) {
    return !i.type.indexOf("key") && t._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : (i.preventDefault(), t.onEnter.apply(null, arguments));
  }, function(i) {
    return !i.type.indexOf("key") && t._k(i.keyCode, "up", 38, i.key, ["Up", "ArrowUp"]) && t._k(i.keyCode, "down", 40, i.key, ["Down", "ArrowDown"]) ? null : (i.preventDefault(), t.onArrowKey.apply(null, arguments));
  }, t.checkKeyEvent], "click-input-field": t.onInputFocus, "clicked-outside": t.onInputBlur }, scopedSlots: t._u([{ key: "below-input", fn: function() {
    return [t.chipsInputActive ? n("BaseDropDownList", { ref: "dropDownList", staticClass: "base-chips-input__drop-down", style: { "min-width": t.dropDownMinWidth }, attrs: { "drop-down-options": t.listInt, "active-option": t.activeOption, "selected-option": t.selectedOption, "identifier-property-name": t.identifierPropertyName, "label-property-name": t.labelPropertyName, "list-id": t.internalId, language: t.language, "drop-down-no-options-info": t.dropDownNoOptionsInfo }, on: { "update:activeOption": function(i) {
      t.activeOption = i;
    }, "update:active-option": function(i) {
      t.activeOption = i;
    }, "update:selectedOption": function(i) {
      t.selectedOption = i;
    }, "update:selected-option": function(i) {
      t.selectedOption = i;
    } }, nativeOn: { click: function(i) {
      return i.stopPropagation(), t.closeDropDown.apply(null, arguments);
    }, touchstart: function(i) {
      return i.stopPropagation(), t.closeDropDown.apply(null, arguments);
    } }, scopedSlots: t._u([{ key: "option", fn: function({ option: i }) {
      return [t.allowUnknownEntries && i[t.identifierPropertyName] === "createNew" ? n("span", { key: i[t.labelPropertyName], ref: "option" }, [t._v(" " + t._s(t.addNewChipText ? `${t.addNewChipText} ${t.getLangLabel(i[t.labelPropertyName], !0)} ...` : `${t.getI18nTerm("form.Add", -1, { value: t.getLangLabel(i[t.labelPropertyName], !0) })} ...`) + " ")]) : i ? [t._t("drop-down-entry", function() {
        return [i[t.identifierPropertyName] ? n("span", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: {
          value: t.highlightStringMatch ? t.highlight(t.getLangLabel(i[t.labelPropertyName], !0)) : t.getLangLabel(i[t.labelPropertyName], !0),
          interpretTextAsHtml: t.interpretChipsLabelAsHtml
        }, expression: `{
                  value: highlightStringMatch
                    ? highlight(getLangLabel(option[labelPropertyName], true))
                    : getLangLabel(option[labelPropertyName], true),
                  interpretTextAsHtml: interpretChipsLabelAsHtml,
                }` }], key: i[t.identifierPropertyName] }) : t._e()];
      }, { item: i })] : t._e()];
    } }, { key: "no-options", fn: function() {
      return [t._t("no-options")];
    }, proxy: !0 }], null, !0) }) : t._e(), t._t("below-input")];
  }, proxy: !0 }, { key: "label-addition", fn: function() {
    return [t._t("label-addition")];
  }, proxy: !0 }, { key: "pre-input-field", fn: function() {
    return [t._t("pre-input-field")];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [t._t("input-field-addition-before")];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [t._t("input-field-inline-before")];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [t._t("input-field-addition-after")];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [t._t("post-input-field"), t.allowMultipleEntries ? t._e() : n("div", { staticClass: "base-chips-input__single-dropdown", on: { keydown: function(i) {
      if (!i.type.indexOf("key") && t._k(i.keyCode, "enter", 13, i.key, "Enter"))
        return null;
      i.stopPropagation(), t.chipsInputActive = !t.chipsInputActive;
    }, click: function(i) {
      i.stopPropagation(), t.chipsInputActive = !t.chipsInputActive;
    } } }, [n("BaseIcon", { class: [
      "base-chips-input__single-dropdown-icon",
      {
        "base-chips-input__single-dropdown-icon-rotated": t.chipsInputActive
      }
    ], attrs: { name: "drop-down" } })], 1)];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [t._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [t._t("remove-icon")];
  }, proxy: !0 }], null, !0), model: { value: t.input, callback: function(i) {
    t.input = i;
  }, expression: "input" } }, "BaseChipsInputField", t.chipsFieldInputProps, !1), t.$listeners))], 1);
}, m = [], g = /* @__PURE__ */ h(
  f,
  y,
  m,
  !1,
  null,
  "418781d7",
  null,
  null
);
const _ = g.exports;
export {
  _ as default
};
//# sourceMappingURL=BaseChipsInput.vue.es.js.map
