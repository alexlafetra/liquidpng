import l from "./BaseMediaCarouselItem.vue.es.js";
import d from "../BaseIcon/BaseIcon.vue.es.js";
import p from "../../mixins/popUpLock.es.js";
import "./BaseMediaCarousel.vue.es2.js";
import u from "../../_virtual/_plugin-vue2_normalizer.es.js";
const c = {
  name: "BaseMediaCarousel",
  components: {
    BaseMediaCarouselItem: l,
    BaseIcon: d
  },
  mixins: [p],
  props: {
    /**
     * items to display in a swiper carousel
     *
     * array of objects with the following **required** properties:
     *  **title** `string` - the asset title
     *  **mediaUrl** `string` - url of the medium to be displayed
     *
     *  additionally, type `video` also requires the following properties:
     *  **mediaPosterUrl** `string` - url of image for poster property in html5 video tag
     *  **displaySize** `Object` - set height and with from outside, needs to be an object with properties `height` and/or `width`.
     *
     *  **optional** properties:
     *  **additionalInfo** `string[]` - additional info text below file name, an array of strings.
     *  **downloadUrl** `string` - url for downloading the file
     *  **mediaType** `string` - specify the media type - needs to be one of: `image`, `video`, `audio`, `pdf`. **Caveat**: if media type is not specified it is automatically determined from file ending!
     *  **orientation** `number` - define how the image should be rotated (EXIF orientation values) (only for type `image`)
     *  **previews** `Object[]` - specify an image `srcset` as an array of objects in the form `{ [mediawidth]: 'url' }` (only for type `image`)
     *  **hlsStartLevel** `number` - define startLevel (size) of hls-video
     *
     */
    items: {
      type: Array,
      default: () => []
    },
    /**
     * index of initial slide
     *   this NEEDS to be provided if carousel should start with any other
     *   than first image in items array
     */
    initialSlide: {
      type: [Number, String],
      default: 0
    },
    /**
     * define if download button should be shown and download be enabled
     */
    allowDownload: {
      type: Boolean,
      default: !0
    },
    /**
     * define information texts for download and view (for pdfs) buttons
     */
    infoTexts: {
      type: Object,
      default: () => ({
        download: "Download",
        view: "View"
      })
    },
    /**
     * steer the display of the lightbox
     */
    showPreview: {
      type: Boolean,
      default: !1
    },
    /**
     * specify [swiper API options](https://swiperjs.com/swiper-api)
     */
    swiperOptions: {
      type: Object,
      default: () => ({
        speed: 500,
        keyboard: {
          enabled: !0
        }
      })
    }
  },
  data() {
    return {
      showInt: this.showPreview,
      // needed for popUpLock mixin
      targetName: "mediaCarousel",
      swiper: null,
      // eslint-disable-next-line
      swiperId: `base-media-carousel__swiper${this._uid}`,
      isMounted: !1
    };
  },
  watch: {
    showPreview(e) {
      this.showInt = e;
    }
  },
  mounted() {
    this.isMounted = !0;
  },
  updated() {
    this.$nextTick(() => {
      this.isMounted && this.showInt && this.swiper === null && (this.initSwiper(), this.$el.addEventListener("keyup", (e) => this.escapeEvent(e)), this.$el.addEventListener("keydown", (e) => this.tabEvents(e))), this.showInt || (this.swiper = null, this.$el.removeEventListener("keyup", (e) => this.escapeEvent(e)), this.$el.removeEventListener("keydown", (e) => this.tabEvents(e)));
    });
  },
  methods: {
    /**
     * hide preview
     */
    hide() {
      this.$emit("hide");
    },
    /**
     * init Swiper
     * control media after swipe
     */
    async initSwiper() {
      const { Swiper: e } = await import("swiper"), { Keyboard: t } = await import("swiper"), { Navigation: s } = await import("swiper"), i = {
        init: !1,
        initialSlide: this.initialSlide,
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev"
        },
        lazyPreloaderClass: "base-media-preview-preloader",
        // Threshold value in px.
        // If "touch distance" will be lower than this value then swiper will not move
        threshold: 10,
        modules: [s, t]
      };
      this.swiper = new e(`#${this.swiperId}`, {
        ...this.swiperOptions,
        ...i
      }), this.swiper.on("slideChange", () => {
        this.mediaPause();
      }), this.swiper.on("transitionEnd", () => {
        this.swiper && this.$refs.baseMedia[this.swiper.activeIndex].$el.focus();
      }), this.swiper.on("init", () => {
        setTimeout(() => {
          window.dispatchEvent(new Event("resize"));
        }, 0);
      }), this.swiper.init(), this.$refs.baseMedia[this.swiper.activeIndex].$el.focus();
    },
    /**
     * pause media on previous slide
     */
    mediaPause() {
      const e = this.$refs.baseMedia[this.swiper.previousIndex];
      e && e.$refs.baseMediaVideo && e.$refs.baseMediaVideo.pause(), e && e.$refs.baseMediaAudio && e.$refs.baseMediaAudio.pause();
    },
    /**
     * intercept escape key event, hide modal
     */
    escapeEvent(e) {
      e.key === "Escape" && this.hide();
    },
    /**
     * intercept tab key event
     * due swiper breaks using tab keys
     */
    tabEvents(e) {
      if (e.shiftKey && e.key === "Tab") {
        e.preventDefault(), this.setFocus("prev");
        return;
      }
      e.key === "Tab" && (e.preventDefault(), this.setFocus("next"));
    },
    /**
     * get focusable dom elements per slide
     *
     * @return array
     */
    getFocusableItems() {
      const e = 'button, audio, video[tabindex="0"]', t = [];
      return this.$refs.baseMedia.forEach((s) => {
        const i = Array.from(s.$el.querySelectorAll(e));
        i.unshift(s.$el), t.push(i);
      }), t;
    },
    /**
     * set focus to prev/next focusable dom element
     * trigger slideEvent if needed
     *
     * @param {string} direction 'prev', 'next'
     */
    setFocus(e = "next") {
      const t = this.getFocusableItems();
      let s, i;
      if (t.forEach((a, o) => {
        a.forEach((r, n) => {
          r.matches(":focus") && (s = o, i = n);
        });
      }), e === "next") {
        if (t[s] && t[s][i + 1]) {
          t[s][i + 1].focus();
          return;
        }
        this.swiper.slideNext();
      }
      if (e === "prev") {
        if (t[s] && t[s][i - 1]) {
          t[s][i - 1].focus();
          return;
        }
        this.swiper.slidePrev();
      }
    },
    download(e) {
      this.$emit("download", e);
    }
  }
};
var h = function() {
  var t = this, s = t._self._c;
  return s("transition", { attrs: { name: "grow" } }, [t.showInt ? s("div", { ref: "mediaCarousel", staticClass: "base-media-carousel" }, [s("div", { staticClass: "base-media-carousel__background" }), s("button", { staticClass: "base-media-carousel__close", on: { click: t.hide } }, [s("base-icon", { attrs: { name: "remove" } })], 1), s("div", { staticClass: "swiper-container", attrs: { id: t.swiperId } }, [t.items.length > 1 ? [s("base-icon", { staticClass: "swiper-button swiper-button-prev", attrs: { name: "prev" } }), s("base-icon", { staticClass: "swiper-button swiper-button-next", attrs: { name: "next" } })] : t._e(), s("div", { staticClass: "swiper-wrapper" }, t._l(t.items, function(i, a) {
    return s("div", { key: a, staticClass: "swiper-slide" }, [s("base-media-carousel-item", { ref: "baseMedia", refInFor: !0, attrs: { autoplay: a === t.initialSlide, "additional-info": i.additionalInfo, "allow-download": t.allowDownload, "current-slide-info": t.items.length > 1 ? `${a + 1} / ${t.items.length}` : "", "display-name": i.title, "display-size": i.displaySize, "download-url": i.downloadUrl, "info-texts": t.infoTexts, "media-url": i.mediaUrl, "media-poster-url": i.mediaPosterUrl, "media-type": i.mediaType, orientation: i.orientation, previews: i.previews, "hls-start-level": i.hlsStartLevel, tabindex: "0" }, on: { download: t.download } })], 1);
  }), 0)], 2)]) : t._e()]);
}, w = [], f = /* @__PURE__ */ u(
  c,
  h,
  w,
  !1,
  null,
  "ca6e5986",
  null,
  null
);
const $ = f.exports;
export {
  $ as default
};
//# sourceMappingURL=BaseMediaCarousel.vue.es.js.map
