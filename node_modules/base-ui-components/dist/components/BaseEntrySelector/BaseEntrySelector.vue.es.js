import r from "../../mixins/i18n.es.js";
import "./BaseEntrySelector.vue.es2.js";
import l from "../../_virtual/_plugin-vue2_normalizer.es.js";
const o = {
  name: "BaseEntrySelector",
  components: {
    BaseDropDown: () => import("../BaseDropDown/BaseDropDown.vue.es.js").then((t) => t.default || t),
    BaseLoader: () => import("../BaseLoader/BaseLoader.vue.es.js").then((t) => t.default || t),
    BaseMenuList: () => import("../BaseMenuList/BaseMenuList.vue.es.js").then((t) => t.default || t),
    BaseOptions: () => import("../BaseOptions/BaseOptions.vue.es.js").then((t) => t.default || t),
    BasePagination: () => import("../BasePagination/BasePagination.vue.es.js").then((t) => t.default || t),
    BaseSearch: () => import("../BaseSearch/BaseSearch.vue.es.js").then((t) => t.default || t),
    BaseSelectOptions: () => import("../BaseSelectOptions/BaseSelectOptions.vue.es.js").then((t) => t.default || t)
  },
  mixins: [r],
  props: {
    /**
     * list of entries to display. Unless the slot `entries` is used this should be an object with
     * properties compatible with [BaseMenuList](BaseMenuList) `list` object array
     */
    entries: {
      type: Array,
      default: () => []
    },
    /**
     * provide the total number of entries for pagination calculations
     */
    entriesTotal: {
      type: Number,
      default: null
    },
    /**
     * number of entries per page (this does not steer the number of entries displayed.
     * (the correct number needs to be provided by `entries`) but is solely
     * needed for correct pagination calculations)
     */
    entriesPerPage: {
      type: Number,
      default: 10
    },
    /**
     * define if entries are selectable - thus if checkboxes are available
     */
    entriesSelectable: {
      type: Boolean,
      default: !1
    },
    /**
     * specify a maximum number of entries that can be selected.
     * specify `0` if there should be no limit
     */
    maxSelectedEntries: {
      type: Number,
      default: 0
    },
    /**
     * specify a custom height - mainly useful if component is within a pop-up.
     * Use a valid CSS height property value.
     */
    height: {
      type: String,
      default: ""
    },
    /**
     * flag to set if loader should be shown (for fetch requests)
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * specify the index of an entry to be marked active (color border on left side).
     */
    activeEntry: {
      type: Number,
      default: -1
    },
    /**
     * specify a language (ISO 639-1) (used for label if label is language specific object
     * e.g. `{ de: 'xxx', en: 'yyy' }`)
     */
    language: {
      type: String,
      default: "en"
    },
    /**
     * hide options completely (necessary if only before or after slot elements should remain)
     * if the complete options row should be hidden set `showOptionsRow` to `false` instead!
     */
    optionsHidden: {
      type: Boolean,
      default: !1
    },
    /**
     * define options to filter entries
     * structure e.g.: `[{ label: { de: "Alle Typen", en: "All Types" }, source: "" }]`
     */
    entryTypes: {
      type: Array,
      default: () => []
    },
    /**
     * specify config options for your sorting drop down element (if `sortOptions` are
     * provided).
     * Needs to be an object with the following properties:
     *  **label** `string` - specify a label for the sort options drop down (purely for accessibility purposes)
     *  **default** `?Object` - specify a default option that the dropdown is initialized with.
     *    this needs to have the same object structure as the objects in `entryTypes`.
     *    if no default is provided the first option in the list will be selected.
     *  **valuePropertyName** `string` - specify the name of the property that contains a unique value
     */
    entryTypesConfig: {
      type: Object,
      default: () => ({
        label: "filter by type",
        default: null,
        valuePropertyName: "value"
      }),
      validator: (t) => !t || ["label", "default", "valuePropertyName"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * define options for sorting entries.
     * structure e.g: `[{ label: 'By Type', value: 'type_en' }]`
     */
    sortOptions: {
      type: Array,
      default: () => []
    },
    /**
     * specify config options for your sorting drop down element (if `sortOptions` are
     * provided).
     * Needs to be an object with the following properties:
     *  **label** `string` - specify a label for the sort options drop down (purely for accessibility purposes)
     *  **default** `?Object` - specify a default option that the dropdown is initialized with.
     *    this needs to have the same object structure as the objects in `entryTypes`.
     *    if no default is provided the first option in the list will be selected.
     *  **valuePropertyName** `string` - specify the name of the property that contains a unique value
     */
    sortConfig: {
      type: Object,
      default: () => ({
        label: "sort entries",
        default: null,
        valuePropertyName: "value"
      }),
      validator: (t) => !t || Object.keys(t).every((e) => [
        "label",
        "default",
        "valuePropertyName"
      ].includes(e))
    },
    /**
     * specify informational texts for the component (especially helpful to provide language
     * specific text) - this needs to be an object with the following
     * properties (if you don't want to display any text leave an empty string):
     *
     *     **noEntriesTitle**: Header text shown if search for string returned no results.
     *     **noEntriesSubtext**: subtext shown if search for string returned no result.
     *     **options**: Text for title button.
     *        This needs to be an object containing a `show` and `hide` property that are shown when
     *        `entriesSelectable` is `true` or `false` respectively.
     *     **search**: placeholder in search input field.
     *     **selectAll**: Text for 'Select All' button.
     *     **selectNone**: Text for 'Select None' button.
     *     **entriesSelected**: Text for number of entries (x) selected. information displayed as
     *      `x {provided text}`.
     *
     *  The values of this object might be plain string or a key for an i18n file (in case it is not
     *  an object that is required! - in that case the above applies to the values within that
     *  object)
     */
    entrySelectorText: {
      type: Object,
      default: () => ({
        noEntriesTitle: "No matching entries found",
        noEntriesSubtext: "Please adjust your search criteria.",
        options: {
          show: "options",
          hide: "options"
        },
        search: "Search",
        selectAll: "Select All",
        selectNone: "Select None",
        entriesSelected: "entries selected",
        maxEntriesReached: "Maximum Number Exceeded!"
      }),
      // checking if all necessary properties are part of the provided object
      validator: (t) => [
        "noEntriesTitle",
        "noEntriesSubtext",
        "options",
        "search",
        "selectAll",
        "selectNone",
        "entriesSelected",
        "maxEntriesReached"
      ].every((e) => Object.keys(t).includes(e)) && ["show", "hide"].every((e) => Object.keys(t.options).includes(e))
    },
    /**
     * define if search field should be shown.
     * this will have no effect if `head` slot is used.
     */
    useSearch: {
      type: Boolean,
      default: !0
    },
    /**
     * this will remove the complete row between search and entries list.
     * This means also the slots `options` and `afterOptions` are not available anymore!
     * (if only the options menu should be hidden use `optionsHidden` instead)
     */
    showOptionsRow: {
      type: Boolean,
      default: !0
    },
    /**
     * this prop gives the option to add assistive text for screen readers.
     * properties:
     * **loaderActive**: text that is announced when results are being fetched (prop
     *  `isLoading` is set `true`)
     * **resultsFound**: provide text that should be announced when the search has
     *  yielded results. Adding the string '{number}' will announce the total number
     *  of results found
     * **noResultsFound**: provide text that should be announced when no search results
     *  were round
     */
    assistiveText: {
      type: Object,
      default: () => ({
        resultsFound: "{number} Results found.",
        noResultsFound: "No results found.",
        loaderActive: "Loading."
      })
    }
  },
  data() {
    return {
      /**
       * variable to store filter text entered into search
       * @type {string}
       */
      filterString: "",
      /**
       * variable to store selected filter type
       * @type {Object}
       */
      filterType: {},
      /**
       * variable to store selected sort option
       * @type {Object}
       */
      sortParam: {},
      headHasShadow: !1,
      pageNumber: 1,
      showOptions: !1,
      // TODO: eventually it would make sense to have selected entries settable from outside
      selectedEntries: [],
      /**
       * timeout to prevent triggering of search after every key stroke
       * @type {?number}
       * TODO: eventually this should be kept in front end to give more individual control to
       * component users
       */
      timeout: null,
      /**
       * variable to remember if page changed when entries are updated (to set the focus
       * to first entry after page change)
       */
      pageChanged: !1,
      /**
       * manage the announcement of found results
       * @type {string}
       */
      resultsAnnouncement: ""
    };
  },
  computed: {
    /**
     * create object for the element style attribute
     * @returns {Object}
     */
    calcStyle() {
      return this.height ? { height: this.height } : {};
    },
    /**
     * calculate page total for pagination from available numbers
     * @returns {number}
     */
    pageTotal() {
      return this.entriesPerPage ? Math.ceil(this.entriesTotal / this.entriesPerPage) : 0;
    },
    /**
     * BaseMenuList components needs a list of unique IDs for selected entries
     * @returns {string[]}
     */
    selectedListIds() {
      return [...new Set(this.selectedEntries.map((t) => t.id))];
    },
    /**
     * to calc the correct max-with for the sort and type drop downs we need to know how
     * many there are
     * @type {number}
     */
    dropDownElementsCount() {
      return this.sortOptions && this.sortOptions.length && this.entryTypes && this.entryTypes.length ? 2 : 1;
    },
    /**
     * filter entries which are not disabled
     *
     * @returns {Object[]}
     */
    selectableEntries() {
      return this.entries.filter((t) => !t.disabled);
    }
  },
  watch: {
    /**
     * watch if entries are updated to set the focus on the first list
     * element
     */
    entries() {
      this.$refs.menuList && this.pageChanged && this.$nextTick(() => {
        const t = this.showOptions ? this.$refs.menuList.$el.querySelector("input:enabled") : this.$refs.menuList.$el.querySelector('*[tabindex]:not([tabindex="-1"])');
        t && t.focus();
      }), this.pageChanged = !1, this.resultsAnnouncement = this.assistiveText[this.entriesTotal ? "resultsFound" : "noResultsFound"].replace("{number}", this.entriesTotal), setTimeout(() => {
        this.resultsAnnouncement = "";
      }, 300);
    },
    /**
     * watch outside variable to have it in sync with internal 'showOptions'
     */
    entriesSelectable: {
      handler(t) {
        t !== this.showOptions && (this.showOptions = t);
      },
      immediate: !0
    },
    showOptions(t) {
      t || (this.selectedEntries = []), t !== this.entriesSelectable && this.$emit("update:entries-selectable", this.showOptions);
    },
    /**
     * watch selectedEntries to inform parent of changes in selection
     */
    selectedEntries() {
      this.$emit("selected-changed", this.selectedEntries);
    }
  },
  created() {
    this.sortParam = this.sortConfig.default || (this.sortOptions.length ? this.sortOptions[0] : {}), this.filterType = this.entryTypesConfig.default || (this.entryTypes.length ? this.entryTypes[0] : {});
  },
  mounted() {
    this.fetchEntries(), this.$refs.body.addEventListener("scroll", this.scroll);
  },
  beforeDestroy() {
    this.$refs.body.removeEventListener("scroll", this.scroll);
  },
  methods: {
    /**
     * select all or none entries
     *
     * @param {Boolean} selected
     */
    changeAllSelectState(t) {
      if (t)
        this.selectedEntries = this.selectedEntries.concat(this.selectableEntries), this.selectedEntries = [...new Set(this.selectedEntries)];
      else {
        const e = this.entries.map((s) => s.id);
        this.selectedEntries = this.selectedEntries.filter((s) => !e.includes(s.id));
      }
    },
    fetchEntries() {
      this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.timeout = setTimeout(() => {
        this.$emit("fetch-entries", {
          page: this.pageNumber,
          query: this.filterString,
          sort: this.sortParam,
          type: this.filterType
        });
      }, 600);
    },
    filterEntries(t, e) {
      e === "type" ? this.fetchEntries() : e === "title" && (this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.timeout = setTimeout(() => {
        (t.length === 0 || t.length > 2) && this.fetchEntries();
      }, 600)), this.pageNumber = 1;
    },
    scroll() {
      if (this.$refs.body.scrollTop) {
        this.headHasShadow = !0;
        return;
      }
      this.headHasShadow = !1;
    },
    /**
     * function to trigger from slot `entries` when an entry was selected
     * @param {Object} obj - selected entry
     * @property {boolean} obj.selected - variable indicating if entry was selected or deselected
     * @property {string} obj.index - the index of the selected or deselected entry in 'entries'
     * @public
     */
    selectEntry(t) {
      t.selected ? this.selectedEntries.push(this.entries[t.index]) : this.selectedEntries = this.selectedEntries.filter((e) => e.id !== this.entries[t.index].id);
    },
    setPage(t) {
      this.pageChanged = !0, this.pageNumber = t, this.fetchEntries();
    },
    entryClicked(t) {
      this.$emit("entry-clicked", this.entries[t].id);
    }
  }
};
var a = function() {
  var e = this, s = e._self._c;
  return s("div", { staticClass: "base-entry-selector", style: e.calcStyle }, [s("div", { ref: "head", class: [
    "base-entry-selector__head",
    { "base-entry-selector__head--shadow": e.headHasShadow },
    { "base-entry-selector__head--padding": e.useSearch }
  ] }, [e._t("head", function() {
    return [e.useSearch ? s("BaseSearch", { class: [
      "base-entry-selector__head__search-bar",
      { "base-entry-selector__head__search-bar--margin-large": !e.showOptionsRow }
    ], attrs: { "show-image": !0, placeholder: e.getI18nTerm(e.entrySelectorText.search), "assistive-text": {
      loaderActive: e.assistiveText.loaderActive,
      results: e.resultsAnnouncement
    } }, on: { input: function(n) {
      return e.filterEntries(n, "title");
    } }, model: { value: e.filterString, callback: function(n) {
      e.filterString = n;
    }, expression: "filterString" } }) : e._e()];
  }), e.showOptionsRow ? s("div", { staticClass: "base-entry-selector__options" }, [s("BaseOptions", { ref: "baseOptions", attrs: { "show-options": e.showOptions, "options-hidden": e.optionsHidden, "use-options-button-on": "always", "show-after-options-below": !0, "options-button-icon": {
    show: "options-menu",
    hide: "options-menu"
  }, "options-button-text": e.entrySelectorText.options, "align-options": "left" }, on: { "update:showOptions": function(n) {
    e.showOptions = n;
  }, "update:show-options": function(n) {
    e.showOptions = n;
  } }, scopedSlots: e._u([{ key: "afterOptions", fn: function() {
    return [s("div", { staticClass: "base-entry-selector__dropdowns" }, [e._t("after-options", function() {
      return [e.sortOptions.length ? s("BaseDropDown", { ref: "baseDropDown", staticClass: "base-entry-selector__dropdowns__dropdown", style: { maxWidth: `${100 / e.dropDownElementsCount}%` }, attrs: { id: `${e.sortConfig.label}-sort-drop-down`, label: e.sortConfig.label, options: e.sortOptions, "with-spacing": !1, "align-drop-down": e.entryTypes.length ? "left" : "right", "value-prop": e.sortConfig.valuePropertyName }, on: { "value-selected": e.fetchEntries }, model: { value: e.sortParam, callback: function(n) {
        e.sortParam = n;
      }, expression: "sortParam" } }) : e._e(), e.entryTypes.length ? s("BaseDropDown", { ref: "baseDropDown", staticClass: "base-entry-selector__dropdowns__dropdown", style: { maxWidth: `${100 / e.dropDownElementsCount}%` }, attrs: { id: `${e.entryTypesConfig.label}-types-drop-down`, label: e.entryTypesConfig.label, options: e.entryTypes, language: e.language, "with-spacing": !1, "value-prop": e.entryTypesConfig.valuePropertyName, "align-drop-down": "right" }, on: { "value-selected": function(n) {
        return e.filterEntries(n, "type");
      } }, model: { value: e.filterType, callback: function(n) {
        e.filterType = n;
      }, expression: "filterType" } }) : e._e()];
    })], 2)];
  }, proxy: !0 }, { key: "options", fn: function() {
    return [e._t("option-actions")];
  }, proxy: !0 }], null, !0) })], 1) : e._e(), e.showOptions ? s("BaseSelectOptions", { ref: "selectOptions", attrs: { "select-text": e.getI18nTerm(e.entrySelectorText.selectAll), "selected-number-text": e.getI18nTerm(e.entrySelectorText.entriesSelected), "deselect-text": e.getI18nTerm(e.entrySelectorText.selectNone), list: e.selectableEntries, "selected-list": e.selectedEntries, "select-all-disabled": !!e.maxSelectedEntries && !(e.selectableEntries.length < e.maxSelectedEntries - e.selectedListIds.length || !e.selectableEntries.some((n) => !e.selectedListIds.includes(n.id))) }, on: { selected: e.changeAllSelectState }, scopedSlots: e._u([{ key: "selectedText", fn: function() {
    return [e._v(" " + e._s(`${e.selectedListIds.length}${e.maxSelectedEntries ? `/${e.maxSelectedEntries}` : ""} ${e.getI18nTerm(e.entrySelectorText.entriesSelected)}`) + " "), e.maxSelectedEntries && e.selectedListIds.length >= e.maxSelectedEntries ? s("span", [e._v(" " + e._s(`(${e.getI18nTerm(e.entrySelectorText.maxEntriesReached)})`) + " ")]) : e._e()];
  }, proxy: !0 }], null, !1, 1235622275) }) : e._e()], 2), s("div", { ref: "body", staticClass: "base-entry-selector__body" }, [e.isLoading ? s("div", { staticClass: "loading-area" }, [s("BaseLoader", { class: { "base-entry-selector__loader__center": e.entries.length < 4 }, attrs: { "text-on-loader-show": e.assistiveText.loaderActive } })], 1) : e._e(), e._t("entries", function() {
    return [e.entries.length ? s("BaseMenuList", { key: "menu-list", ref: "menuList", staticClass: "base-entry-selector__body__entries", attrs: { "select-active": e.showOptions, list: e.entries, "active-entry": e.activeEntry, "selected-list": e.selectedListIds }, on: { clicked: e.entryClicked, selected: e.selectEntry }, scopedSlots: e._u([{ key: "entry-text-content", fn: function({ item: n }) {
      return [e._t("entry-text-content", null, { item: n })];
    } }, { key: "entry-right-side-elements", fn: function({ isSelected: n, item: i }) {
      return [e._t("entry-right-side-elements", null, { isSelected: n, selectActive: e.showOptions, item: i })];
    } }, { key: "thumbnails", fn: function({ item: n }) {
      return [e._t("thumbnails", null, { item: n })];
    } }], null, !0) }) : e.isLoading ? e._e() : s("div", { staticClass: "base-entry-selector__no-entries" }, [s("p", { staticClass: "base-entry-selector__no-entries__title" }, [e._v(" " + e._s(e.getI18nTerm(e.entrySelectorText.noEntriesTitle)) + " ")]), s("p", { staticClass: "base-entry-selector__no-entries__subtext" }, [e._v(" " + e._s(e.getI18nTerm(e.entrySelectorText.noEntriesSubtext)) + " ")])])];
  }, { entries: e.entries, selectEntry: e.selectEntry })], 2), e.pageTotal > 1 ? s("BasePagination", { ref: "pagination", attrs: { total: e.pageTotal, current: e.pageNumber }, on: { "set-page": e.setPage } }) : e._e()], 1);
}, c = [], d = /* @__PURE__ */ l(
  o,
  a,
  c,
  !1,
  null,
  "4d631712",
  null,
  null
);
const f = d.exports;
export {
  f as default
};
//# sourceMappingURL=BaseEntrySelector.vue.es.js.map
