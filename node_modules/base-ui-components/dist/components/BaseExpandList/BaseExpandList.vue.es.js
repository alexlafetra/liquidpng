import n from "../BaseButton/BaseButton.vue.es.js";
import r from "./BaseExpandListRow.vue.es.js";
import "./BaseExpandList.vue.es2.js";
import o from "../../_virtual/_plugin-vue2_normalizer.es.js";
const l = {
  name: "BaseExpandList",
  components: {
    BaseButton: n,
    BaseExpandListRow: r,
    Draggable: () => import("vuedraggable").then((e) => e.default || e)
  },
  props: {
    /**
     * should be an object array with the following properties:
     *  **label** `string` - the displayed label
     *  **id** `string` - an identifier
     *  **data** `Object[]` - an object array with the property:
     *    \* **label** `string` (renders component as
     *    expandable row) or
     *    * **value** `string` (renders component as entry row)
     *
     * optional properties:
     *  **count** `number` - used for the number shown in brackets
     *    (else the array length will be used)
     *  **hidden** `boolean` - used to set visibility and is set in edit mode to toggle item
     *
     *  the `.sync` modifier might be used on this prop
     */
    data: {
      type: Array,
      default: () => []
    },
    /**
     * set edit mode from outside
     */
    edit: {
      type: Boolean,
      default: !1
    },
    /**
     * specify number of minimal displayed items
     */
    minItems: {
      type: Number,
      default: 3
    },
    /**
     * expand multiple items
     */
    multiple: {
      type: Boolean,
      default: !1
    },
    /**
     * button text to show more content
     */
    showMoreText: {
      type: String,
      default: "Show all"
    },
    /**
     * button text to show less content
     */
    showLessText: {
      type: String,
      default: "Show less"
    },
    /**
     * button text to hide item
     */
    editHideText: {
      type: String,
      default: "Hide"
    },
    /**
     * button text to show item
     */
    editShowText: {
      type: String,
      default: "Show"
    },
    /**
     * additional texts for screen-reader users to order items.
     *   object that needs to have the following properties:
     *   **activate**: Text read when item is focused, use variable {state} to
     *    announce item visibility - specify text used in properties 'hidden' and 'visible'
     *   **activated**: Text read after item was activated (selected by enter key)
     *   **description**: Text read on initial list focus
     *   **moved**: Text read after item was moved; can contain variables {pos} (for new position) and {total}
     *   **visible**: string substituted to 'activate' text for state variable if item is visible
     *   **hidden**: string substituted to 'activate' text for state variable if item is hidden
     *
     */
    assistiveText: {
      type: Object,
      default: () => ({
        activate: "Use the Enter key to select item. Item is currently {state}",
        activated: "Item selected. Use arrow keys to order item.",
        description: "Use Tab key to navigate to item an order item.",
        moved: "Item moved: {pos} of {total}",
        visible: "visible",
        hidden: "hidden"
      }),
      validator: (e) => Object.keys(e).every((t) => ["activate", "activated", "description", "moved", "visible", "hidden"].includes(t))
    },
    /**
     * specify the type of visibility switch in edit mode
     *  **button**: a [BaseButton](BaseButton) without text
     *  **toggle**: a [BaseToggle](BaseToggle) element without text
     */
    controlType: {
      type: String,
      default: "button",
      validator: (e) => ["button", "toggle"].includes(e)
    },
    /**
     * define which items are expanded
     */
    expanded: {
      type: Array,
      default: () => []
    },
    /**
     * option to disable the edit functionalities of the element (toggle and draggable)
     */
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      assertiveText: "",
      showAll: !1,
      dataSorted: null,
      originalData: null,
      dragHandle: ""
    };
  },
  computed: {
    // the data array computed for draggable
    dataInt: {
      get() {
        return this.dataSorted || this.data;
      },
      set(e) {
        this.dataSorted = e;
      }
    }
  },
  watch: {
    dataSorted: {
      handler(e) {
        this.edit && JSON.stringify(e) !== JSON.stringify(this.data) && this.$emit("update:data", e);
      },
      deep: !0
    },
    data: {
      handler(e) {
        JSON.stringify(e) !== JSON.stringify(this.dataSorted) && (this.dataInt = JSON.parse(JSON.stringify(e)));
      },
      deep: !0,
      immediate: !0
    },
    /**
     * watch edit to create a copy of the data for the reset function
     */
    edit(e) {
      this.assertiveText = "", e && (this.$nextTick(() => {
        this.$refs.baseExpandListDraggable.focus({ preventScroll: !0 });
      }), this.originalData = JSON.parse(JSON.stringify(this.data)));
    },
    /**
     * watch expanded state and expand items
     */
    expanded(e) {
      this.expandItems(e);
    }
  },
  mounted() {
    this.dragHandle = this.isTouchCapable() ? [".base-expand-item__handle"] : [".base-expand-item__handle", ".base-expand-item__label"];
  },
  methods: {
    /**
     * expand items
     *
     * @param {Array} state - expanded state, eg: [0, 1]: level1 first item,
     *  level2 second item is expanded
     */
    expandItems(e) {
      e.length && (e[0] >= this.minItems && this.$refs.baseExpandListRow[e[0]] && (this.showAll = !0), e[0] !== void 0 && this.$refs.baseExpandListRow[e[0]] && (this.$refs.baseExpandListRow[e[0]].expanded = !0), e[1] !== void 0 && this.$refs.baseExpandListRow[e[0]].$refs.baseExpandListRow[e[1]] && (this.$refs.baseExpandListRow[e[0]].$refs.baseExpandListRow[e[1]].expanded = !0));
    },
    /**
     * emit expanded state of items
     * each array element represents the index of the expanded item per level
     * eg: [0, 1]: level1 first item, level2 second item is expanded
     *
     * @param {Array} value - value to emit
     */
    emitExpandedState(e) {
      this.$emit("expanded-state", e);
    },
    /**
     * function called from BaseExpandListRow in case a prop of the data variable
     * changes (e.g. hidden)
     * @param {Object} rowData - the updated data of the BaseExpandListRow
     * @param {number} index - the index in the dataInt array
     */
    updateData(e, t) {
      this.$set(this.dataSorted, t, e);
    },
    /**
     * sort list
     *
     * @param {object} obj
     * @property {string} obj.direction - 'up' or 'down'
     * @param {number} index - the previous index of the item in the array
     */
    sort({ direction: e }, t) {
      if (e === "up" && t - 1 < 0 || e === "down" && t + 1 >= this.dataInt.length) {
        this.$refs.baseExpandListRow[t].useAssistiveText = !1, this.$refs.baseExpandListRow[t].movable = !0;
        return;
      }
      const a = e === "up" ? t - 1 : t + 1, s = t, i = this.dataInt;
      i.splice(a, 0, i.splice(s, 1)[0]), this.dataInt = i, this.assertiveText = this.assistiveText.moved.replace("{pos}", a + 1).replace("{total}", this.dataInt.length), this.$refs.baseExpandListRow[a].useAssistiveText = !1, this.$refs.baseExpandListRow[a].movable = !0;
    },
    /**
     * reset list data - this always restores the state of the data on
     * last save() triggered (=was triggered in parent)
     * @public
     */
    reset() {
      this.dataInt = JSON.parse(JSON.stringify(this.originalData)), this.$emit("update:data", this.dataInt);
    },
    /**
     * save changed data
     * @public
     */
    save() {
      this.$emit("saved", this.dataInt), this.originalData = JSON.parse(JSON.stringify(this.dataInt));
    },
    /**
     * set assistiveText for screen readers
     *
     * @param {string} type
     * @param {number} index
     */
    assistive(e, t) {
      const a = this.dataInt[t].hidden ? this.assistiveText.hidden : this.assistiveText.visible, s = this.assistiveText[e].replace("{state}", a);
      if (this.assertiveText === s) {
        this.assertiveText = "", setTimeout(() => {
          this.assertiveText = s;
        }, 1);
        return;
      }
      this.assertiveText = s;
    },
    /**
     * check touch capabilities of current device
     *
     * @returns {boolean|*}
     */
    isTouchCapable() {
      return "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;
    }
  }
};
var h = function() {
  var t = this, a = t._self._c;
  return a("div", { staticClass: "base-expand-list" }, [a("div", { class: ["base-box-shadow", { "base-box-shadow--edit": t.edit }] }, [t.edit ? t._e() : a("ul", t._l(t.data, function(s, i) {
    return a("BaseExpandListRow", { directives: [{ name: "show", rawName: "v-show", value: i < (t.showAll ? t.data.length : t.minItems), expression: "index < (showAll ? data.length : minItems)" }], key: i, ref: "baseExpandListRow", refInFor: !0, attrs: { "parent-index": i, data: s, multiple: t.multiple, "render-as": "li" }, on: { "expanded-state": t.emitExpandedState }, scopedSlots: t._u([{ key: "content", fn: function(d) {
      return [t._t("content", null, { data: d.data })];
    } }], null, !0) });
  }), 1), t.edit ? [a("div", { staticClass: "assistive-text", attrs: { "aria-live": "assertive" } }, [t._v(" " + t._s(t.assertiveText) + " ")]), a("p", { staticClass: "assistive-text", attrs: { id: `draggable-${t._uid}` } }, [t._v(" " + t._s(t.assistiveText.description) + " ")]), a("div", { ref: "baseExpandListDraggable", staticClass: "base-expand-list__draggable", attrs: { tabindex: "0", "aria-labelledby": `draggable-${t._uid}` } }, [a("draggable", { staticClass: "base-expand-list__draggable", attrs: { draggable: ".base-expand-list__draggable__item", handle: t.dragHandle, disabled: t.disabled, animation: "150" }, model: { value: t.dataInt, callback: function(s) {
    t.dataInt = s;
  }, expression: "dataInt" } }, t._l(t.dataInt, function(s, i) {
    return a("BaseExpandListRow", { key: i, ref: "baseExpandListRow", refInFor: !0, staticClass: "base-expand-list__draggable__item", attrs: { data: s, edit: !0, "edit-hide-text": t.editHideText, "edit-show-text": t.editShowText, "control-type": t.controlType, disabled: t.disabled }, on: { assistive: function(d) {
      return t.assistive(d, i);
    }, sorted: function(d) {
      return t.sort(d, i);
    }, "update:data": function(d) {
      return t.updateData(d, i);
    } } });
  }), 1)], 1)] : t._e()], 2), !t.edit && t.data.length > t.minItems ? a("BaseButton", { class: { "base-button-icon-rotate-180": t.showAll }, attrs: { id: `base-expand-list-${t._uid}`, "aria-expanded": t.showAll ? "true" : "false", "has-background-color": !1, icon: "drop-down", "icon-position": "right", text: t.showAll ? t.showLessText : t.showMoreText }, on: { clicked: function(s) {
    t.showAll = !t.showAll;
  } } }) : t._e()], 1);
}, p = [], u = /* @__PURE__ */ o(
  l,
  h,
  p,
  !1,
  null,
  "6ee40e22",
  null,
  null
);
const b = u.exports;
export {
  b as default
};
//# sourceMappingURL=BaseExpandList.vue.es.js.map
