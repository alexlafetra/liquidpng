{"version":3,"file":"BaseAdvancedSearch.vue.es.js","sources":["../../../src/components/BaseAdvancedSearch/BaseAdvancedSearch.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"searchContainer\"\n    class=\"base-advanced-search\">\n    <!-- FILTER ROW LIST (MODE 'LIST') -->\n    <template v-if=\"mode === 'list' && appliedFiltersInt && appliedFiltersInt.length\">\n      <BaseAdvancedSearchRow\n        v-for=\"(filter, index) in appliedFiltersInt\"\n        :key=\"'filter-' + index\"\n        :mode=\"mode\"\n        :search-row-id=\"`${rowId}-${filter[identifierPropertyName.filter]}-${index}`\"\n        :is-main-search=\"false\"\n        :autocomplete-results=\"filtersAutocompleteResults[index]\"\n        :filter-list=\"displayedFilters\"\n        :applied-filter=\"filter\"\n        :is-loading=\"filtersLoadingState[index]\"\n        :default-filter=\"defaultFilter\"\n        :placeholder=\"placeholder.filterRow || placeholder\"\n        :autocomplete-property-names=\"autocompletePropertyNames\"\n        :label-property-name=\"labelPropertyName\"\n        :identifier-property-name=\"identifierPropertyName\"\n        :drop-down-info-texts=\"dropDownInfoTexts\"\n        :advanced-search-text=\"advancedSearchText\"\n        :assistive-text=\"{\n          addFilter: assistiveText.addFilter,\n          removeFilter: assistiveText.removeFilter,\n          selectFilterLabel: assistiveText.selectFilterLabel,\n          searchLabel: assistiveText.searchLabel,\n          selectedOption: assistiveText.selectedOption,\n          loaderActive: assistiveText.autocompleteLoaderActive,\n          autocompleteResultsRetrieved: assistiveText.autocompleteResultsRetrieved,\n          autocompleteNoResults: assistiveText.autocompleteNoResults,\n          autocompleteInitial: assistiveText.autocompleteInitial,\n          categoryAnnouncement: assistiveText.categoryAnnouncement,\n          optionsAnnouncement: assistiveText.optionsAnnouncement,\n        }\"\n        :date-field-delay=\"dateFieldDelay\"\n        :language=\"language\"\n        :highlight-autocomplete-match=\"highlightAutocompleteMatch\"\n        :highlight-autocomplete-tags=\"highlightAutocompleteTags\"\n        class=\"base-advanced-search__filter-row\"\n        @remove-filter=\"removeFilter($event, index)\"\n        @update:applied-filter=\"updateFilter($event, index)\"\n        @fetch-autocomplete-results=\"fetchAutocomplete($event, index)\">\n        <template #autocomplete-option=\"{ option: autocompleteOption, collectionId }\">\n          <!-- @slot to allow for modification of the autocomplete option\n            @binding {Object} option - the option object as specified in the [autocompletePropertyNames.data] array\n            @binding {string} collection-id the currently active collection as provided in [autocompletePropertyNames.id] -->\n          <slot\n            name=\"autocomplete-option\"\n            :option=\"autocompleteOption\"\n            :collection-id=\"collectionId\" />\n        </template>\n      </BaseAdvancedSearchRow>\n    </template>\n\n    <!-- MAIN FILTER -->\n    <BaseAdvancedSearchRow\n      ref=\"mainSearch\"\n      :search-row-id=\"`main-${rowId}`\"\n      :mode=\"mode\"\n      :applied-filter.sync=\"mainFilter\"\n      :filter-list=\"displayedFilters\"\n      :form-filter-list=\"formFilterList\"\n      :default-filter=\"defaultFilter\"\n      :autocomplete-results=\"filtersAutocompleteResults[mainFilterIndex]\"\n      :is-loading=\"filtersLoadingState[mainFilterIndex]\"\n      :placeholder=\"placeholder.main || placeholder\"\n      :autocomplete-property-names=\"autocompletePropertyNames\"\n      :label-property-name=\"labelPropertyName\"\n      :identifier-property-name=\"identifierPropertyName\"\n      :drop-down-info-texts=\"dropDownInfoTexts\"\n      :advanced-search-text=\"advancedSearchText\"\n      :assistive-text=\"{\n        addFilter: assistiveText.addFilter,\n        removeFilter: assistiveText.removeFilter,\n        selectFilterLabel: assistiveText.selectFilterLabel,\n        searchLabel: assistiveText.searchLabel,\n        selectedOption: assistiveText.selectedOption,\n        loaderActive: assistiveText.autocompleteLoaderActive,\n        autocompleteResultsRetrieved: assistiveText.autocompleteResultsRetrieved,\n        autocompleteNoResults: assistiveText.autocompleteNoResults,\n        autocompleteInitial: assistiveText.autocompleteInitial,\n        categoryAnnouncement: assistiveText.categoryAnnouncement,\n        optionsAnnouncement: assistiveText.optionsAnnouncement,\n        results: assistiveText.results,\n      }\"\n      :date-field-delay=\"dateFieldDelay\"\n      :language=\"language\"\n      :highlight-autocomplete-match=\"highlightAutocompleteMatch\"\n      :highlight-autocomplete-tags=\"highlightAutocompleteTags\"\n      v-on=\"$listeners\"\n      @add-filter-row=\"addFilterRow\"\n      @fetch-autocomplete-results=\"fetchAutocomplete($event, mainFilterIndex)\"\n      @option-selected=\"fillOptionToForm\">\n      <!-- SHOW ADVANCED SEARCH FORM BUTTON (MODE 'FORM') -->\n      <template #after>\n        <BaseButton\n          v-if=\"mode === 'form'\"\n          :text=\"showAdvancedSearchButtonText ? advancedSearchText.advancedButtonLabel : ''\"\n          :aria-expanded=\"`${formOpen}`\"\n          :aria-controls=\"`${rowId}-form`\"\n          :description=\"advancedButtonDescription\"\n          button-style=\"row\"\n          icon=\"drop-down\"\n          icon-size=\"small\"\n          icon-position=\"right\"\n          :class=\"['base-advanced-search__expand-button',\n                   { 'base-button-icon-rotate-180': formOpen }]\"\n          @click.native.prevent.stop=\"openAdvancedSearch\"\n          @keydown.native.enter.space.prevent.stop=\"openAdvancedSearch\"\n          @focusin.native.stop />\n      </template>\n      <!-- ADVANCED SEARCH FORM (MODE 'FORM') -->\n      <template #below>\n        <BaseForm\n          v-if=\"mode === 'form' && formOpen\"\n          :id=\"`${rowId}-form`\"\n          v-bind=\"amendedFormProps\"\n          :form-field-json=\"formFilterList\"\n          :value-list=\"formFilterValuesInt\"\n          :label-property-name=\"labelPropertyName.formInputs\"\n          :identifier-property-name=\"identifierPropertyName.formInputs\"\n          :class=\"['base-advanced-search__search-form',\n                   { 'base-advanced-search__search-form--hidden': !formMounted}]\"\n          @input-complete=\"updateFormFilters\"\n          @fetch-autocomplete=\"fetchFormAutocomplete\"\n          @form-mounted=\"formIsMounted\">\n          <template #label-addition=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-label-addition\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #pre-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-pre-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template\n            #input-field-addition-before=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-input-field-addition-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-input-field-inline-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-input-field-addition-after\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #post-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-post-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots). -->\n            <slot name=\"form-error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots). -->\n            <slot name=\"form-remove-icon\" />\n          </template>\n          <template #below-input=\"{ fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n            @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n            @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"form-below-input\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #drop-down-entry=\"{ option, fieldName, groupNames }\">\n            <!-- @slot all [BaseForm](BaseForm.html#slots) slots are available with the prefix 'form-'. For a more detailed description and demonstration refer to [BaseForm](BaseForm.html#slots).\n              @binding {object} option - the option object\n              @binding {string} field-name - the name of the displayed field (for time range fields there is a '-time' suffix added)\n              @binding {string[]} group-names - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\"\n              :option=\"option\"\n              name=\"form-drop-down-entry\">\n              <template\n                v-if=\"mode === 'form'\n                  // check if value is boolean and was set true\n                  && ((typeof renderFormChipsLabelAsHtml === 'boolean' && renderFormChipsLabelAsHtml)\n                    // or if it is an array and\n                    || (typeof renderFormChipsLabelAsHtml === 'object'\n                      // a) includes the field name\n                      && (renderFormChipsLabelAsHtml.includes(fieldName)\n                        // or b) this is nested field in a form group and the array\n                        // contains a (nested) object with the group names and an array with the field name\n                        || (groupNames?.length && renderFormChipsLabelAsHtml\n                          .some((arrayEntry) => typeof arrayEntry === 'object'\n                            && extractNestedPropertyValue(groupNames.join('.'), arrayEntry)\n                              .includes(fieldName))))))\">\n                <span\n                  v-insert-text-as-html=\"{\n                    value: option[labelPropertyName.formInputs],\n                    interpretTextAsHtml: true,\n                  }\" />\n              </template>\n            </slot>\n          </template>\n        </BaseForm>\n        <div\n          v-else-if=\"mode === 'form' && !formOpen && collapsedFiltersArray.length\">\n          <BaseCollapsedFilterRow\n            :filters.sync=\"collapsedFiltersArray\"\n            :date-time-text=\"advancedSearchText.collapsedDateTime\"\n            :interpret-label-as-html=\"renderFormChipsLabelAsHtml\"\n            :assistive-text=\"{\n              removeFiltersLabel: assistiveText.removeAllFiltersLabel,\n              filterRemovedNotification: assistiveText.removeFilterValueNotification,\n              appliedFiltersLabel: assistiveText.collapsedAppliedFiltersLabel,\n              booleanFilterLabel: assistiveText.collapsedBooleanFilterValue,\n              optionToRemoveSelected: assistiveText.collapsedOptionToRemoveSelected,\n            }\"\n            @remove-all=\"removeAllFilters\" />\n        </div>\n      </template>\n      <template #autocomplete-option=\"{ option: autocompleteOption, collectionId }\">\n        <!-- @slot to allow for modification of the autocomplete option\n          @binding {Object} option - the option object as specified in the [autocompletePropertyNames.data] array\n          @binding {string} collection-id the currently active collection as provided in [autocompletePropertyNames.id] -->\n        <slot\n          name=\"autocomplete-option\"\n          :option=\"autocompleteOption\"\n          :collection-id=\"collectionId\">\n          <!-- also automate the display of html for all fields specified directly in the component -->\n          <template\n            v-if=\"mode === 'form'\n              && ((typeof renderFormChipsLabelAsHtml === 'boolean' && renderFormChipsLabelAsHtml)\n                || (typeof renderFormChipsLabelAsHtml === 'object'\n                  && renderFormChipsLabelAsHtml.includes(collectionId)))\">\n            <span\n              v-insert-text-as-html=\"{\n                value: autocompleteOption[labelPropertyName.autocompleteOption],\n                interpretTextAsHtml: true,\n              }\" />\n          </template>\n        </slot>\n      </template>\n    </BaseAdvancedSearchRow>\n    <span\n      v-if=\"assistiveTextNotification\"\n      aria-live=\"assertive\"\n      class=\"assistive-text\">\n      {{ assistiveTextNotification }}\n    </span>\n  </div>\n</template>\n\n<script>\nimport { defineAsyncComponent, ref } from 'vue';\nimport { createId, debounce, extractNestedPropertyValue, hasData, sort } from '@/utils/utils';\nimport InsertTextAsHtml from '@/directives/InsertTextAsHtml';\nimport BaseAdvancedSearchRow from '@/components/BaseAdvancedSearch/BaseAdvancedSearchRow';\nimport { useAnnouncer } from '@/composables/useAnnouncer';\n\n/**\n * @typedef Filter\n * @property {string?} label|* - property 'label' indicating the label or an equivalent\n *  custom property defined in prop labelPropertyName.filter\n * @property {string} id|* - property 'id' used as unique identifier or an equivalent\n *  custom property defined in prop identifierPropertyName.filter\n * @property {string} type - a filter type defining the type of search element shown\n *  @values text, chips, chipssingle, date, daterange\n * @property {boolean?} [hidden] - exclude filters that have this attribute true from display\n * @property {boolean?} [freetext_allowed] - property specifc for type: chips determining\n *  if options are autocompleted (true) or used from the options property (false)\n * @property {Object[]?} [options] - the options used for chips filter types with\n *  freetext_allowed false\n * @property {Object[]|string[]|string|Object?} [filter_values] - the values a filter contains - only\n *  relevant for applied filters, not for filters coming from backend presented in the drop down\n * @property {string[]} [subsets] - if a filter of `type` 'text' or 'chips' with `freetext_allowed`\n *      (thus triggering autocomplete) has subordinate filters for which the autosuggest results\n *      should also be shown - add these filter ids here\n */\n\nexport default {\n  name: 'BaseAdvancedSearch',\n  components: {\n    BaseAdvancedSearchRow,\n    BaseCollapsedFilterRow: defineAsyncComponent(() => import('@/components/BaseAdvancedSearch/BaseCollapsedFilterRow').then(m => m.default || m)),\n    BaseForm: defineAsyncComponent(() => import('@/components/BaseForm/BaseForm').then(m => m.default || m)),\n    BaseButton: defineAsyncComponent(() => import('@/components/BaseButton/BaseButton').then(m => m.default || m)),\n  },\n  directives: {\n    insertTextAsHtml: InsertTextAsHtml,\n  },\n  props: {\n    /**\n     * define the appearance and functionality of the component here.\n     * **`list`**: search offers advanced search with 'filters' to select from drop down, each filter is added\n     *    as a separate row.\n     * **`form`**: advanced search is displayed as a form below only one single search row. Offers a condensed view\n     *    of the form within a single scrollable row below main row.\n     */\n    mode: {\n      type: String,\n      default: 'list',\n      validator: val => ['list', 'form'].includes(val),\n    },\n    /**\n     * this variable is just used in mode `list`, for mode `form` leave it empty and use variable `formFilterList`\n     *  to provide a list of filters instead.\n     * provide a list of available filters, needs to be an array of objects with the following properties:\n     *\n     *    **label** `string` - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `labelPropertyName.filter`.\n     *    **id** `string` - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `identifierPropertyName.filter`.\n     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.\n     *    **hidden** `boolean` - filters with this attribute true will be filtered from\n     *      displayed filter list.\n     *    **freetext_allowed** `boolean` - determines if predetermined options from `options`\n     *      property are used or autocomplete is used.\n     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled\n     *      vocabulary options.\n     *     **subsets** `string[]` - if a filter of `type` 'text' or 'chips' with\n     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which\n     *      the autosuggest results should also be shown - add the filter identifiers here\n     */\n    filterList: {\n      type: Array,\n      default: () => ([]),\n      validator: val => !val.length\n        // make sure a filter type is present and type is other than chips or freetext is\n        // allowed - otherwise it needs to have an options property\n        || (val.every(v => !!v.type\n          && (!['chips', 'chipssingle'].includes(v.type) || v.freetext_allowed || !!v.options))),\n    },\n    /**\n     * this variable is just used in mode `list`, for mode `form` leave it empty and use property `formFilterValues`\n     *  to provide values per filter instead.\n     * possibility to set applied filters from outside, for necessary object properties\n     * see `filterList` (except `options` - this property is not necessary for applied filters)\n     */\n    appliedFilters: {\n      type: Array,\n      default: () => ([]),\n      // don't check for options on applied filters - not necessary\n      validator: val => !val.length || val.every(v => v.type),\n    },\n    /**\n     * in mode `list` specify a default value for a filter that is set when none of the\n     * available filters is selected, should have the following properties:\n     *\n     *    **label** `string` - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `labelPropertyName.filter`.\n     *    **id** `string` - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `identifierPropertyName.filter`.\n     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.\n     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled\n     *      vocabulary options.\n     *    **filter_values** `Object[], string[], Object` - the values selected - object for date\n     *    or array of objects or strings for type `text`, type `chips` and `chipssingle`,\n     *\n     *    defaultFilter does not need the property `subsets` since results for all filters are\n     *    shown per default\n     *\n     *  this property is not relevant in mode `form`\n     */\n    defaultFilter: {\n      type: Object,\n      default: () => ({\n        label: 'Fulltext',\n        id: 'default',\n        type: 'text',\n        options: [],\n        filter_values: [],\n      }),\n      validator: val => val === null || (val.type\n        && (!['chips', 'chipssingle'].includes(val.type) || val.options)),\n    },\n    /**\n     * this variable is just used in mode `form`, for mode `list` leave it empty and use property `filterList`\n     *  to provide a list of filters instead.\n     * for mode 'form' provide a specification for the form fields in the form of [OpenAPi\n     *  schema object](https://swagger.io/specification/#schema-object).\n     *  see also [BaseForm](BaseForm) `form-field-json` prop - currently all field types except\n     *    `multiline` and `chips-below` and for date/time fields only single date, date range and date time fields\n     *    are supported. Also field groups are supported but maximum nesting level is 1.\n     */\n    formFilterList: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * this variable is just used in mode `form`, for mode `list` leave it empty and use property `appliedFilters`\n     *  to provide values per filter instead.\n     * provide values for the fields specified in `formFilterList`. Main filter can be filled by adding a `default` property.\n     */\n    formFilterValues: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * pass props for [BaseForm](BaseForm) directly via this prop, for example `autocompleteResults`,\n     *  `isLoading` or `fieldProps` (except `valueList` and `formFieldJson` which are passed separately\n     *   since they are also utilized (and modified) in this component).\n     */\n    formProps: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * provide the component with the fetched autocomplete results\n     * (drop down options).\n     * this needs to be an object array with the properties specified in\n     * `autocompletePropertyNames`.\n     */\n    autocompleteResults: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * specify a language (ISO 639-1) (used for label if label is language specific object\n     * e.g. `{ de: 'xxx', en: 'yyy' }`) or for date display conversion in mode 'form'.\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * set the row loader from outside per row index\n     */\n    isLoadingIndex: {\n      type: Number,\n      default: -1,\n    },\n    /**\n     * specify informational texts for the component - this needs to be an object with the following\n     * properties (if you don't want to display any text leave an empty string):\n     *\n     *     **title**: text shown as first line on the drop-down in filters area for mode `list`.\n     *     **subtext**: text shown as second line on the drop-down in filters area for mode `list`.\n     *     **availableOptions**: text shown with chips options for controlled vocabulary\n     *     search` for mode `list`.\n     *     **collapsedDateTime**: for mode `form`: set the text for the collapsed filter row which is\n     *      displayed for date or time values of ranges when only one field is filled. (e.g. `until 12.12.2023`)\n     *     **advancedButtonLabel**: button text displayed for Advanced Search Toggle button for mode `form`.\n     *\n     *  The values of this object might be plain text or a key for an i18n file.\n     */\n    advancedSearchText: {\n      type: Object,\n      default: () => ({\n        title: 'Advanced Search',\n        subtext: 'Select a filter',\n        availableOptions: 'Available options',\n        collapsedDateTime: {\n          from: 'from',\n          until: 'until',\n          range: 'to',\n        },\n        advancedButtonLabel: 'Advanced Search',\n      }),\n    },\n    /**\n     * specify informational texts for the drop-down - this needs to be an object with the following\n     * properties:\n     *\n     *     **autocompleteNoOptions**: info text shown when autocomplete search does not yield\n     *        any results.\n     *     **autocompleteOngoing**: info text displayed while autocomplete search is ongoing\n     *        (and no previous results are displayed).\n     *     **autocompleteInitial**: info text shown when user first opens the search\n     *        component.\n     *     **chipsNoOptions**: info text shown when no options for controlled vocabulary search\n     *        are available (anymore).\n     *     **chipsMaxOptions**: text displayed if more than max number of options that can be\n     *        displayed are available (configure via prop `maxNumberControlledOptions`).\n     *     **chipsNoMatch**: text displayed if string in input does not match any options.\n     *     **chipsOngoing**: info text shown when controlled vocabulary chips are being\n     *        fetched.\n     *\n     *  The values of this object might be plain text or a key for an i18n file\n     * This prop can be ignored when the `no-options` slot is used.\n     */\n    dropDownInfoTexts: {\n      type: Object,\n      default: () => ({\n        autocompleteNoOptions: 'No matching options found',\n        autocompleteOngoing: 'Autocomplete is being fetched...',\n        autocompleteInitial: 'Please start typing or select a filter to see options',\n        chipsNoOptions: 'No more options available',\n        chipsMaxOptions: 'Please start typing to see options',\n        chipsNoMatch: 'No matching options were found',\n        chipsOngoing: 'Options are being loaded...',\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['autocompleteNoOptions', 'autocompleteOngoing', 'autocompleteInitial',\n        'chipsNoOptions', 'chipsOngoing', 'chipsMaxOptions', 'chipsNoMatch']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * add a placeholder for the search input, either a string used for every row or\n     * add separate values for main filter row and already added filters\n     * properties:\n     *     **filterRow**: for already added filter rows.\n     *     **main**: for the primary search input field.\n     *\n     *  each of these specific placeholders can again be a string or an object with different\n     *  placeholders for each search type (`text`, `chips`, `date`)\n     */\n    placeholder: {\n      type: [Object, String],\n      default: () => ({\n        filterRow: 'Add values to your filter',\n        main: 'Search and Discover',\n      }),\n      validator: val => typeof val === 'string' || ['filterRow', 'main']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * specify the object property that can be used for identification of filters,\n     * autocomplete options and controlled vocabulary options.\n     *   Could be a string (used for all the mentioned objects) or an object with the following\n     *   properties:\n     *     **filter**: identifier property name in filter objects.\n     *     **autocompleteOption**: identifier property name in autocomplete option objects.\n     *     **controlledVocabularyOption**: identifier property name in controlled\n     *     vocabulary option objects.\n     *     **formInputs**: for mode 'form' in case the form contains chips or autocomplete input fields,\n     *      the object properties for label and identifier need to be set here (in case they are different\n     *      from the input components default (e.g. see [BaseChipsInput](BaseChipsInput) `identifierPropertyName`))\n     *      if `identifierPropertyName` is also set via `fieldProps` the latter is the preferred value.\n     *  Caveat: Please note that the property `idInternal` is used for internal handlings and the property\n     *    might be overwritten\n     */\n    identifierPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'id',\n        autocompleteOption: 'id',\n        controlledVocabularyOption: 'id',\n        formInputs: 'source',\n      }),\n    },\n    /**\n     * specify the object property that should be used for label display of filters,\n     * autocomplete options and controlled vocabulary options.\n     *   Could be a string (used for all the mentioned objects) or an object with the following\n     *   properties:\n     *     **filter**: label property name in filter objects.\n     *     **autocompleteOption**: label property name in autocomplete option objects.\n     *     **controlledVocabularyOption**: label property name in controlled\n     *     vocabulary option objects.\n     *     **formInputs**: for mode 'form' in case the form contains chips or autocomplete input fields,\n     *      the object properties for label and identifier need to be set here (in case they are different\n     *      from the input components default (e.g. see [BaseChipsInput](BaseChipsInput) `labelPropertyName`))\n     *      if `labelPropertyName` is also set via `fieldProps` the latter is the preferred value.\n     *    Caveat: Please note that the property `labelInternal` is used for internal handlings and the property\n     *    might be overwritten\n     */\n    labelPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'label',\n        autocompleteOption: 'title',\n        controlledVocabularyOption: 'label',\n        formInputs: 'label',\n      }),\n    },\n    /**\n     * autocomplete results need a label, and id and a data property that contains all the actual\n     * autocomplete results for that specific category\n     * TODO: make category optional\n     */\n    autocompletePropertyNames: {\n      type: Object,\n      default: () => ({\n        label: 'label',\n        id: 'id',\n        data: 'data',\n      }),\n      // check if all the necessary attributes are included in the provided object\n      validator: val => ['id', 'label', 'data'].every(key => Object.keys(val).includes(key)),\n    },\n    /**\n     * this prop gives the option to add assistive text for screen readers for\n     *  the BaseSearch component.\n     * properties:\n     * **addFilter**: text/label used for add filter icon for mode `list`.\n     * **removeFilter**: text/label used for remove filter icon for mode `list`.\n     * **selectFilterLabel**: label (not visible) used for filter chips input field for mode `list`.\n     * **searchLabel**: label (not visible) used for search input field.\n     * **selectedOption**: text read when a selected option is focused (currently only\n     *  working for type chips with autocomplete (=freetext_allowed))\n     * **loaderActive**: text that is announced when autocomplete results are being fetched (prop\n     *  `isLoading` is set `true`)\n     * **autocompleteResultsRetrieved**: text announced when autocomplete results are returned.\n     *  use {optionsNumber} and {collectionsNumber} in the string to announce the number of\n     *  total options and collections found respectively.\n     * **autocompleteNoResults**: Text announced when no results were found with a given\n     *  search string.\n     * **autocompleteInitial**: Text announced when no search string was provided for\n     *  autocomplete.\n     * **categoryAnnouncement**: Text announced when a new category is entered in the\n     *  autocomplete drop down options list with keyboard navigation. string '{label}' will\n     *  be replaced by the actual specified category label\n     * **optionsAnnouncement**: announced together with category when in category selection\n     *  mode (after using arrowLeft key on autocomplete input) - to give the user a feeling\n     *  how many options were found for the announced category. string '{number}' will be\n     *  replaced by the number of entries in that category.\n     * **autocompleteOptionFilledToForm**: text announced when an option was selected from the autocomplete\n     *  dropdown, and it is filled into the respective form field. (only for mode `form`)\n     * **advancedButtonDescription**: button description for Advanced Search Toggle button for mode `form`.\n     *      For accessibility purposes. You may add the string {state} which will be replaced with the respective\n     *      'open' and 'close' value specified in `formState` (see below). Only relevant for mode `form`.\n     * **formState**: an object with properties `open` (text that is read when form is closed and button\n     *      functionality is to open the form) and `close` (text that is read when form is open and button\n     *      functionality is to close the form). Only relevant for mode `form`.\n     * **removeAllFiltersLabel**: label for the remove icon in the collapsed filter row.\n     *     Only relevant for mode `form`. For accessibility purposes\n     * **removeFilterValueNotification**: notification that is read by screen readers when a filter\n     *      value was removed. Add the string {value} to read the filter value that was removed and\n     *      {label} to read the label of the filter from which the value was removed. Only relevant for mode `form`.\n     * **collapsedFilterRowRemovedNotification**: notification read when the last filter was removed from\n     *      the collapsed filter row. Or remove row was clicked. Only relevant for mode `form`.\n     * **collapsedAppliedFiltersLabel**: description for the filters in the collapsed filter row.\n     *      Only relevant for mode `form`. For accessibility purposes.\n     * **collapsedBooleanFilterValue**: Set text that should be read for a boolean filter value. You may add\n     *      the string {label} which will be replaced by the filter label.\n     *      Only relevant for mode `form`. For accessibility purposes.\n     * **collapsedOptionToRemoveSelected**: text read when an option is focused (and thus selected), should\n     *  announce to the screen reader user that option can now be removed via Backspace or Delete.\n     * **results**: provide text that should be announced when the search has\n     *  yielded results (or not).\n     *\n     * Caveat: `results` has a watcher attached to trigger the\n     *    announcement so make sure the property values are reset after filling them\n     *    by using update:assistive-text or resetting it manually (after a timeout)\n     */\n    assistiveText: {\n      type: Object,\n      default: () => ({\n        addFilter: 'Add filter',\n        removeFilter: 'Remove filter',\n        selectFilterLabel: 'Select filter',\n        searchLabel: 'Search for Entries',\n        selectedOption: '',\n        autocompleteLoaderActive: 'loading options.',\n        autocompleteResultsRetrieved: '{optionsNumber} options found in {collectionsNumber} categories.',\n        autocompleteNoResults: 'No results found.',\n        autocompleteInitial: 'Please start typing to see suggestions.',\n        categoryAnnouncement: 'category {label}.',\n        optionsAnnouncement: '{number} options.',\n        autocompleteOptionFilledToForm: 'option {optionLabel} filled to field {fieldLabel}.',\n        advancedButtonDescription: 'Click to {state} advanced search form.',\n        formState: {\n          open: 'open',\n          close: 'close',\n        },\n        removeAllFiltersLabel: 'Remove all filters.',\n        removeFilterValueNotification: 'Filter value {value} was removed from filter {label}.',\n        collapsedFilterRowRemovedNotification: 'All search filters were reset.',\n        collapsedAppliedFiltersLabel: 'Currently applied Filters',\n        collapsedBooleanFilterValue: 'Filter {label} was set',\n        collapsedOptionToRemoveSelected: 'Press delete or backspace to remove.',\n        results: '',\n      }),\n    },\n    /**\n     * if desired the box shadow around the search rows can be deactivated here\n     */\n    applyBoxShadow: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * use this prop to set a delay in ms before date input calendar is displayed\n     */\n    dateFieldDelay: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * prop only relevant for mode `form`\n     * set advanced search (form) visibility from outside\n     * this can also be used to not show the advanced search after initial loading\n     */\n    advancedFormOpen: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * set this flag to `true` to highlight autocomplete option characters that match\n     *  the current search input string\n     */\n    highlightAutocompleteMatch: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `highlightAutocompleteMatch` is set `true`\n     *  provide tag names to style the matched characters\n     *  (without '<' and '>', e.g. ['b'] for <b>)\n     */\n    highlightAutocompleteTags: {\n      type: Array,\n      default: () => ([]),\n    },\n    /**\n     * mode `form`: if necessary selected chip text can  be rendered as v-html directive\n     *  either set this prop `true` or `false`\n     *\n     * this will only be applied to chips with an identifier property and of course\n     *   can only apply to form field field_type `chips`\n     *\n     * if only chips of certain form fields should be rendered as html use prop\n     *  `formProps.fieldProps.interpretChipsLabelAsHtml` or if certain fields should\n     *  be excluded set this prop to `true` and set `formProps.fieldProps.interpretChipsLabelAsHtml`\n     *  for that field `false`\n     */\n    interpretFormChipsLabelAsHtml: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  emits: ['search', 'fetch-autocomplete', 'fetch-form-autocomplete', 'update:applied-filters', 'update:form-filter-values', 'update:advanced-form-open'],\n  setup() {\n    /**\n     * set up a reference to the element to be able to attach the announcements element\n     * @type {Ref<UnwrapRef<null|HTMLElement>>}\n     */\n    const searchContainer = ref(null);\n    /**\n     * insert an HTML element with aria-live assertive that will announce the\n     * search result\n     * @type {Ref<UnwrapRef<string>>}\n     */\n    const { announcement } = useAnnouncer(searchContainer);\n    return {\n      searchContainer,\n      announcement,\n    };\n  },\n  data() {\n    return {\n      /**\n       * internal variable to handle applied filters also when set from outside\n       * @type {Filter[]}\n       */\n      appliedFiltersInt: [],\n      /**\n       * the filter used in the main search field - not added to applied filters yet\n       * @type {Filter}\n       */\n      mainFilter: null,\n      /**\n       * store the autocomplete results for each filter in this variable to have\n       * it available even when other filter was used in the meantime\n       * @type {Object[]}\n       */\n      filtersAutocompleteResults: [],\n      /**\n       * a variable storing the info for which filter autocomplete results were\n       * requested\n       * @type {number}\n       */\n      autocompleteIndex: -1,\n      originalMainFilter: null,\n      /**\n       * variable to control showing of advanced search form in mode 'form'\n       * @type {boolean}\n       */\n      formOpen: true,\n      /**\n       * internal representation of formFilterValues in order to be able to modify\n       * @type {Object}\n       */\n      formFilterValuesInt: {},\n      /**\n       * store filter values to see if filter values changed before triggering search\n       * @type {Object}\n       */\n      originalFilterValues: null,\n      /**\n       * render BaseForm with delay to reduce flickering and flinching\n       * @type {boolean}\n       */\n      formMounted: false,\n      /**\n       * resize observer for specific element (instead of window)\n       * (only mode `form`)\n       */\n      resizeObserver: null,\n      /**\n       * button text should only be shown if enough space is available\n       * (only mode `form`)\n       */\n      showAdvancedSearchButtonText: true,\n      /**\n       * variable to contain assistive text to inform user of actions\n       * @type {string}\n       */\n      assistiveTextNotification: '',\n    };\n  },\n  computed: {\n    amendedFormProps() {\n      // if the prop is false - don't bother any further and just return\n      // the formProps as is\n      if (!this.interpretFormChipsLabelAsHtml) {\n        return this.formProps;\n      }\n      // else get the fieldProps out of formProps\n      const fieldProps = this.formProps.fieldProps || {};\n      // now iterate over the fields and add (or overwrite) the `interpretChipsLabelAsHtml`\n      // prop\n      const updatedFormFieldProps = this.renderFormChipsLabelAsHtml.reduce((prev, renderProp) => ({\n        ...prev,\n        ...this.addNewPropertyValueToNestedObject(\n          renderProp,\n          fieldProps || {},\n          'interpretChipsLabelAsHtml',\n          true,\n          // individually set fields should always have priority\n          // over `interpretFormChipsLabelAsHtml`\n          false,\n        ),\n      }), {});\n\n      return {\n        // add all other specified form props\n        ...this.formProps,\n        // and the modified fieldprops\n        fieldProps: {\n          // also don't lose the field props of non-chips fields or not\n          // modified ones\n          ...fieldProps,\n          // and add the modified ones\n          ...updatedFormFieldProps,\n        },\n      };\n    },\n    /**\n     * store the loading state of every filter\n     *\n     * @returns {boolean[]}\n     */\n    filtersLoadingState() {\n      return [\n        ...this.appliedFiltersInt\n          .map((filter, index) => (this.autocompleteIndex === index)),\n        // add one at the end for main search field (not added to applied filters array yet)\n        this.autocompleteIndex === this.appliedFiltersInt.length,\n      ];\n    },\n    /**\n     * the actually displayed filter categories (visible in the filter drop down for mode 'list')\n     * @returns {Filter[]}\n     */\n    displayedFilters() {\n      // filter filters with property hidden true\n      const displayed = [...this.filterList].filter(f => !f.hidden);\n      // sort them\n      return sort(displayed, this.labelPropertyName.filter);\n    },\n    /**\n     * main filter is always added to the emitted filter array last to maintain same order\n     *  to what is rendered (main filter lowest) so we need to get the last filter index\n     * @returns {number}\n     */\n    mainFilterIndex() {\n      const lastFilterIndex = this.appliedFilters.length - 1;\n      return lastFilterIndex > 0 ? lastFilterIndex : 0;\n    },\n    /**\n     * transform values to collapsed form and back\n     */\n    collapsedFiltersArray: {\n      /**\n       * use formFieldValuesInt to create the correct structure for BaseCollapsedFilterRow\n       * @returns {{\n         *  filter_values: { values: Object[], fieldType: string, fieldId: string },\n         *  label: string,\n         *  id: string,\n       *  }[]}\n       */\n      get() {\n        return Object.entries(this.formFilterValuesInt)\n          // only use filters that have values\n          .filter(([, value]) => hasData(value))\n          // sort the values in the order of the form so the collapsed display has the same order\n          .sort(([key1], [key2]) => {\n            if (this.formFilterList[key1] && this.formFilterList[key2]\n                && this.formFilterList[key1]['x-attrs'].order > this.formFilterList[key2]['x-attrs'].order) {\n              return 1;\n            }\n            return -1;\n          })\n          // map data to collapsed filter array structure\n          .map(([key, value]) => {\n            // get the OpenAPI json field information for the field in question\n            const formFilterData = this.formFilterList[key];\n            // check here if field is repeatable\n            const isRepeatableField = formFilterData.type === 'array' && !formFilterData['x-attrs'].field_type.includes('chips');\n            // if value list is not already an array (because it is a repeatable field) make it an array\n            const valueList = isRepeatableField ? value : [value];\n            return valueList.map((repeatableEntry, index) => ({\n              // label that will be displayed on top of each collapsed filter\n              labelInternal: formFilterData.title,\n              // add a special id that allows to identify repeatable fields (applied in reverse mapping\n              // ~line 555)\n              idInternal: `${key}${isRepeatableField ? `-group-${index}` : ''}`,\n              // the actual filter values and filter information for each field (important for field groups)\n              filter_values: this.getCollapsedFilterValue(repeatableEntry, formFilterData, key),\n            }));\n          })\n          .flat();\n      },\n      /**\n       * maps changes that were made to collapsed filters back to formFilterValuesInt\n       * @param {{ filter_values: Object[]|Object[[]], label: string, id: string, type: string|string[] }[]} val - changed collapsed filter values\n       */\n      set(val) {\n        // loop through every collapsed filter array value and create a form filter values compatible\n        // object structure out of it again\n        this.formFilterValuesInt = val.reduce((prev, filter) => {\n          // necessary because of field groups to remove index (added in line 538) from id\n          // get actual field id and indicator if field was repeatable field\n          const [, filterId, groupMatch] = filter.idInternal.match(/(.*?)(-group-\\d*)?$/);\n          // get the form field data for the id\n          const filterData = this.formFilterList[filterId];\n          // get the correctly mapped filter values\n          const filterValues = this.setFormFilterValues(filter.filter_values, filterData);\n          // if field is repeatable - check if there are already values field into the object property\n          // if yes store them in a value to be able to concat or use an empty array\n          const previousValues = groupMatch && prev && prev[filterId] ? prev[filterId] : [];\n          return {\n            ...prev,\n            // if field is repeatable join the previous values with the new values otherwise just\n            // set currently retrieved values\n            [filterId]: groupMatch ? previousValues.concat(filterValues) : filterValues,\n          };\n        }, {});\n        // trigger search after filters changed\n        this.search();\n      },\n    },\n    renderFormChipsLabelAsHtml() {\n      // first get all form field props\n      const { fieldProps } = this.formProps;\n      // if no fieldProps were specified just use the prop value\n      if (!fieldProps) return this.interpretFormChipsLabelAsHtml;\n      // else we need to check if prop `renderChipsLabelAsHtml` was specified for\n      // a chips input field - done via recursive (because of subforms) function\n      const fieldsToSetTrue = this.filterHtmlRenderFields(this.formFilterList);\n\n      // check if values were set for individual fields, otherwise fall back\n      // to the prop value\n      return fieldsToSetTrue.length ? fieldsToSetTrue : this.interpretFormChipsLabelAsHtml;\n    },\n    /**\n     * create an internal row id for unique identification of added filter rows\n     *\n     * @returns {string}\n     */\n    rowId() {\n      return createId();\n    },\n    /**\n     * advanced button description for mode `form`\n     * @returns {string}\n     */\n    advancedButtonDescription() {\n      // if value was not set for any reason just return an empty string\n      if (!this.assistiveText.advancedButtonDescription) return '';\n      return this.assistiveText.advancedButtonDescription\n        .replace('{state}', this.assistiveText.formState[this.formOpen ? 'close' : 'open']);\n    },\n  },\n  watch: {\n    /**\n     * watch prop autocompleteResults to assign it to the correct filter row\n     */\n    autocompleteResults(val) {\n      // check if autocomplete is active for any field ( > -1 )\n      if (this.autocompleteIndex >= 0) {\n        // if yes set the results on the filter row active\n        this.$set(this.filtersAutocompleteResults, this.autocompleteIndex, [...val]);\n        this.autocompleteIndex = -1;\n      }\n    },\n    /**\n     * have appliedFilters in sync with parent to be able to set them from outside\n     */\n    appliedFiltersInt: {\n      handler(val) {\n        // check if val is actually different from prop value\n        if (JSON.stringify(val) !== JSON.stringify(this.appliedFilters.slice(1))) {\n          // if yes - inform parent\n          this.$emit('update:applied-filters', [...val, this.mainFilter]);\n        }\n      },\n      deep: true,\n    },\n    /**\n     * have appliedFilters in sync with parent to be able to set them from outside\n     */\n    appliedFilters: {\n      handler(val) {\n        // check if value is different from internal value\n        if (val\n          && JSON.stringify(val.slice(0, -1)) !== JSON.stringify(this.appliedFiltersInt)) {\n          // if yes - update internal value\n          [, ...this.appliedFiltersInt] = JSON.parse(JSON\n            .stringify([val, ...val.slice(0, -1)]));\n        }\n        // also check if main filter is different separately!\n        if (val && val.length >= 1\n          && JSON.stringify(this.mainFilter) !== JSON.stringify(val[this.mainFilterIndex])) {\n          [this.mainFilter] = JSON.parse(JSON.stringify(val.slice(-1)));\n        } else if (!val || val < 1) {\n          this.mainFilter = { ...this.defaultFilter };\n        }\n      },\n      immediate: true,\n    },\n    /**\n     * watch main filter since changes are not directly handled via update:applied-filters\n     * event and trigger search if anything changed\n     * @param {Filter} val - the updated main filter\n     */\n    mainFilter(val) {\n      // make sure mainFilter exists and has property filter_values\n      if (val && val.filter_values) {\n        // store values to compare in variables\n        const mainFilterHasData = hasData(val.filter_values);\n        // for original filter also check right here if property filter_values actually\n        // exists\n        const originalMainFilterHasData = !!this.originalMainFilter\n          && !!this.originalMainFilter.filter_values\n          && hasData(this.originalMainFilter.filter_values);\n        // now check a) if originalMainFilter exists already and\n        // b) filter itself has switched (and there are actually data to search for)\n        // c) original data and current data diverge (only one of them does not have data)\n        // d) or both have data but data are different from each other\n        if (this.originalMainFilter\n          && ((mainFilterHasData && this.originalMainFilter[this.identifierPropertyName.filter]\n            !== val[this.identifierPropertyName.filter])\n          || mainFilterHasData !== originalMainFilterHasData\n          || (mainFilterHasData && originalMainFilterHasData\n          && (JSON.stringify(this.originalMainFilter.filter_values\n              !== JSON.stringify(val.filter_values)))))) {\n          // if so - update original data\n          this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n          // and trigger search\n          this.search(true);\n        }\n      }\n      /**\n       * inform parent of changes in applied filters - event emitted for mode `list`\n       *\n       * @event update:applied-filters\n       * @param {Filter[]} - the list of updated applied filters\n       */\n      this.$emit('update:applied-filters', [...this.appliedFiltersInt, val]);\n      // also emit updated form filter values at this point\n      this.$emit('update:form-filter-values', { ...this.formFilterValuesInt, default: this.mainFilter.filter_values });\n    },\n    /**\n     * have formFilterValues in sync with parent to be able to set them from outside\n     */\n    formFilterValuesInt: {\n      handler(val) {\n        // get filters without default first to ensure comparability\n        const filtersWithoutDefault = { ...this.formFilterValues };\n        this.$delete(filtersWithoutDefault, 'default');\n        // check if val is actually different from prop value\n        if (JSON.stringify(val) !== JSON.stringify(filtersWithoutDefault)) {\n          // if yes - inform parent\n          /**\n           * inform parent of form filter value changes - event emitted for mode `form`\n           * @event update:form-filter-values\n           * @param {Object} - a form filter values object with a property for each filter field - main filter values\n           *  are available under the default property\n           *\n           */\n          this.$emit('update:form-filter-values', { ...val, default: this.mainFilter.filter_values });\n        }\n      },\n      deep: true,\n    },\n    /**\n     * have formFilterValues in sync with parent to be able to set them from outside\n     */\n    formFilterValues: {\n      handler(val) {\n        if (this.mode === 'form') {\n          // check if value is different from internal value\n          if (val\n            && JSON.stringify(val) !== JSON.stringify({\n              ...this.formFilterValuesInt,\n              default: this.mainFilter.filter_values,\n            })) {\n            // remove the default key from the form filter values that should fill form\n            const { default: _, ...filterValuesNoMain } = val;\n            // update internal values\n            this.formFilterValuesInt = JSON.parse(JSON.stringify(filterValuesNoMain));\n            // set default property to mainFilter.filter_values\n            this.$set(this.mainFilter, 'filter_values', val.default || ['']);\n            // trigger search with updated values\n            this.search();\n          }\n        }\n      },\n      immediate: true,\n    },\n    advancedFormOpen: {\n      handler(val) {\n        this.formOpen = val;\n      },\n      immediate: true,\n    },\n    formOpen(val) {\n      /**\n       * in mode `form` when 'advanced search' button was clicked\n       * @event update:advanced-form-open\n       * @type {boolean}\n       */\n      this.$emit('update:advanced-form-open', val);\n    },\n    /**\n     * function to automatically reset the assistiveTextNotification\n     * after using it\n     * @param {string} val\n     */\n    assistiveTextNotification(val) {\n      // setting the value will trigger the screenreader\n      if (val) {\n        setTimeout(() => {\n          // after that text can be removed again\n          this.assistiveTextNotification = '';\n        }, 300);\n      }\n    },\n  },\n  created() {\n    // check if mainFilter was already set (e.g. from outside)\n    if (!this.mainFilter) {\n      // if not set default filter\n      this.mainFilter = JSON.parse(JSON.stringify(this.defaultFilter));\n    }\n    // copy these filter values to later be able to determine if filters changed before\n    // triggering search\n    this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n  },\n  mounted() {\n    // only add observer for mode `form`\n    if (this.mode === 'form') {\n      // to listen to element with instead of window width create an observer!\n      this.initObserver();\n    }\n  },\n  beforeDestroy() {\n    if (this.resizeObserver) this.resizeObserver.unobserve(this.$refs.searchContainer);\n  },\n  methods: {\n    extractNestedPropertyValue,\n    /**\n     * GENERAL FUNCTIONALITIES\n     */\n\n    /**\n     * initialize resize observer to steer advanced search button appearance\n     */\n    initObserver() {\n      const resizeObserver = new ResizeObserver(debounce(50, ([container]) => {\n        this.showAdvancedSearchButtonText = container.contentRect.width >= 460;\n      }));\n      resizeObserver.observe(this.$refs.searchContainer);\n      this.resizeObserver = resizeObserver;\n    },\n    /**\n     * @param {string} input - the search string to autocomplete\n     * @param {Filter} filter - the filter the autocomplete was triggered for\n     * @param {number} index - the index of the filter\n     */\n    fetchAutocomplete({ input, filter }, index) {\n      if (input) {\n        // if input string present set autocomplete variable to correct filter row\n        this.autocompleteIndex = index;\n      } else {\n        // else reset the autocomplete results\n        this.$set(this.filtersAutocompleteResults, index, []);\n      }\n      // stil emit fetch-autocomplete no matter if input string present or not to give\n      // parent opportunity to also update\n      /**\n       * inform parent to fetch autocomplete data for the provided filter\n       *\n       * @event fetch-autocomplete\n       * @type {Object} - object with the following properties:\n       * @property {string} searchString - the string to autocomplete\n       * @property {Filter} filter - the filter object\n       * @property {number} index - the filter index of all filters (main and applied)\n       */\n      this.$emit('fetch-autocomplete', { searchString: input, filter, index });\n    },\n    /**\n     * search function\n     * @param {boolean} alwaysTrigger - set true if search should be triggered irrespective of\n     *  appliedFiltersInt changes (needed for changes in mainFilter which is checked in the\n     *  mainFilter watcher already)\n     */\n    search(alwaysTrigger = false) {\n      // get the correct filter values list according to component mode\n      const modeFilterList = this.mode === 'form' ? this.formFilterList : this.filterList;\n      // define variable to store modified filters list to be emitted\n      let searchFilterList = [];\n      if (this.mode === 'form') {\n        searchFilterList = Object.entries(this.formFilterValuesInt)\n          // also only keep the filters that have filter values\n          .filter(([, filterValues]) => hasData(filterValues))\n          .map(([filterKey, filterValues]) => ({\n            [this.identifierPropertyName.filter]: filterKey,\n            type: modeFilterList[filterKey]?.['x-attrs']?.field_type ?? 'text',\n            // only keep filter values that actually have values (relevant for groups!)\n            filter_values: typeof filterValues === 'object' && filterValues.length\n            && !modeFilterList[filterKey]?.type.includes('chips')\n              ? filterValues.filter(filterValue => hasData(filterValue)) : filterValues,\n          }));\n      } else {\n        searchFilterList = this.appliedFiltersInt\n          // and only keep the properties relevant for search\n          // eslint-disable-next-line camelcase\n          .map(filter => ({\n            [this.identifierPropertyName.filter]: filter[this.identifierPropertyName.filter],\n            type: filter.type,\n            filter_values: filter.filter_values,\n          }));\n      }\n      // if there are changes in filters or main filter trigger search (=if alwaysTrigger was\n      // set true in mainFilter watcher)\n      if (alwaysTrigger || JSON.stringify(this.originalFilterValues) !== JSON\n        .stringify(searchFilterList)) {\n        // update the original value\n        this.originalFilterValues = JSON.parse(JSON.stringify(searchFilterList));\n        // also minimize main filter\n        const minMainFilter = {\n          [this.identifierPropertyName.filter]: this.mainFilter[this.identifierPropertyName.filter],\n          type: this.mainFilter.type,\n          filter_values: this.mainFilter.filter_values,\n        };\n        /**\n         * inform parent that search should be triggered\n         *\n         * @event search\n         * @param {Filter[]} - the updated list of applied filters - last filter in the list is always the main\n         *  filter (relevant especially for mode `form`)\n         */\n        this.$emit('search', [...searchFilterList, minMainFilter]);\n      }\n    },\n    /**\n     * MODE 'LIST' FUNCTIONALITIES\n     */\n\n    /**\n     * function to add a filter row after '+' icon was triggered\n     */\n    addFilterRow({ filter, input }) {\n      // first handle remaining input and add it to filter values if necessary\n      // therefore have separate variable and assign the original values first (in case no\n      // modifications are necessary)\n      let newFilterValues = filter.type.includes('date') ? filter.filter_values\n        : [...filter.filter_values];\n      // have variable for search trigger in case additional values are added and should trigger\n      // search\n      let triggerSearch = false;\n      // now check if type is text and the current value saved in filter does not equal text input\n      if (filter.type === 'text' && input.trim() && (!filter.filter_values || !filter.filter_values.length\n        || this.mainFilter.filter_values[0] !== input.trim())) {\n        // in that case assign new value and set search trigger true\n        newFilterValues = [input];\n        triggerSearch = true;\n        // else if type is freetext chips add the value at the end of the array\n      } else if (filter.type === 'chips' && filter.freetext_allowed && input.trim()) {\n        newFilterValues = [\n          ...filter.filter_values,\n          {\n            [this.labelPropertyName.autocompleteOption]: input,\n          },\n        ];\n        // also here triger search after\n        triggerSearch = true;\n      }\n      // now finally add filter to internal filter list\n      this.appliedFiltersInt.push({\n        ...filter,\n        filter_values: newFilterValues,\n      });\n      // and reset the main filter\n      this.mainFilter = {\n        ...this.defaultFilter,\n        filter_values: null,\n      };\n      // and store the main filter to compare to later\n      this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n      // now check if search should be triggered\n      if (triggerSearch) {\n        this.search();\n      }\n      // now focus new added row search input but wait until it is rendered\n      this.$nextTick(() => {\n        // get the correct field from all input fields of that element\n        const newSearchInputField = Array.from(this.$refs.mainSearch.$el\n          .getElementsByTagName('input'))\n          .find(element => element.id.includes('search-input'));\n        newSearchInputField.focus();\n      });\n    },\n    /**\n     * remove filter after 'x' was triggered\n     * @param {Filter} filter - the filter to remove\n     * @param {number} index - the index of the filter\n     */\n    removeFilter(filter, index) {\n      this.appliedFiltersInt.splice(index, 1);\n      // trigger search to update search results\n      this.search();\n    },\n    /**\n     * for mode 'list'\n     * function called when a filter object within a filter row changes\n     * @param {Filter} filter - the filter that was altered\n     * @param {number} index - the index of the filter\n     */\n    updateFilter(filter, index) {\n      this.$set(this.appliedFiltersInt, index, JSON.parse(JSON.stringify(filter)));\n      // trigger search to update search results\n      this.search();\n    },\n\n    /**\n     * MODE 'FORM' FUNCTIONALITIES\n     */\n\n    /**\n     * function called when an option was selected from main search autocomplete OR on\n     *  search input TAB keydown\n     *\n     * @param {Object} entry - the selected option\n     * @param {string} collectionId - the option category selected - this needs to match a\n     *  formFilter id\n     */\n    fillOptionToForm({ entry, collectionId }) {\n      // check if mode is form and if collection id is present\n      // (otherwise value is default filter string input)\n      if (this.mode === 'form' && collectionId\n        // and if option is already included in the selected options to prevent double key problems\n        && !this.formFilterValuesInt[collectionId]\n          ?.map(selectedOption => selectedOption[this.identifierPropertyName.formInputs])\n          .includes(entry[this.identifierPropertyName.autocompleteOption])) {\n        // get the filter field information if there is any\n        const fieldInformation = this.formFilterList[collectionId];\n        // check if there is actual field information --> default filter is not part of\n        // swagger list! so all but default filter will go here!\n        if (fieldInformation) {\n          const fieldXAttrs = fieldInformation['x-attrs'];\n          // check the type of field that the value should be added to (we assume the only possibilities\n          // are chips or text - other types are currently NOT implemented and would need to be added here!)\n          if (fieldXAttrs.field_type === 'chips') {\n            // in order to be able to set the correct properties for the chip display in the input field\n            // we might need to map the label and id properties of the autocomplete option to the label and\n            // id properties of the input field - since an individual option for a field might have been\n            // set via fieldProps - we need to check for that first\n            const fieldProps = this.formProps.fieldProps?.[collectionId] || {};\n            // check if label prop was set otherwise use the default form input one\n            const labelProp = fieldProps.labelPropertyName\n              || this.labelPropertyName.formInputs;\n            // check if id prop was set otherwise use the default form input one\n            const idProp = fieldProps.identifierPropertyName\n              || this.identifierPropertyName.formInputs;\n            // map the information from the search autocomplete to the chips form field\n            // required values\n            const chipsFormFieldValue = {\n              // map search autocomplete result to chips form field required values\n              [labelProp]: entry[this.labelPropertyName.autocompleteOption],\n              [idProp]: entry[this.identifierPropertyName.autocompleteOption],\n              // HOWEVER - in order to enable customization of the properties used in the front\n              // end - e.g. to add discriminatory terms html we also leave the rest of the\n              // object properties and actually give them PRIORITY over the newly created ones!\n              // (so e.g. if the property `displayLabel` was already added to the autocomplete option\n              // with the appropriate tags and styling then this will not be overwritten by\n              // entry[this.labelPropertyName.autocompleteOption] but be retained\n              ...entry,\n            };\n            // for multi chips - add value to array\n            if (fieldInformation.type === 'array') {\n              // check if property exists already in formFilterValuesInt\n              if (this.formFilterValuesInt[collectionId]) {\n                this.formFilterValuesInt[collectionId].push(chipsFormFieldValue);\n              } else {\n                this.$set(this.formFilterValuesInt, collectionId, [chipsFormFieldValue]);\n              }\n              // for single chips - replace value\n            } else if (fieldInformation.type === 'object') {\n              this.$set(this.formFilterValuesInt, collectionId, chipsFormFieldValue);\n            }\n          } else if (!fieldXAttrs || fieldXAttrs.field_type === 'text') {\n            this.$set(\n              this.formFilterValuesInt,\n              collectionId,\n              entry[this.labelPropertyName.autocompleteOption] ?? entry,\n            );\n          }\n          // main filter filter values should remain empty\n          this.mainFilter.filter_values = [];\n          // announce to screen reader user that field was added to advanced search form\n          // if the appropriate text was set\n          if (this.assistiveText.autocompleteOptionFilledToForm) {\n            // get option label from entry param\n            const optionLabel = entry[this.labelPropertyName.autocompleteOption];\n            // and field label from fieldInformation\n            const fieldLabel = fieldInformation.title;\n            // assemble announcement\n            this.announcement = this.assistiveText.autocompleteOptionFilledToForm\n              .replace('{optionLabel}', optionLabel)\n              .replace('{fieldLabel}', fieldLabel);\n          }\n\n          // this does not trigger an update event from BaseForm so search needs to be triggered manually here\n          this.search();\n        } else {\n          // if it is main filter set the value to main filter instead\n          this.$set(\n            this.mainFilter,\n            'filter_values',\n            [entry],\n          );\n          // and also update original filter with newly set data\n          this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n          // this does not trigger an update event from BaseForm so search needs to be triggered manually here\n          // since main filter is not evaluated in filter comparison set alwaysTrigger true\n          this.search(true);\n        }\n      }\n    },\n    /**\n     * function called from form if one of the form fields needs autocomplete\n     *\n     * @param {Object} params - see event for object properties sent to parent\n     */\n    fetchFormAutocomplete(params) {\n      /**\n       * event emitted when a form drop down (e.g. chips input field) needs autocomplete\n       *\n       * @event fetch-form-autocomplete\n       *\n       * @property {string} value - the string to autocomplete\n       * @property {string} name - the name of the field\n       * @property {string} source - the url to request the data from\n       * @property {?string} equivalent - string specified for related fields. e.g. for contributor roles equivalent is `contributor`\n       * @property {?string[]} parentFields - in case the autocomplete event originates from a subform the subform id's (field property names) are specified in this array (most nested property last)\n       */\n      this.$emit('fetch-form-autocomplete', params);\n    },\n    /**\n     * for mode 'form'\n     * update the form filters when an event is received from form that values have changed\n     * @param {Object} newFilterValueList - the new filter values object\n     */\n    updateFormFilters(newFilterValueList) {\n      this.formFilterValuesInt = JSON.parse(JSON.stringify(newFilterValueList));\n      this.search();\n    },\n    /**\n     * function called by BaseCollapsedFilter row if 'x' was clicked to remove all filters\n     */\n    removeAllFilters() {\n      // reset form filter values\n      this.formFilterValuesInt = {};\n      this.assistiveTextNotification = this.assistiveText.collapsedFilterRowRemovedNotification || '';\n      // trigger search without filters\n      this.search();\n    },\n    /**\n     * reduce the flickering and flinching from base form fields rendering by\n     *  only making the element visible after component mount and additionally\n     *  apply a timeout\n     */\n    formIsMounted() {\n      setTimeout(() => {\n        this.formMounted = true;\n      }, 200);\n    },\n    /**\n     * function triggered when 'advanced search' button is clicked in 'form' mode\n     */\n    openAdvancedSearch() {\n      // close the main search autocomplete drop down since this is not in user focus\n      // anymore\n      this.$refs.mainSearch.isActive = false;\n      // toggle form\n      this.formOpen = !this.formOpen;\n    },\n    /**\n     * function to retrieve the filter values in reduced form the way CollapsedFilterRow needs them\n     * @param {any} values - the form field values\n     * @param {Object} fieldData - the OpenAPI json field information\n     * @param {string} fieldId - the id of the field to transform\n     * @param {string[]} parentFields - if field is a field group we also need the parent field name(s)\n     *  (in theory there could be many but BaseAdvancedSearch is currently only supporting one nesting level)\n     * @returns {[string, unknown]|[{label: string}]|string|{label: *}[]|boolean[]|[{label: (string|string)}]|*}\n     */\n    getCollapsedFilterValue(values, fieldData, fieldId, parentFields = []) {\n      const fieldType = fieldData['x-attrs'].field_type;\n      if (fieldType === 'integer' || fieldType === 'float' || typeof values === 'number') {\n        return {\n          values: [{\n            labelInternal: values.toString(),\n          }],\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'boolean' || typeof values === 'boolean') {\n        return {\n          values: [{\n            labelInternal: values,\n          }],\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'text' || fieldType === 'autocomplete' || typeof values === 'string') {\n        let formattedLabel = values;\n        if (fieldType === 'date' && values) {\n          // if type is date we need to parse the storage date to display values also considering\n          // possible minus\n          formattedLabel = this.formatToDisplayDate(values);\n        }\n        return {\n          values: [{\n            // if fieldType is date convert to de date locale for display\n            labelInternal: formattedLabel,\n          }],\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'chips') {\n        // check if general property names were overwritten for the specific field\n        const fieldProps = extractNestedPropertyValue(\n          parentFields.length ? [fieldId].concat(parentFields).join('.') : fieldId,\n          this.formProps.fieldProps,\n        );\n        const labelProp = fieldProps?.labelPropertyName\n          || this.labelPropertyName.formInputs;\n        const idProp = fieldProps?.identifierPropertyName\n          || this.identifierPropertyName.formInputs;\n        return {\n          values: values.map((chipValue) => {\n            // do not delete additional properties the chip might have\n            const additionalProperties = typeof chipValue === 'object' ? chipValue : {};\n            return ({\n              labelInternal: chipValue[labelProp] ?? chipValue,\n              idInternal: chipValue[idProp] || '',\n              ...additionalProperties,\n            });\n          }),\n          fieldId,\n          fieldType,\n        };\n      }\n      if (fieldType === 'group') {\n        return {\n          values: Object.entries(values)\n            .reduce((prev, [fieldKey, fieldValue]) => {\n              // add an array for each field in the group\n              prev.push(this.getCollapsedFilterValue(\n                fieldValue,\n                // depending if group is repeatable or not get to properties attribute\n                fieldData.items ? fieldData.items.properties[fieldKey] : fieldData.properties[fieldKey],\n                fieldKey,\n                [fieldKey].concat(parentFields),\n              ));\n              return prev;\n            }, []),\n          fieldType,\n          fieldId,\n        };\n      }\n      // any date or time range field\n      if (fieldType === 'date' && typeof values !== 'string') {\n        return {\n          values: Object.values(values)\n            .map(chipValue => ({\n              // convert to de date locale for display\n              labelInternal: chipValue ? this.formatToDisplayDate(chipValue) : '',\n            })),\n          fieldId,\n          // BaseCollapsedRow needs information if date is type daterange, timerange or datetime\n          // so alter to 'date' and 'time' for daterange and timerange respectively and 'datetime'\n          // for datetime.\n          fieldType: Object.keys(values).reduce((prev, key) => {\n            const currentType = key.split('_')[0];\n            return currentType !== prev ? prev + currentType : prev;\n          }, ''),\n        };\n      }\n      // NOT COVERED: multiline and chips below\n      return values;\n    },\n    formatToDisplayDate(storageDate) {\n      const { groups: { minus, year, month, day } = {} } = storageDate\n        .match(/((?<minus>-)?(?<year>\\d{4})-?(?<month>\\d{2})?-?(?<day>\\d{2})?)/) || {};\n      return year ? `${day ? `${day}.` : ''}${month ? `${month}.` : ''}${minus || ''}${year}` : '';\n    },\n    formatToStorageDate(storageDate) {\n      const { groups: { minus, year, month, day } = {} } = storageDate\n        .match(/(?<day>\\d{2})?\\.?(?<month>\\d{2})?\\.?(?<minus>-)?(?<year>\\d{4})/) || {};\n      return year ? `${minus || ''}${year}${month ? `-${month}` : ''}${day ? `-${day}` : ''}` : '';\n    },\n    /**\n     * function to transform collapsed values to form field values (necessary if something changed\n     * in collapsed values, e.g. a filter value was removed)\n     * @param {{ values: Object[], fieldId: string, fieldType: string }} collapsedValues - the updated collapsed\n     *  values coming from collapsed filter row\n     * @param {Object} filterData - the relevant OpenAPI form field information\n     * @param {string[]} parentFields - if field is a field group we also need the parent field name(s)\n     *  (in theory there could be many but BaseAdvancedSearch is currently only supporting one nesting level)\n     * @returns {any} - value returned depending on the filter type\n     */\n    setFormFilterValues(collapsedValues, filterData, parentFields = []) {\n      // get the relevant information out of collapsed values\n      const { values, fieldType, fieldId } = collapsedValues;\n      // case string\n      if (filterData.type === 'string') {\n        // special case date that needs to transform display to storage date format again\n        if (fieldType === 'date') {\n          return this.formatToStorageDate(values[0].labelInternal);\n        }\n        return values[0].labelInternal;\n      }\n      // case boolean value\n      if (filterData.type === 'boolean') {\n        return values[0].labelInternal;\n      }\n      // case number value\n      if (filterData.type === 'integer' || filterData.type === 'float') {\n        return Number(values[0].labelInternal);\n        // date could be string if it is just a single date or an object in all other cases\n      }\n      // case date field (not string)\n      if ((fieldType.includes('date') || fieldType.includes('time')) && filterData.type === 'object') {\n        const objectProperties = Object.keys(filterData.properties);\n        return values.reduce((valueObject, value, index) => ({\n          ...valueObject,\n          [objectProperties[index]]: this.formatToStorageDate(value.labelInternal),\n        }), {});\n      }\n      // case chips input field\n      if (fieldType.includes('chips')) {\n        // we need to take into consideration that custom label and identifier property names\n        // might have been set for a specific form field - so we need to check `formProps.fieldProps`\n        // (or the corresponding nested field for type 'group') for that field first and use these\n        // values if present\n        const fieldProps = extractNestedPropertyValue(\n          parentFields.length ? [fieldId].concat(parentFields).join('.') : fieldId,\n          this.formProps.fieldProps,\n        );\n        const labelProp = fieldProps?.labelPropertyName\n          || this.labelPropertyName.formInputs;\n        const idProp = fieldProps?.identifierPropertyName\n          || this.identifierPropertyName.formInputs;\n        return values.filter(filterValue => !!filterValue.labelInternal)\n          .map((filterValue) => {\n            // in order to keep any additional properties the chips entry might have, clone\n            // the object and remove internally added variables again\n            const additionalProperties = JSON.parse(JSON.stringify(filterValue));\n            this.$delete(additionalProperties, 'labelInternal');\n            this.$delete(additionalProperties, 'idInternal');\n            return ({\n              // and add it to the values that are returned\n              ...additionalProperties,\n              // apart from the labelProperty and the identifierProperty\n              [labelProp]: filterValue.labelInternal,\n              [idProp]: filterValue.idInternal,\n            });\n          });\n      }\n      // case repeatable fields where every repeated field or field group is a separate filter entry\n      if (!fieldType.includes('chips') && filterData.type === 'array') {\n        return this.setFormFilterValues(\n          collapsedValues,\n          filterData.items,\n        );\n      }\n      // case field groups\n      if (fieldType === 'group'\n        && filterData.type === 'object') {\n        return values\n          .filter(value => hasData(value.values))\n          .reduce((o, k) => ({\n            ...o,\n            [k.fieldId]: this.setFormFilterValues(\n              k,\n              filterData.properties[k.fieldId],\n              [k.fieldId].concat(parentFields),\n            ),\n          }), {});\n      }\n      return null;\n    },\n    filterHtmlRenderFields(formFieldInfo, parentFields = []) {\n      // get the field props needed later\n      const { fieldProps } = this.formProps;\n      // iterate over all form fields given in formFieldInfo\n      return Object.entries(formFieldInfo)\n        .reduce((prev, [key, values]) => {\n          // get the field type from the x attributes\n          const { field_type: fieldType } = values['x-attrs'] ? values['x-attrs'] : {};\n          // check if form fields are nested (subform)\n          if (fieldType === 'group') {\n            // and recursively iterate over these fields as well\n            const subFields = this.filterHtmlRenderFields(\n              values.properties || values.items.properties,\n              [key].concat(parentFields),\n            );\n            // if fields with `interpretChipsLabelAsHtml` `true` are found\n            // add them in the form { [key]: ['subField1', 'SubField2'] }\n            return subFields.length ? prev.concat({\n              [key]: subFields,\n            }) : prev;\n          }\n          // only add fields that are type chips\n          if (fieldType === 'chips') {\n            // get the fieldProps set for that specific field - if it is a nested field we\n            // need to extract them with the function below - else we can use fieldProps directly\n            const keyProps = ((parentFields.length\n              ? extractNestedPropertyValue(parentFields.join('.'), fieldProps) : fieldProps) || {})[key];\n            // now check if field key should be added to the list - 2 possibilities to add:\n            // a) prop `interpretFormChipsLabelAsHtml` is `false` - and the fieldProp for that specific\n            //  field is set\n            // b) prop `interpretFormChipsLabelAsHtml` was set `true` to cover all fields and\n            //  specifically exclude this one\n            if ((!this.interpretFormChipsLabelAsHtml && keyProps?.interpretChipsLabelAsHtml)\n              || (this.interpretFormChipsLabelAsHtml && (!keyProps\n                || !Object.keys(keyProps).includes('interpretChipsLabelAsHtml') || keyProps.interpretChipsLabelAsHtml))) {\n              return prev.concat(key);\n            }\n          }\n          // if any of the conditions fail just return the list unaltered\n          return prev;\n        }, []);\n    },\n    /**\n     * a function to add a new property to a nested object\n     *\n     * @param {string|Object} renderProp - this is either a string - then an object\n     *  with `previousFieldProps` and this property will be created, or an object in\n     *  the style of { [parentProperty]: ['childProp1', 'childProp2'] } - this object\n     *  can also be nested deeper - 'childProp2' could instead also be an object in the\n     *  style above again\n     * @param {Object} fieldProps - an object for all fields including `renderProp` that contains\n     *  other properties `renderProp` or [renderProp.key] should receive\n     *  so: { [renderProp]: { renderPropProperties } }\n     * @param {string} propertyName - the name of the property to be added or overwritten\n     * @param {*} propertyValue - the value of the property to be added or overwritten\n     * @param {boolean} [overwritePreviousValues=true] - define if a preexisting value for\n     *  `propertyName` should be overwritten\n     * @returns {{[p: string]: *}|{}} - returns an object in the style\n     *  { [renderProp|renderProp.key]: { ...previousFieldProps, [propertyName]: propertyValue }}\n     *  or a deeper nested version thereof\n     */\n    addNewPropertyValueToNestedObject(\n      renderProp,\n      fieldProps,\n      propertyName,\n      propertyValue,\n      overwritePreviousValues = false,\n    ) {\n      // check if renderProp is a string\n      if (typeof renderProp === 'string') {\n        const previousFieldProps = fieldProps[renderProp] || {};\n        return {\n          [renderProp]: {\n            // if previous values should be overwritten - place the add the previous\n            // object properties first\n            ...(overwritePreviousValues ? previousFieldProps : {}),\n            [propertyName]: propertyValue,\n            // otherwise add them after the new property\n            ...(!overwritePreviousValues ? previousFieldProps : {}),\n          },\n        };\n      }\n      if (typeof renderProp === 'object') {\n        return Object.entries(renderProp).reduce((prev, [renderPropKey, renderPropValues]) => ({\n          ...prev,\n          // add an object in the form of [formGroupPropertyName]: {},\n          [renderPropKey]: {\n            // add all the field props that have been defined for that form group fields\n            // previously\n            ...fieldProps[renderPropKey],\n            // then overwrite form group fields that are defined in the renderProp array\n            ...renderPropValues.reduce((prevObject, field) => ({\n              ...prevObject,\n              // add property to fieldProps of this field\n              ...this.addNewPropertyValueToNestedObject(\n                field,\n                fieldProps[renderPropKey] || {},\n                propertyName,\n                propertyValue,\n              ),\n            }), {}),\n          },\n        }), {});\n      }\n      return {};\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../../styles/variables\";\n\n.base-advanced-search {\n  .base-advanced-search__filter-row {\n    margin-bottom: $spacing;\n  }\n\n  .base-advanced-search__expand-button {\n    border-left: $separation-line;\n    margin-left: $spacing-small;\n    padding-right: $spacing-small;\n  }\n\n  .base-advanced-search__search-form {\n    border-top: $separation-line;\n\n    &.base-advanced-search__search-form--hidden {\n      display: none;\n    }\n  }\n}\n\n</style>\n"],"names":["_sfc_main","BaseAdvancedSearchRow","defineAsyncComponent","m","InsertTextAsHtml","val","v","prop","key","searchContainer","ref","announcement","useAnnouncer","fieldProps","updatedFormFieldProps","prev","renderProp","filter","index","displayed","f","sort","lastFilterIndex","value","hasData","key1","key2","formFilterData","isRepeatableField","repeatableEntry","filterId","groupMatch","filterData","filterValues","previousValues","fieldsToSetTrue","createId","mainFilterHasData","originalMainFilterHasData","filtersWithoutDefault","_","filterValuesNoMain","extractNestedPropertyValue","resizeObserver","debounce","container","input","alwaysTrigger","modeFilterList","searchFilterList","filterKey","_b","_a","_c","filterValue","minMainFilter","newFilterValues","triggerSearch","element","entry","collectionId","selectedOption","fieldInformation","fieldXAttrs","labelProp","idProp","chipsFormFieldValue","optionLabel","fieldLabel","params","newFilterValueList","values","fieldData","fieldId","parentFields","fieldType","formattedLabel","chipValue","additionalProperties","fieldKey","fieldValue","currentType","storageDate","minus","year","month","day","collapsedValues","objectProperties","valueObject","o","k","formFieldInfo","subFields","keyProps","propertyName","propertyValue","overwritePreviousValues","previousFieldProps","renderPropKey","renderPropValues","prevObject","field"],"mappings":";;;;;;;AAoTA,MAAAA,IAAA;AAAA,EACA,MAAA;AAAA,EACA,YAAA;AAAA,IACA,uBAAAC;AAAA,IACA,wBAAAC,EAAA,MAAA,OAAA,oCAAA,EAAA,KAAA,CAAAC,MAAAA,EAAA,WAAAA,CAAA,CAAA;AAAA,IACA,UAAAD,EAAA,MAAA,OAAA,gCAAA,EAAA,KAAA,CAAAC,MAAAA,EAAA,WAAAA,CAAA,CAAA;AAAA,IACA,YAAAD,EAAA,MAAA,OAAA,oCAAA,EAAA,KAAA,CAAAC,MAAAA,EAAA,WAAAA,CAAA,CAAA;AAAA,EACA;AAAA,EACA,YAAA;AAAA,IACA,kBAAAC;AAAA,EACA;AAAA,EACA,OAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,MAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,MACA,WAAA,CAAAC,MAAA,CAAA,QAAA,MAAA,EAAA,SAAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAuBA,YAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,MAAA,CAAA;AAAA,MACA,WAAA,CAAAA,MAAA,CAAAA,EAAA,UAGAA,EAAA,MAAA,CAAAC,MAAA,CAAA,CAAAA,EAAA,SACA,CAAA,CAAA,SAAA,aAAA,EAAA,SAAAA,EAAA,IAAA,KAAAA,EAAA,oBAAA,CAAA,CAAAA,EAAA,QAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,gBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,MAAA,CAAA;AAAA;AAAA,MAEA,WAAA,CAAAD,MAAA,CAAAA,EAAA,UAAAA,EAAA,MAAA,CAAAC,MAAAA,EAAA,IAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsBA,eAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,OAAA;AAAA,QACA,IAAA;AAAA,QACA,MAAA;AAAA,QACA,SAAA,CAAA;AAAA,QACA,eAAA,CAAA;AAAA,MACA;AAAA,MACA,WAAA,CAAAD,MAAAA,MAAA,QAAAA,EAAA,SACA,CAAA,CAAA,SAAA,aAAA,EAAA,SAAAA,EAAA,IAAA,KAAAA,EAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,gBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,kBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,WAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,qBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,MAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,UAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,gBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,oBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,OAAA;AAAA,QACA,SAAA;AAAA,QACA,kBAAA;AAAA,QACA,mBAAA;AAAA,UACA,MAAA;AAAA,UACA,OAAA;AAAA,UACA,OAAA;AAAA,QACA;AAAA,QACA,qBAAA;AAAA,MACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsBA,mBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,uBAAA;AAAA,QACA,qBAAA;AAAA,QACA,qBAAA;AAAA,QACA,gBAAA;AAAA,QACA,iBAAA;AAAA,QACA,cAAA;AAAA,QACA,cAAA;AAAA,MACA;AAAA;AAAA,MAEA,WAAA,CAAAA,MAAA;AAAA,QAAA;AAAA,QAAA;AAAA,QAAA;AAAA,QACA;AAAA,QAAA;AAAA,QAAA;AAAA,QAAA;AAAA,MAAA,EACA,MAAA,CAAAE,MAAA,OAAA,KAAAF,CAAA,EAAA,SAAAE,CAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,aAAA;AAAA,MACA,MAAA,CAAA,QAAA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,WAAA;AAAA,QACA,MAAA;AAAA,MACA;AAAA,MACA,WAAA,CAAAF,MAAA,OAAAA,KAAA,YAAA,CAAA,aAAA,MAAA,EACA,MAAA,CAAAE,MAAA,OAAA,KAAAF,CAAA,EAAA,SAAAE,CAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBA,wBAAA;AAAA,MACA,MAAA,CAAA,QAAA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,QAAA;AAAA,QACA,oBAAA;AAAA,QACA,4BAAA;AAAA,QACA,YAAA;AAAA,MACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBA,mBAAA;AAAA,MACA,MAAA,CAAA,QAAA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,QAAA;AAAA,QACA,oBAAA;AAAA,QACA,4BAAA;AAAA,QACA,YAAA;AAAA,MACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,2BAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,OAAA;AAAA,QACA,IAAA;AAAA,QACA,MAAA;AAAA,MACA;AAAA;AAAA,MAEA,WAAA,CAAAF,MAAA,CAAA,MAAA,SAAA,MAAA,EAAA,MAAA,CAAAG,MAAA,OAAA,KAAAH,CAAA,EAAA,SAAAG,CAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAwDA,eAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,OAAA;AAAA,QACA,WAAA;AAAA,QACA,cAAA;AAAA,QACA,mBAAA;AAAA,QACA,aAAA;AAAA,QACA,gBAAA;AAAA,QACA,0BAAA;AAAA,QACA,8BAAA;AAAA,QACA,uBAAA;AAAA,QACA,qBAAA;AAAA,QACA,sBAAA;AAAA,QACA,qBAAA;AAAA,QACA,gCAAA;AAAA,QACA,2BAAA;AAAA,QACA,WAAA;AAAA,UACA,MAAA;AAAA,UACA,OAAA;AAAA,QACA;AAAA,QACA,uBAAA;AAAA,QACA,+BAAA;AAAA,QACA,uCAAA;AAAA,QACA,8BAAA;AAAA,QACA,6BAAA;AAAA,QACA,iCAAA;AAAA,QACA,SAAA;AAAA,MACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,gBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,gBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,kBAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,4BAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,2BAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA,MAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAaA,+BAAA;AAAA,MACA,MAAA;AAAA,MACA,SAAA;AAAA,IACA;AAAA,EACA;AAAA,EACA,OAAA,CAAA,UAAA,sBAAA,2BAAA,0BAAA,6BAAA,2BAAA;AAAA,EACA,QAAA;AAKA,UAAAC,IAAAC,EAAA,IAAA,GAMA,EAAA,cAAAC,EAAA,IAAAC,EAAAH,CAAA;AACA,WAAA;AAAA,MACA,iBAAAA;AAAA,MACA,cAAAE;AAAA,IACA;AAAA,EACA;AAAA,EACA,OAAA;AACA,WAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,mBAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,YAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,4BAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,mBAAA;AAAA,MACA,oBAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,UAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,qBAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,sBAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,aAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,gBAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,8BAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,2BAAA;AAAA,IACA;AAAA,EACA;AAAA,EACA,UAAA;AAAA,IACA,mBAAA;AAGA,UAAA,CAAA,KAAA;AACA,eAAA,KAAA;AAGA,YAAAE,IAAA,KAAA,UAAA,cAAA,CAAA,GAGAC,IAAA,KAAA,2BAAA,OAAA,CAAAC,GAAAC,OAAA;AAAA,QACA,GAAAD;AAAA,QACA,GAAA,KAAA;AAAA,UACAC;AAAA,UACAH,KAAA,CAAA;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA,UAGA;AAAA,QACA;AAAA,MACA,IAAA,CAAA,CAAA;AAEA,aAAA;AAAA;AAAA,QAEA,GAAA,KAAA;AAAA;AAAA,QAEA,YAAA;AAAA;AAAA;AAAA,UAGA,GAAAA;AAAA;AAAA,UAEA,GAAAC;AAAA,QACA;AAAA,MACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,sBAAA;AACA,aAAA;AAAA,QACA,GAAA,KAAA,kBACA,IAAA,CAAAG,GAAAC,MAAA,KAAA,sBAAAA,CAAA;AAAA;AAAA,QAEA,KAAA,sBAAA,KAAA,kBAAA;AAAA,MACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,mBAAA;AAEA,YAAAC,IAAA,CAAA,GAAA,KAAA,UAAA,EAAA,OAAA,CAAAC,MAAA,CAAAA,EAAA,MAAA;AAEA,aAAAC,EAAAF,GAAA,KAAA,kBAAA,MAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,kBAAA;AACA,YAAAG,IAAA,KAAA,eAAA,SAAA;AACA,aAAAA,IAAA,IAAAA,IAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,uBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASA,MAAA;AACA,eAAA,OAAA,QAAA,KAAA,mBAAA,EAEA,OAAA,CAAA,CAAA,EAAAC,CAAA,MAAAC,EAAAD,CAAA,CAAA,EAEA,KAAA,CAAA,CAAAE,CAAA,GAAA,CAAAC,CAAA,MACA,KAAA,eAAAD,CAAA,KAAA,KAAA,eAAAC,CAAA,KACA,KAAA,eAAAD,CAAA,EAAA,SAAA,EAAA,QAAA,KAAA,eAAAC,CAAA,EAAA,SAAA,EAAA,QACA,IAEA,EACA,EAEA,IAAA,CAAA,CAAAlB,GAAAe,CAAA,MAAA;AAEA,gBAAAI,IAAA,KAAA,eAAAnB,CAAA,GAEAoB,IAAAD,EAAA,SAAA,WAAA,CAAAA,EAAA,SAAA,EAAA,WAAA,SAAA,OAAA;AAGA,kBADAC,IAAAL,IAAA,CAAAA,CAAA,GACA,IAAA,CAAAM,GAAAX,OAAA;AAAA;AAAA,YAEA,eAAAS,EAAA;AAAA;AAAA;AAAA,YAGA,YAAA,GAAAnB,CAAA,GAAAoB,IAAA,UAAAV,CAAA,KAAA,EAAA;AAAA;AAAA,YAEA,eAAA,KAAA,wBAAAW,GAAAF,GAAAnB,CAAA;AAAA,UACA,EAAA;AAAA,QACA,CAAA,EACA;MACA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,IAAAH,GAAA;AAGA,aAAA,sBAAAA,EAAA,OAAA,CAAAU,GAAAE,MAAA;AAGA,gBAAA,CAAA,EAAAa,GAAAC,CAAA,IAAAd,EAAA,WAAA,MAAA,qBAAA,GAEAe,IAAA,KAAA,eAAAF,CAAA,GAEAG,IAAA,KAAA,oBAAAhB,EAAA,eAAAe,CAAA,GAGAE,IAAAH,KAAAhB,KAAAA,EAAAe,CAAA,IAAAf,EAAAe,CAAA,IAAA;AACA,iBAAA;AAAA,YACA,GAAAf;AAAA;AAAA;AAAA,YAGA,CAAAe,CAAA,GAAAC,IAAAG,EAAA,OAAAD,CAAA,IAAAA;AAAA,UACA;AAAA,QACA,GAAA,CAAA,CAAA,GAEA,KAAA,OAAA;AAAA,MACA;AAAA,IACA;AAAA,IACA,6BAAA;AAEA,YAAA,EAAA,YAAApB,EAAA,IAAA,KAAA;AAEA,UAAA,CAAAA;AAAA,eAAA,KAAA;AAGA,YAAAsB,IAAA,KAAA,uBAAA,KAAA,cAAA;AAIA,aAAAA,EAAA,SAAAA,IAAA,KAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,QAAA;AACA,aAAAC,EAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,4BAAA;AAEA,aAAA,KAAA,cAAA,4BACA,KAAA,cAAA,0BACA,QAAA,WAAA,KAAA,cAAA,UAAA,KAAA,WAAA,UAAA,MAAA,CAAA,IAFA;AAAA,IAGA;AAAA,EACA;AAAA,EACA,OAAA;AAAA;AAAA;AAAA;AAAA,IAIA,oBAAA/B,GAAA;AAEA,MAAA,KAAA,qBAAA,MAEA,KAAA,KAAA,KAAA,4BAAA,KAAA,mBAAA,CAAA,GAAAA,CAAA,CAAA,GACA,KAAA,oBAAA;AAAA,IAEA;AAAA;AAAA;AAAA;AAAA,IAIA,mBAAA;AAAA,MACA,QAAAA,GAAA;AAEA,QAAA,KAAA,UAAAA,CAAA,MAAA,KAAA,UAAA,KAAA,eAAA,MAAA,CAAA,CAAA,KAEA,KAAA,MAAA,0BAAA,CAAA,GAAAA,GAAA,KAAA,UAAA,CAAA;AAAA,MAEA;AAAA,MACA,MAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,gBAAA;AAAA,MACA,QAAAA,GAAA;AAEA,QAAAA,KACA,KAAA,UAAAA,EAAA,MAAA,GAAA,EAAA,CAAA,MAAA,KAAA,UAAA,KAAA,iBAAA,MAEA,CAAA,EAAA,GAAA,KAAA,iBAAA,IAAA,KAAA,MAAA,KACA,UAAA,CAAAA,GAAA,GAAAA,EAAA,MAAA,GAAA,EAAA,CAAA,CAAA,CAAA,IAGAA,KAAAA,EAAA,UAAA,KACA,KAAA,UAAA,KAAA,UAAA,MAAA,KAAA,UAAAA,EAAA,KAAA,eAAA,CAAA,IACA,CAAA,KAAA,UAAA,IAAA,KAAA,MAAA,KAAA,UAAAA,EAAA,MAAA,EAAA,CAAA,CAAA,KACA,CAAAA,KAAAA,IAAA,OACA,KAAA,aAAA,EAAA,GAAA,KAAA,cAAA;AAAA,MAEA;AAAA,MACA,WAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,WAAAA,GAAA;AAEA,UAAAA,KAAAA,EAAA,eAAA;AAEA,cAAAgC,IAAAb,EAAAnB,EAAA,aAAA,GAGAiC,IAAA,CAAA,CAAA,KAAA,sBACA,CAAA,CAAA,KAAA,mBAAA,iBACAd,EAAA,KAAA,mBAAA,aAAA;AAKA,QAAA,KAAA,uBACAa,KAAA,KAAA,mBAAA,KAAA,uBAAA,MAAA,MACAhC,EAAA,KAAA,uBAAA,MAAA,KACAgC,MAAAC,KACAD,KAAAC,KACA,KAAA,UAAA,KAAA,mBAAA,kBACA,KAAA,UAAAjC,EAAA,aAAA,CAAA,OAEA,KAAA,qBAAA,KAAA,MAAA,KAAA,UAAA,KAAA,UAAA,CAAA,GAEA,KAAA,OAAA,EAAA;AAAA,MAEA;AAOA,WAAA,MAAA,0BAAA,CAAA,GAAA,KAAA,mBAAAA,CAAA,CAAA,GAEA,KAAA,MAAA,6BAAA,EAAA,GAAA,KAAA,qBAAA,SAAA,KAAA,WAAA,cAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,qBAAA;AAAA,MACA,QAAAA,GAAA;AAEA,cAAAkC,IAAA,EAAA,GAAA,KAAA,iBAAA;AACA,aAAA,QAAAA,GAAA,SAAA,GAEA,KAAA,UAAAlC,CAAA,MAAA,KAAA,UAAAkC,CAAA,KASA,KAAA,MAAA,6BAAA,EAAA,GAAAlC,GAAA,SAAA,KAAA,WAAA,cAAA,CAAA;AAAA,MAEA;AAAA,MACA,MAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,kBAAA;AAAA,MACA,QAAAA,GAAA;AACA,YAAA,KAAA,SAAA,UAEAA,KACA,KAAA,UAAAA,CAAA,MAAA,KAAA,UAAA;AAAA,UACA,GAAA,KAAA;AAAA,UACA,SAAA,KAAA,WAAA;AAAA,QACA,CAAA,GAAA;AAEA,gBAAA,EAAA,SAAAmC,GAAA,GAAAC,EAAA,IAAApC;AAEA,eAAA,sBAAA,KAAA,MAAA,KAAA,UAAAoC,CAAA,CAAA,GAEA,KAAA,KAAA,KAAA,YAAA,iBAAApC,EAAA,WAAA,CAAA,EAAA,CAAA,GAEA,KAAA,OAAA;AAAA,QACA;AAAA,MAEA;AAAA,MACA,WAAA;AAAA,IACA;AAAA,IACA,kBAAA;AAAA,MACA,QAAAA,GAAA;AACA,aAAA,WAAAA;AAAA,MACA;AAAA,MACA,WAAA;AAAA,IACA;AAAA,IACA,SAAAA,GAAA;AAMA,WAAA,MAAA,6BAAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,0BAAAA,GAAA;AAEA,MAAAA,KACA,WAAA,MAAA;AAEA,aAAA,4BAAA;AAAA,MACA,GAAA,GAAA;AAAA,IAEA;AAAA,EACA;AAAA,EACA,UAAA;AAEA,IAAA,KAAA,eAEA,KAAA,aAAA,KAAA,MAAA,KAAA,UAAA,KAAA,aAAA,CAAA,IAIA,KAAA,qBAAA,KAAA,MAAA,KAAA,UAAA,KAAA,UAAA,CAAA;AAAA,EACA;AAAA,EACA,UAAA;AAEA,IAAA,KAAA,SAAA,UAEA,KAAA,aAAA;AAAA,EAEA;AAAA,EACA,gBAAA;AACA,IAAA,KAAA,kBAAA,KAAA,eAAA,UAAA,KAAA,MAAA,eAAA;AAAA,EACA;AAAA,EACA,SAAA;AAAA,IACA,4BAAAqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,eAAA;AACA,YAAAC,IAAA,IAAA,eAAAC,EAAA,IAAA,CAAA,CAAAC,CAAA,MAAA;AACA,aAAA,+BAAAA,EAAA,YAAA,SAAA;AAAA,MACA,CAAA,CAAA;AACA,MAAAF,EAAA,QAAA,KAAA,MAAA,eAAA,GACA,KAAA,iBAAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,kBAAA,EAAA,OAAAG,GAAA,QAAA7B,EAAA,GAAAC,GAAA;AACA,MAAA4B,IAEA,KAAA,oBAAA5B,IAGA,KAAA,KAAA,KAAA,4BAAAA,GAAA,CAAA,CAAA,GAaA,KAAA,MAAA,sBAAA,EAAA,cAAA4B,GAAA,QAAA7B,GAAA,OAAAC,EAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,OAAA6B,IAAA,IAAA;AAEA,YAAAC,IAAA,KAAA,SAAA,SAAA,KAAA,iBAAA,KAAA;AAEA,UAAAC,IAAA,CAAA;AAyBA,UAxBA,KAAA,SAAA,SACAA,IAAA,OAAA,QAAA,KAAA,mBAAA,EAEA,OAAA,CAAA,CAAA,EAAAhB,CAAA,MAAAT,EAAAS,CAAA,CAAA,EACA,IAAA,CAAA,CAAAiB,GAAAjB,CAAA,MAAA;;AAAA;AAAA,UACA,CAAA,KAAA,uBAAA,MAAA,GAAAiB;AAAA,UACA,QAAAC,KAAAC,IAAAJ,EAAAE,CAAA,MAAA,gBAAAE,EAAA,eAAA,gBAAAD,EAAA,eAAA;AAAA;AAAA,UAEA,eAAA,OAAAlB,KAAA,YAAAA,EAAA,UACA,GAAAoB,IAAAL,EAAAE,CAAA,MAAA,QAAAG,EAAA,KAAA,SAAA,YACApB,EAAA,OAAA,CAAAqB,MAAA9B,EAAA8B,CAAA,CAAA,IAAArB;AAAA,QACA;AAAA,OAAA,IAEAgB,IAAA,KAAA,kBAGA,IAAA,CAAAhC,OAAA;AAAA,QACA,CAAA,KAAA,uBAAA,MAAA,GAAAA,EAAA,KAAA,uBAAA,MAAA;AAAA,QACA,MAAAA,EAAA;AAAA,QACA,eAAAA,EAAA;AAAA,MACA,EAAA,GAIA8B,KAAA,KAAA,UAAA,KAAA,oBAAA,MAAA,KACA,UAAAE,CAAA,GAAA;AAEA,aAAA,uBAAA,KAAA,MAAA,KAAA,UAAAA,CAAA,CAAA;AAEA,cAAAM,IAAA;AAAA,UACA,CAAA,KAAA,uBAAA,MAAA,GAAA,KAAA,WAAA,KAAA,uBAAA,MAAA;AAAA,UACA,MAAA,KAAA,WAAA;AAAA,UACA,eAAA,KAAA,WAAA;AAAA,QACA;AAQA,aAAA,MAAA,UAAA,CAAA,GAAAN,GAAAM,CAAA,CAAA;AAAA,MACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,aAAA,EAAA,QAAAtC,GAAA,OAAA6B,KAAA;AAIA,UAAAU,IAAAvC,EAAA,KAAA,SAAA,MAAA,IAAAA,EAAA,gBACA,CAAA,GAAAA,EAAA,aAAA,GAGAwC,IAAA;AAEA,MAAAxC,EAAA,SAAA,UAAA6B,EAAA,KAAA,MAAA,CAAA7B,EAAA,iBAAA,CAAAA,EAAA,cAAA,UACA,KAAA,WAAA,cAAA,CAAA,MAAA6B,EAAA,KAAA,MAEAU,IAAA,CAAAV,CAAA,GACAW,IAAA,MAEAxC,EAAA,SAAA,WAAAA,EAAA,oBAAA6B,EAAA,WACAU,IAAA;AAAA,QACA,GAAAvC,EAAA;AAAA,QACA;AAAA,UACA,CAAA,KAAA,kBAAA,kBAAA,GAAA6B;AAAA,QACA;AAAA,MACA,GAEAW,IAAA,KAGA,KAAA,kBAAA,KAAA;AAAA,QACA,GAAAxC;AAAA,QACA,eAAAuC;AAAA,MACA,CAAA,GAEA,KAAA,aAAA;AAAA,QACA,GAAA,KAAA;AAAA,QACA,eAAA;AAAA,MACA,GAEA,KAAA,qBAAA,KAAA,MAAA,KAAA,UAAA,KAAA,UAAA,CAAA,GAEAC,KACA,KAAA,OAAA,GAGA,KAAA,UAAA,MAAA;AAKA,QAHA,MAAA,KAAA,KAAA,MAAA,WAAA,IACA,qBAAA,OAAA,CAAA,EACA,KAAA,CAAAC,MAAAA,EAAA,GAAA,SAAA,cAAA,CAAA,EACA,MAAA;AAAA,MACA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,aAAAzC,GAAAC,GAAA;AACA,WAAA,kBAAA,OAAAA,GAAA,CAAA,GAEA,KAAA,OAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,aAAAD,GAAAC,GAAA;AACA,WAAA,KAAA,KAAA,mBAAAA,GAAA,KAAA,MAAA,KAAA,UAAAD,CAAA,CAAA,CAAA,GAEA,KAAA,OAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,iBAAA,EAAA,OAAA0C,GAAA,cAAAC,KAAA;;AAGA,UAAA,KAAA,SAAA,UAAAA,KAEA,GAAAR,IAAA,KAAA,oBAAAQ,CAAA,MAAA,QAAAR,EACA,IAAA,CAAAS,MAAAA,EAAA,KAAA,uBAAA,UAAA,GACA,SAAAF,EAAA,KAAA,uBAAA,kBAAA,KAAA;AAEA,cAAAG,IAAA,KAAA,eAAAF,CAAA;AAGA,YAAAE,GAAA;AACA,gBAAAC,IAAAD,EAAA,SAAA;AAGA,cAAAC,EAAA,eAAA,SAAA;AAKA,kBAAAlD,MAAAsC,IAAA,KAAA,UAAA,eAAA,gBAAAA,EAAAS,OAAA,IAEAI,IAAAnD,EAAA,qBACA,KAAA,kBAAA,YAEAoD,IAAApD,EAAA,0BACA,KAAA,uBAAA,YAGAqD,IAAA;AAAA;AAAA,cAEA,CAAAF,CAAA,GAAAL,EAAA,KAAA,kBAAA,kBAAA;AAAA,cACA,CAAAM,CAAA,GAAAN,EAAA,KAAA,uBAAA,kBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAOA,GAAAA;AAAA,YACA;AAEA,YAAAG,EAAA,SAAA,UAEA,KAAA,oBAAAF,CAAA,IACA,KAAA,oBAAAA,CAAA,EAAA,KAAAM,CAAA,IAEA,KAAA,KAAA,KAAA,qBAAAN,GAAA,CAAAM,CAAA,CAAA,IAGAJ,EAAA,SAAA,YACA,KAAA,KAAA,KAAA,qBAAAF,GAAAM,CAAA;AAAA,UAEA;AAAA,aAAA,CAAAH,KAAAA,EAAA,eAAA,WACA,KAAA;AAAA,cACA,KAAA;AAAA,cACAH;AAAA,cACAD,EAAA,KAAA,kBAAA,kBAAA,KAAAA;AAAA,YACA;AAMA,cAHA,KAAA,WAAA,gBAAA,IAGA,KAAA,cAAA,gCAAA;AAEA,kBAAAQ,IAAAR,EAAA,KAAA,kBAAA,kBAAA,GAEAS,IAAAN,EAAA;AAEA,iBAAA,eAAA,KAAA,cAAA,+BACA,QAAA,iBAAAK,CAAA,EACA,QAAA,gBAAAC,CAAA;AAAA,UACA;AAGA,eAAA,OAAA;AAAA,QACA;AAEA,eAAA;AAAA,YACA,KAAA;AAAA,YACA;AAAA,YACA,CAAAT,CAAA;AAAA,UACA,GAEA,KAAA,qBAAA,KAAA,MAAA,KAAA,UAAA,KAAA,UAAA,CAAA,GAGA,KAAA,OAAA,EAAA;AAAA,MAEA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,sBAAAU,GAAA;AAYA,WAAA,MAAA,2BAAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,kBAAAC,GAAA;AACA,WAAA,sBAAA,KAAA,MAAA,KAAA,UAAAA,CAAA,CAAA,GACA,KAAA,OAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,mBAAA;AAEA,WAAA,sBAAA,IACA,KAAA,4BAAA,KAAA,cAAA,yCAAA,IAEA,KAAA,OAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,gBAAA;AACA,iBAAA,MAAA;AACA,aAAA,cAAA;AAAA,MACA,GAAA,GAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,qBAAA;AAGA,WAAA,MAAA,WAAA,WAAA,IAEA,KAAA,WAAA,CAAA,KAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,wBAAAC,GAAAC,GAAAC,GAAAC,IAAA,CAAA,GAAA;AACA,YAAAC,IAAAH,EAAA,SAAA,EAAA;AACA,UAAAG,MAAA,aAAAA,MAAA,WAAA,OAAAJ,KAAA;AACA,eAAA;AAAA,UACA,QAAA,CAAA;AAAA,YACA,eAAAA,EAAA,SAAA;AAAA,UACA,CAAA;AAAA,UACA,SAAAE;AAAA,UACA,WAAAE;AAAA,QACA;AAEA,UAAAA,MAAA,aAAA,OAAAJ,KAAA;AACA,eAAA;AAAA,UACA,QAAA,CAAA;AAAA,YACA,eAAAA;AAAA,UACA,CAAA;AAAA,UACA,SAAAE;AAAA,UACA,WAAAE;AAAA,QACA;AAEA,UAAAA,MAAA,UAAAA,MAAA,kBAAA,OAAAJ,KAAA,UAAA;AACA,YAAAK,IAAAL;AACA,eAAAI,MAAA,UAAAJ,MAGAK,IAAA,KAAA,oBAAAL,CAAA,IAEA;AAAA,UACA,QAAA,CAAA;AAAA;AAAA,YAEA,eAAAK;AAAA,UACA,CAAA;AAAA,UACA,SAAAH;AAAA,UACA,WAAAE;AAAA,QACA;AAAA,MACA;AACA,UAAAA,MAAA,SAAA;AAEA,cAAA9D,IAAA6B;AAAA,UACAgC,EAAA,SAAA,CAAAD,CAAA,EAAA,OAAAC,CAAA,EAAA,KAAA,GAAA,IAAAD;AAAA,UACA,KAAA,UAAA;AAAA,QACA,GACAT,KAAAnD,KAAA,gBAAAA,EAAA,sBACA,KAAA,kBAAA,YACAoD,KAAApD,KAAA,gBAAAA,EAAA,2BACA,KAAA,uBAAA;AACA,eAAA;AAAA,UACA,QAAA0D,EAAA,IAAA,CAAAM,MAAA;AAEA,kBAAAC,IAAA,OAAAD,KAAA,WAAAA,IAAA,CAAA;AACA,mBAAA;AAAA,cACA,eAAAA,EAAAb,CAAA,KAAAa;AAAA,cACA,YAAAA,EAAAZ,CAAA,KAAA;AAAA,cACA,GAAAa;AAAA,YACA;AAAA,UACA,CAAA;AAAA,UACA,SAAAL;AAAA,UACA,WAAAE;AAAA,QACA;AAAA,MACA;AACA,aAAAA,MAAA,UACA;AAAA,QACA,QAAA,OAAA,QAAAJ,CAAA,EACA,OAAA,CAAAxD,GAAA,CAAAgE,GAAAC,CAAA,OAEAjE,EAAA,KAAA,KAAA;AAAA,UACAiE;AAAA;AAAA,UAEAR,EAAA,QAAAA,EAAA,MAAA,WAAAO,CAAA,IAAAP,EAAA,WAAAO,CAAA;AAAA,UACAA;AAAA,UACA,CAAAA,CAAA,EAAA,OAAAL,CAAA;AAAA,QACA,CAAA,GACA3D,IACA,EAAA;AAAA,QACA,WAAA4D;AAAA,QACA,SAAAF;AAAA,MACA,IAGAE,MAAA,UAAA,OAAAJ,KAAA,WACA;AAAA,QACA,QAAA,OAAA,OAAAA,CAAA,EACA,IAAA,CAAAM,OAAA;AAAA;AAAA,UAEA,eAAAA,IAAA,KAAA,oBAAAA,CAAA,IAAA;AAAA,QACA,EAAA;AAAA,QACA,SAAAJ;AAAA;AAAA;AAAA;AAAA,QAIA,WAAA,OAAA,KAAAF,CAAA,EAAA,OAAA,CAAAxD,GAAAP,MAAA;AACA,gBAAAyE,IAAAzE,EAAA,MAAA,GAAA,EAAA,CAAA;AACA,iBAAAyE,MAAAlE,IAAAA,IAAAkE,IAAAlE;AAAA,QACA,GAAA,EAAA;AAAA,MACA,IAGAwD;AAAA,IACA;AAAA,IACA,oBAAAW,GAAA;AACA,YAAA,EAAA,QAAA,EAAA,OAAAC,GAAA,MAAAC,GAAA,OAAAC,GAAA,KAAAC,EAAA,IAAA,CAAA,EAAA,IAAAJ,EACA,MAAA,gEAAA,KAAA;AACA,aAAAE,IAAA,GAAAE,IAAA,GAAAA,CAAA,MAAA,EAAA,GAAAD,IAAA,GAAAA,CAAA,MAAA,EAAA,GAAAF,KAAA,EAAA,GAAAC,CAAA,KAAA;AAAA,IACA;AAAA,IACA,oBAAAF,GAAA;AACA,YAAA,EAAA,QAAA,EAAA,OAAAC,GAAA,MAAAC,GAAA,OAAAC,GAAA,KAAAC,EAAA,IAAA,CAAA,EAAA,IAAAJ,EACA,MAAA,gEAAA,KAAA;AACA,aAAAE,IAAA,GAAAD,KAAA,EAAA,GAAAC,CAAA,GAAAC,IAAA,IAAAA,CAAA,KAAA,EAAA,GAAAC,IAAA,IAAAA,CAAA,KAAA,EAAA,KAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,oBAAAC,GAAAvD,GAAA0C,IAAA,CAAA,GAAA;AAEA,YAAA,EAAA,QAAAH,GAAA,WAAAI,GAAA,SAAAF,EAAA,IAAAc;AAEA,UAAAvD,EAAA,SAAA;AAEA,eAAA2C,MAAA,SACA,KAAA,oBAAAJ,EAAA,CAAA,EAAA,aAAA,IAEAA,EAAA,CAAA,EAAA;AAGA,UAAAvC,EAAA,SAAA;AACA,eAAAuC,EAAA,CAAA,EAAA;AAGA,UAAAvC,EAAA,SAAA,aAAAA,EAAA,SAAA;AACA,eAAA,OAAAuC,EAAA,CAAA,EAAA,aAAA;AAIA,WAAAI,EAAA,SAAA,MAAA,KAAAA,EAAA,SAAA,MAAA,MAAA3C,EAAA,SAAA,UAAA;AACA,cAAAwD,IAAA,OAAA,KAAAxD,EAAA,UAAA;AACA,eAAAuC,EAAA,OAAA,CAAAkB,GAAAlE,GAAAL,OAAA;AAAA,UACA,GAAAuE;AAAA,UACA,CAAAD,EAAAtE,CAAA,CAAA,GAAA,KAAA,oBAAAK,EAAA,aAAA;AAAA,QACA,IAAA,CAAA,CAAA;AAAA,MACA;AAEA,UAAAoD,EAAA,SAAA,OAAA,GAAA;AAKA,cAAA9D,IAAA6B;AAAA,UACAgC,EAAA,SAAA,CAAAD,CAAA,EAAA,OAAAC,CAAA,EAAA,KAAA,GAAA,IAAAD;AAAA,UACA,KAAA,UAAA;AAAA,QACA,GACAT,KAAAnD,KAAA,gBAAAA,EAAA,sBACA,KAAA,kBAAA,YACAoD,KAAApD,KAAA,gBAAAA,EAAA,2BACA,KAAA,uBAAA;AACA,eAAA0D,EAAA,OAAA,CAAAjB,MAAA,CAAA,CAAAA,EAAA,aAAA,EACA,IAAA,CAAAA,MAAA;AAGA,gBAAAwB,IAAA,KAAA,MAAA,KAAA,UAAAxB,CAAA,CAAA;AACA,sBAAA,QAAAwB,GAAA,eAAA,GACA,KAAA,QAAAA,GAAA,YAAA,GACA;AAAA;AAAA,YAEA,GAAAA;AAAA;AAAA,YAEA,CAAAd,CAAA,GAAAV,EAAA;AAAA,YACA,CAAAW,CAAA,GAAAX,EAAA;AAAA,UACA;AAAA,QACA,CAAA;AAAA,MACA;AAEA,aAAA,CAAAqB,EAAA,SAAA,OAAA,KAAA3C,EAAA,SAAA,UACA,KAAA;AAAA,QACAuD;AAAA,QACAvD,EAAA;AAAA,MACA,IAGA2C,MAAA,WACA3C,EAAA,SAAA,WACAuC,EACA,OAAA,CAAAhD,MAAAC,EAAAD,EAAA,MAAA,CAAA,EACA,OAAA,CAAAmE,GAAAC,OAAA;AAAA,QACA,GAAAD;AAAA,QACA,CAAAC,EAAA,OAAA,GAAA,KAAA;AAAA,UACAA;AAAA,UACA3D,EAAA,WAAA2D,EAAA,OAAA;AAAA,UACA,CAAAA,EAAA,OAAA,EAAA,OAAAjB,CAAA;AAAA,QACA;AAAA,MACA,IAAA,CAAA,CAAA,IAEA;AAAA,IACA;AAAA,IACA,uBAAAkB,GAAAlB,IAAA,IAAA;AAEA,YAAA,EAAA,YAAA7D,EAAA,IAAA,KAAA;AAEA,aAAA,OAAA,QAAA+E,CAAA,EACA,OAAA,CAAA7E,GAAA,CAAAP,GAAA+D,CAAA,MAAA;AAEA,cAAA,EAAA,YAAAI,EAAA,IAAAJ,EAAA,SAAA,IAAAA,EAAA,SAAA,IAAA;AAEA,YAAAI,MAAA,SAAA;AAEA,gBAAAkB,IAAA,KAAA;AAAA,YACAtB,EAAA,cAAAA,EAAA,MAAA;AAAA,YACA,CAAA/D,CAAA,EAAA,OAAAkE,CAAA;AAAA,UACA;AAGA,iBAAAmB,EAAA,SAAA9E,EAAA,OAAA;AAAA,YACA,CAAAP,CAAA,GAAAqF;AAAA,UACA,CAAA,IAAA9E;AAAA,QACA;AAEA,YAAA4D,MAAA,SAAA;AAGA,gBAAAmB,MAAApB,EAAA,SACAhC,EAAAgC,EAAA,KAAA,GAAA,GAAA7D,CAAA,IAAAA,MAAA,IAAAL,CAAA;AAMA,cAAA,CAAA,KAAA,kCAAAsF,KAAA,QAAAA,EAAA,8BACA,KAAA,kCAAA,CAAAA,KACA,CAAA,OAAA,KAAAA,CAAA,EAAA,SAAA,2BAAA,KAAAA,EAAA;AACA,mBAAA/E,EAAA,OAAAP,CAAA;AAAA,QAEA;AAEA,eAAAO;AAAA,MACA,GAAA,CAAA,CAAA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoBA,kCACAC,GACAH,GACAkF,GACAC,GACAC,IAAA,IACA;AAEA,UAAA,OAAAjF,KAAA,UAAA;AACA,cAAAkF,IAAArF,EAAAG,CAAA,KAAA,CAAA;AACA,eAAA;AAAA,UACA,CAAAA,CAAA,GAAA;AAAA;AAAA;AAAA,YAGA,GAAAiF,IAAAC,IAAA;YACA,CAAAH,CAAA,GAAAC;AAAA;AAAA,YAEA,GAAAC,IAAA,KAAAC;AAAA,UACA;AAAA,QACA;AAAA,MACA;AACA,aAAA,OAAAlF,KAAA,WACA,OAAA,QAAAA,CAAA,EAAA,OAAA,CAAAD,GAAA,CAAAoF,GAAAC,CAAA,OAAA;AAAA,QACA,GAAArF;AAAA;AAAA,QAEA,CAAAoF,CAAA,GAAA;AAAA;AAAA;AAAA,UAGA,GAAAtF,EAAAsF,CAAA;AAAA;AAAA,UAEA,GAAAC,EAAA,OAAA,CAAAC,GAAAC,OAAA;AAAA,YACA,GAAAD;AAAA;AAAA,YAEA,GAAA,KAAA;AAAA,cACAC;AAAA,cACAzF,EAAAsF,CAAA,KAAA,CAAA;AAAA,cACAJ;AAAA,cACAC;AAAA,YACA;AAAA,UACA,IAAA,CAAA,CAAA;AAAA,QACA;AAAA,MACA,IAAA,CAAA,CAAA,IAEA;IACA;AAAA,EACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}