{"version":3,"file":"BaseChipsInput.vue.es.js","sources":["../../../src/components/BaseChipsInput/BaseChipsInput.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"chipsInput\"\n    class=\"base-chips-input\">\n    <!-- TODO: check if really ALL props should be forwarded -->\n    <BaseChipsInputField\n      ref=\"baseInput\"\n      v-model=\"input\"\n      v-bind=\"chipsFieldInputProps\"\n      :input-type=\"inputType\"\n      :add-selected-entry-directly=\"false\"\n      :selected-list.sync=\"selectedListInt\"\n      :drop-down-list-id=\"internalId\"\n      :linked-list-option=\"activeOption ? activeOption[identifierPropertyName] : null\"\n      :is-active.sync=\"chipsInputActive\"\n      :loadable=\"allowDynamicDropDownEntries\"\n      @keydown.enter.prevent=\"onEnter\"\n      @keydown.up.down.prevent=\"onArrowKey\"\n      @keydown=\"checkKeyEvent\"\n      @click-input-field=\"onInputFocus\"\n      @clicked-outside=\"onInputBlur\"\n      v-on=\"$listeners\">\n      <template #below-input>\n        <BaseDropDownList\n          v-if=\"chipsInputActive\"\n          ref=\"dropDownList\"\n          :drop-down-options=\"listInt\"\n          :active-option.sync=\"activeOption\"\n          :selected-option.sync=\"selectedOption\"\n          :identifier-property-name=\"identifierPropertyName\"\n          :label-property-name=\"labelPropertyName\"\n          :list-id=\"internalId\"\n          :style=\"{ 'min-width': dropDownMinWidth }\"\n          :language=\"language\"\n          :drop-down-no-options-info=\"dropDownNoOptionsInfo\"\n          class=\"base-chips-input__drop-down\"\n          @click.native.stop=\"closeDropDown\"\n          @touchstart.native.stop=\"closeDropDown\">\n          <template #option=\"{ option }\">\n            <span\n              v-if=\"allowUnknownEntries && option[identifierPropertyName] === 'createNew'\"\n              ref=\"option\"\n              :key=\"option[labelPropertyName]\">\n              {{ addNewChipText\n                ? `${addNewChipText} ${getLangLabel(option[labelPropertyName], true)} ...`\n                : `${getI18nTerm('form.Add', -1, {\n                  value: getLangLabel(option[labelPropertyName], true),\n                })} ...` }}\n            </span>\n            <template\n              v-else-if=\"option\">\n              <!-- @slot a slot to provide more advanced drop down entries per default only the `Object[labelPropertyName][?lang]` will be displayed\n                @binding {Object} item - the option passed to options list -->\n              <slot\n                :item=\"option\"\n                name=\"drop-down-entry\">\n                <!-- SLOT DEFAULT -->\n                <span\n                  v-if=\"option[identifierPropertyName]\"\n                  :key=\"option[identifierPropertyName]\"\n                  v-insert-text-as-html=\"{\n                    value: highlightStringMatch\n                      ? highlight(getLangLabel(option[labelPropertyName], true))\n                      : getLangLabel(option[labelPropertyName], true),\n                    interpretTextAsHtml: interpretChipsLabelAsHtml,\n                  }\" />\n              </slot>\n            </template>\n          </template>\n          <template\n            #no-options>\n            <!-- @slot a slot to customize messages in case of no options present in drop down -->\n            <slot\n              name=\"no-options\" />\n          </template>\n        </BaseDropDownList>\n        <!-- @slot to add elements below input fields e.g. add drop down -->\n        <slot name=\"below-input\" />\n      </template>\n      <template\n        #label-addition>\n        <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs)). for an example see [BaseChipsInputField](BaseChipsInputField)-->\n        <slot name=\"label-addition\" />\n      </template>\n      <template #pre-input-field>\n        <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseChipsInputField](BaseChipsInputField)-->\n        <slot name=\"pre-input-field\" />\n      </template>\n      <template\n        #input-field-addition-before>\n        <!-- @slot Slot to allow for additional elements in the input field \\<div\\> (before <input>). for an example see [BaseChipsInputField](BaseChipsInputField)-->\n        <slot name=\"input-field-addition-before\" />\n      </template>\n      <template #input-field-inline-before>\n        <!-- @slot to add elements directly inline before the input (contrary to `input-field-addition-before` this does not wrap. for an example see [BaseChipsInputField](BaseChipsInputField)-->\n        <slot name=\"input-field-inline-before\" />\n      </template>\n      <template #input-field-addition-after>\n        <!-- @slot for adding elements after input -->\n        <slot name=\"input-field-addition-after\" />\n      </template>\n      <template #post-input-field>\n        <!-- @slot for adding elements at the end covering the whole height. for an example see [BaseChipsInputField](BaseChipsInputField)-->\n        <slot name=\"post-input-field\" />\n        <div\n          v-if=\"!allowMultipleEntries\"\n          class=\"base-chips-input__single-dropdown\"\n          @keydown.enter.stop=\"chipsInputActive = !chipsInputActive\"\n          @click.stop=\"chipsInputActive = !chipsInputActive\">\n          <BaseIcon\n            :class=\"[\n              'base-chips-input__single-dropdown-icon',\n              {\n                'base-chips-input__single-dropdown-icon-rotated':\n                  chipsInputActive,\n              },\n            ]\"\n            name=\"drop-down\" />\n        </div>\n      </template>\n      <template #error-icon>\n        <!-- @slot use a custom icon instead of standard error/warning icon. for an example see [BaseChipsInputField](BaseChipsInputField).-->\n        <slot name=\"error-icon\" />\n      </template>\n      <template #remove-icon>\n        <!-- @slot use a custom icon instead of standard remove icon. for an example see [BaseChipsInputField](BaseChipsInputField). -->\n        <slot name=\"remove-icon\" />\n      </template>\n    </BaseChipsInputField>\n  </div>\n</template>\n\n<script>\nimport { createId, highlightText } from '@/utils/utils';\nimport InsertTextAsHtml from '@/directives/InsertTextAsHtml';\nimport BaseIcon from '@/components/BaseIcon/BaseIcon';\nimport { ref } from 'vue';\nimport { useAnnouncer } from '@/composables/useAnnouncer';\nimport BaseChipsInputField from '../BaseChipsInputField/BaseChipsInputField';\nimport i18n from '../../mixins/i18n';\nimport navigateMixin from '../../mixins/navigateList';\n\n/**\n * Base Chips Input component with drop down and autocomplete functionality\n *\n */\n\nexport default {\n  name: 'BaseChipsInput',\n  components: {\n    BaseIcon,\n    BaseDropDownList: () => import('@/components/BaseDropDownList/BaseDropDownList').then(m => m.default || m),\n    BaseChipsInputField,\n  },\n  directives: {\n    insertTextAsHtml: InsertTextAsHtml,\n  },\n  mixins: [\n    i18n,\n    navigateMixin,\n  ],\n  model: {\n    prop: 'selectedList',\n    event: 'selected-changed',\n  },\n  props: {\n    /**\n     * list of selectable options. needs to be a list with at least an identifier and a label\n     *  (properties can be set via `identifierPropertyName` and `labelPropertyName`)\n     */\n    list: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * list of already selected options, displayed as chips\n     *  needs to be a list with at least an identifier and a label\n     *  (properties can be set via `identifierPropertyName` and `labelPropertyName`)\n     */\n    selectedList: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * specify input field type\n     * @values text, search\n     */\n    inputType: {\n      type: String,\n      default: 'text',\n      validator: val => ['text', 'search'].includes(val),\n    },\n    /**\n     * input field label\n     */\n    label: {\n      type: String,\n      required: true,\n    },\n    /**\n     * define if label should be visible\n     */\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * input field placeholder\n     */\n    placeholder: {\n      type: String,\n      default: null,\n    },\n    /**\n     * message displayed when no selectable options are available\n     */\n    dropDownNoOptionsInfo: {\n      type: String,\n      default: 'No options available',\n    },\n    /**\n     * define if the user can add an option that is not in the list\n     */\n    // can the user add Entries that are not available in the vocabulary (selectable list)\n    allowUnknownEntries: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * define only a single or multiple options can be selected\n     */\n    // define if one or several entries can be selected from drop down menu\n    allowMultipleEntries: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * define if selectable list options should be fetched every time or if the\n     * list passed in the beginning is used\n     */\n    allowDynamicDropDownEntries: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * this prop was added because there was some action needed to be done before entry was added\n     * so this is possible if entry is not added to `selectedList` directly but only in parent\n     * component\n     */\n    addSelectedEntryDirectly: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * option to have the border of the input field not displayed\n     */\n    showInputBorder: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * if `true` a button with that functionality will be visible\n     */\n    sortable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * define if chips should be draggable (currently only available for inline)\n     */\n    draggable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * define if entries should always appear linked (-> with grey background)\n     */\n    alwaysLinked: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set content for the info box activatable by click.\n     * see [BaseHoverBox](BaseHoverBox) for more details\n     */\n    hoverboxContent: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * show spinner to indicate that something is loading\n     * (for dynamically fetched entries that need to do backend requests)\n     */\n    isLoading: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if sorting is enabled this will be the text shown in the button\n     */\n    sortText: {\n      type: String,\n      default: 'Sort A â€“ Z',\n    },\n    /**\n     * if `true` sorting will consider the last string in a label or if a comma is\n     * present the string before the comma\n     */\n    sortName: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set a language (ISO 639-1)\n     */\n    language: {\n      type: String,\n      default: '',\n    },\n    /**\n     * set a chips text for adding a new chip.\n     * (alternatively add a `form.Add` value to your localization files)\n     * if allowUnknownEntries is true please add this in one form or another!\n     */\n    addNewChipText: {\n      type: String,\n      default: '',\n    },\n    /**\n     if field is occuring more then once - set an id\n     */\n    id: {\n      type: String,\n      default: '',\n    },\n    /**\n     * specify the object property that should be used as identifier\n     */\n    identifierPropertyName: {\n      type: String,\n      default: 'id',\n    },\n    /**\n     * specify the object property that should be used as value to be displayed\n     */\n    labelPropertyName: {\n      type: String,\n      default: 'label',\n    },\n    /**\n     * property for special case in component [BaseChipsBelow](BaseChipsBelow) - if `false` in this case chips will\n     * not be displayed in the input field\n     */\n    displayChipsInline: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * mark as required field (currently only used for `aria-required` attribute)\n     */\n    required: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * mark the form field as invalid and ideally also provide an error message\n     * to display below the form field.\n     * for an example see [BaseInput](BaseInput)\n     */\n    invalid: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set `true` if input field should be disabled.\n     * for an example see [BaseInput](BaseInput)\n     */\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * add an error message to be displayed below form field if field is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    errorMessage: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define if error icon should be shown.\n     * for an example see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `true` a remove icon (or a custom icon if slot `remove-icon` is used) will be shown allowing to remove\n     * all input at once\n     * for an example see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * specify additional input field styling\n     */\n    inputClass: {\n      type: String,\n      default: '',\n    },\n    /**\n     * set `true` if chip should be editable on click\n     *\n     * **Caveat**: chips can not be both `draggable` AND `editable` and it can not show\n     *  `hoverBoxContent` as soon as it is editable respectively - if both are set `true` edit\n     *  functionality takes precedent - chip will not be draggable, `hoverBoxContent` will not\n     *  be shown!\n     */\n    chipsEditable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set `true` if dropdown should be closed after selecting an option\n     */\n    closeDropdownOnOptionSelect: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * this prop gives the option to add assistive text for screen readers\n     * properties:\n     * **selectedOption**: text read when a selected option is focused (currently only\n     *  working for editable chips)\n     * **loaderActive**: text that is announced when results are being fetched (prop\n     *  `isLoading` is set `true`)\n     * **resultsRetrieved**: text that is announced when results were retrieved (drop down\n     *  list changed)\n     * **optionAdded**: text read when option was added to the selected list. string {label}\n     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])\n     * **optionToRemoveSelected**: text read when option is marked active for removal (by using\n     *  backspace in empty input field). string {label} could be added to be replaced\n     *  by the actual chip label (value in [`labelPropertyName`])\n     * **optionRemoved**: text read when option was removed from the selected list. string {label}\n     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])\n     */\n    assistiveText: {\n      type: Object,\n      default: () => ({\n        selectedOption: '',\n        loaderActive: 'loading.',\n        resultsRetrieved: '{number} options in drop down.',\n        optionAdded: 'option {label} added to selected list.',\n        optionToRemoveSelected: 'option {label} from selected list marked for removal. Press delete or backspace to remove.',\n        optionRemoved: 'option {label} removed.',\n      }),\n    },\n    /**\n     * define if selected options chips should come with a remove icon\n     */\n    chipsRemovable: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * define a default entry\n     * will be added when component is mounted and selected list is initially empty\n     * properties:\n     * **label|*** `string`: the label of the default option - use the property name set via prop `labelPropertyName`\n     * **id|*** `string?`: (optional) identifier of the default option - use the property name set via prop `identifierPropertyName`\n     */\n    defaultEntry: {\n      type: [Object, null],\n      default: null,\n    },\n    /**\n     * set this flag to `true` to highlight autocomplete option characters that match\n     *  the current search input string\n     *\n     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use\n     *    this prop on trusted content and never on user-provided content.\n     */\n    highlightStringMatch: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `highlightAutocompleteMatch` is set `true`\n     *  provide tag names to style the matched characters\n     *  (without '<' and '>', e.g. ['b'] for <b>)\n     */\n    highlightStringTags: {\n      type: Array,\n      default: () => ([]),\n    },\n    /**\n     * if necessary selected chip text can\n     *  be rendered as v-html directive\n     *\n     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use\n     *    this prop on trusted content and never on user-provided content.\n     */\n    interpretChipsLabelAsHtml: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup() {\n    /**\n     * set up component reference\n     * @type {Ref<UnwrapRef<null|HTMLElement>>}\n     */\n    const chipsInput = ref(null);\n    // use composable to announce screen reader text on actions taken (e.g.\n    // add chip to selected list or remove chip\n    const { announcement } = useAnnouncer(chipsInput);\n    return {\n      chipsInput,\n      announcement,\n    };\n  },\n  data() {\n    return {\n      /**\n       * the current input field string\n       * @type {string}\n       */\n      input: '',\n      /**\n       * internal representation of selected options list\n       * @type {Object[]}\n       */\n      selectedListInt: [],\n      /**\n       * the currently active option, styled with grey background\n       * (only if selected by keyboard)\n       *\n       * @type {number}\n       */\n      activeOptionIndex: 0,\n      /**\n       * the currently selected option after mouse click or keyboard enter\n       *\n       * @type {?Object}\n       */\n      selectedOption: null,\n      /**\n       * variable to store state of input field (for drop down handling)\n       * @type {boolean}\n       */\n      chipsInputActive: false,\n      /**\n       * the minimal width of the drop down element (calculated in js because ? )\n       * TODO: above...\n       * @type {string}\n       */\n      dropDownMinWidth: '100%',\n      /**\n       * the input element\n       * @type {HTMLElement}\n       */\n      inputElem: null,\n      /**\n       * timeout for drop down options found announcer because otherwise\n       * text not read if more than one character entered into input\n       * @type {?number}\n       */\n      timeout: null,\n    };\n  },\n  computed: {\n    /**\n     * clean props from props not available in ChipsInputField component\n     * (e.g. because they are only needed for drop down component)\n     */\n    chipsFieldInputProps() {\n      const newProps = { ...this.$props, id: this.internalId };\n      delete newProps.dropDownNoOptionsInfo;\n      delete newProps.allowDynamicDropDownEntries;\n      delete newProps.addNewChipText;\n      // drop down options\n      delete newProps.list;\n      return newProps;\n    },\n    /**\n     * internal representation of options list, filtered for already selected entries\n     * and also handling input string matching with options list in case of\n     * no dynamic autocomplete fetching\n     * @returns {Object[]}\n     */\n    listInt() {\n      let tempList = [...this.list];\n      // if unknown entries are allowed add an \"Add InputString ...\" as first option\n      if (this.allowUnknownEntries && this.input) {\n        tempList.unshift({\n          [this.labelPropertyName]: this.language ? { [this.language]: this.input } : this.input,\n          // add an identifier here as well so this option can be recognized by the inputs\n          // `aria-activedescendant` attribute\n          [this.identifierPropertyName]: 'createNew',\n        });\n      }\n      // filter entries that were already selected, if no identifier\n      // compare by object property\n      if (this.selectedListInt && this.selectedListInt.length) {\n        tempList = tempList.filter(option => !this.selectedListInt\n          .map(selected => (selected[this.identifierPropertyName]\n            || selected[this.labelPropertyName]))\n          .includes(option[this.identifierPropertyName] || option[this.labelPropertyName]));\n      }\n      // in case of no dynamic autocomplete fetching match the input string\n      // with the options list and only show matching options\n      if (this.input && !this.allowDynamicDropDownEntries) {\n        // also only return entries matching the input string\n        return tempList.filter(option => this.getLangLabel(option[this.labelPropertyName])\n          .toLowerCase().includes(this.input.toLowerCase()));\n      }\n      return tempList;\n    },\n    /**\n     * the currently active option object\n     */\n    activeOption: {\n      /**\n       * setter function of activeOption - will set active option index\n       * @param {?Object} val - the active option (by hover or arrow key use)\n       */\n      set(val) {\n        this.activeOptionIndex = this.listInt.indexOf(val);\n      },\n      /**\n       * getter function for activeOption - determined by active option index\n       * @returns {?Object}\n       */\n      get() {\n        return this.listInt[this.activeOptionIndex];\n      },\n    },\n    internalId() {\n      return this.id || createId();\n    },\n    /**\n     * create an object out of prop `highlightStringTags` so it can be\n     *  spread into the options of the `highlightText` function\n     * @returns {{highlightTags: []}|{}}\n     */\n    highlightTags() {\n      return this.highlightStringTags?.length\n        ? { highlightTags: this.highlightStringTags } : {};\n    },\n  },\n  watch: {\n    /**\n     * if the selected option changed (by click or keybord enter) add\n     * it to the list of selected options\n     * @param {?Object} val\n     */\n    selectedOption(val) {\n      if (val) {\n        this.addSelectedOption(val);\n        // if input element was found - focus after chips select\n        if (this.inputElem && this.allowMultipleEntries) {\n          this.inputElem.focus();\n        }\n      }\n    },\n    listInt: {\n      /**\n       * watch listInt for changes to set the currently active option index\n       * accordingly\n       * @param {Object[]} val\n       */\n      handler(val) {\n        if (val.length && !this.activeOption) {\n          // set first option in list as active option\n          this.activeOptionIndex = 0;\n        } else if (!val.length && (!this.allowUnknownEntries || !this.input)) {\n          this.activeOptionIndex = -1;\n        }\n        // only set the text when the drop down is actually visible\n        // and do not announce the \"create {custom entry}...\" because it overwrites\n        // the loader message and is announced again with the rest of the search results\n        // later anyway\n        if (this.chipsInputActive\n          && !this.isLoading && !this.announcement) {\n          if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n          }\n          // adding this timeout because with dynamicFetch false the list\n          // changes immediately and announcement text is not always read\n          this.timeout = setTimeout(() => {\n            // check if drop down is still open agin to prevent announcement\n            // after option was added (if drop down was closed)\n            if (this.chipsInputActive && this.assistiveText.resultsRetrieved) {\n              if (val.length) {\n                this.announcement = this.assistiveText.resultsRetrieved\n                  .replace('{number}', val.length);\n              } else {\n                this.announcement = this.dropDownNoOptionsInfo;\n              }\n            }\n          }, 300);\n        }\n      },\n      immediate: true,\n    },\n    list: {\n      /**\n       * watch list to reset active option index\n       * @param {Object[]} val\n       */\n      handler(val) {\n        // if list changed externally - reset index to 0\n        this.activeOptionIndex = val.length || (this.allowUnknownEntries && this.input) ? 0 : -1;\n      },\n      immediate: true,\n    },\n    selectedList: {\n      /**\n       * get changes to selectedListInt as soon as selectedList changes\n       * @param {Object[]} val\n       */\n      handler(val) {\n        this.selectedListInt = [...val];\n      },\n      immediate: true,\n    },\n    /**\n     * watch for changes to selectedListInt and propagate to parent if necessary\n     * @param {Object[]} val\n     */\n    selectedListInt(val) {\n      if (JSON.stringify(val) !== JSON.stringify(this.selectedList)) {\n        this.updateParentSelectedList(val);\n      }\n    },\n    /**\n     * input is watched for follow up actions needed after input\n     * --> fetch autocomplete entries\n     * --> inform parent of input (this however is not needed anymore since\n     * $listeners from input are now propagated to parent anyways!)\n     * @param {string} val\n     */\n    input(val) {\n      // if dropdown content is dynamic alert parent to fetch new relevant entries (if desired)\n      if (this.allowDynamicDropDownEntries) {\n        /**\n         * if input changed this event is emitted to fetch matching autocomplete options\n         * (if allowDynamicDropDownEntries is set true)\n         *\n         * @event fetch-dropdown-entries\n         * @property {string} value - the input string\n         * @property {string} type - the `labelPropertyName` that was specified\n         */\n        this.$emit('fetch-dropdown-entries', { value: val, type: this.labelPropertyName });\n      }\n    },\n    /**\n     * watching drop down active to do necessary actions once drop down opens\n     * a) to fetch drop down entries for static drop downs on first show only\n     * b) to calculate actual drop down width (TODO: do i need this?)\n     * c) to inform parent of drop down state changes\n     * @param {boolean} val\n     */\n    chipsInputActive(val) {\n      // allow also for static drop down entries to be loaded on first drop down show only\n      if (val && !this.allowDynamicDropDownEntries && !this.listInt.length) {\n        /**\n         * event to fetch drop down entries with changing input\n         *\n         * @event fetch-dropdown-entries\n         * @type { object }\n         *\n         */\n        this.$emit('fetch-dropdown-entries', { value: this.input, type: this.labelPropertyName });\n      }\n      if (val) {\n        // TODO: check again why this is needed bzw. it not sure if it is working\n        // properly\n        this.calcDropDownMinWidth();\n        // reset the active option index to first item\n        this.activeOptionIndex = 0;\n      }\n    },\n  },\n  mounted() {\n    // get the input element(s) and store them for later\n    const elems = this.$el.getElementsByTagName('input');\n    if (elems && elems.length) {\n      [this.inputElem] = elems;\n    }\n\n    // add optional default entry to empty selectedList only\n    if (this.defaultEntry && !this.selectedList.length) {\n      this.selectedListInt.push(this.defaultEntry);\n    }\n  },\n  methods: {\n    /** CHIPS (ADDING) FUNCTIONALITIES */\n\n    /**\n     * method for adding a selected option to selected option list\n     * (remove works via setter - does not need a separate method)\n     *\n     * @param {Object} selected\n     */\n    addSelectedOption(selected) {\n      // if unknown entries are allowed we need to remove the added\n      // id again before pushing it to selectedListInt\n      const newSelected = { ...selected };\n      if (this.allowUnknownEntries && newSelected[this.identifierPropertyName] === 'createNew') {\n        delete newSelected[this.identifierPropertyName];\n      }\n      if (this.allowMultipleEntries) {\n        this.selectedListInt.push(newSelected);\n      } else {\n        // set the option on first array index (either setting new if empty\n        // array or replacing old option)\n        this.$set(this.selectedListInt, 0, newSelected);\n        // for single select the drop down should close again automatically\n        // after choosing the option\n        this.chipsInputActive = false;\n      }\n      // inform parent of the changes\n      this.updateParentSelectedList(this.selectedListInt);\n      // make sure the assistive text exists\n      if (this.assistiveText.optionAdded) {\n        // announce the added option to the screen reader\n        this.announcement = this.assistiveText.optionAdded\n          .replace('{label}', newSelected[this.labelPropertyName]);\n      }\n      // clear input\n      this.input = '';\n      // reset selected option\n      this.selectedOption = null;\n      // remove focus from input if element is single select\n      if (!this.allowMultipleEntries) {\n        this.chipsInputActive = false;\n        this.inputElem.blur();\n      }\n      // make sure drop down is closed at the end of all variable updates\n      setTimeout(() => {\n        // optional close dropdown after selection\n        this.closeDropDown();\n      }, 0);\n    },\n    /**\n     * method for emitting selected list changes to parent\n     * (called after adding or deleting an option to / from selected list)\n     *\n     * @param {Object[]} updatedList - the list that should be emitted in the event\n     */\n    updateParentSelectedList(updatedList) {\n      // only emit if updated list is different from parent list\n      if (JSON.stringify(this.selectedList) !== JSON.stringify(updatedList)) {\n        /**\n         * inform parent of changes to selectedList\n         * @event selected-changed\n         * @property {Object[]} - the altered selectedList\n         */\n        this.$emit('selected-changed', [...updatedList]);\n      }\n    },\n\n    /** INPUT FIELD ACTIVE/INACTIVE HANDLING */\n\n    /**\n     * function triggered when input field was clicked\n     */\n    onInputFocus() {\n      this.chipsInputActive = true;\n    },\n    /**\n     * function triggered when click-outside happened\n     */\n    onInputBlur() {\n      this.chipsInputActive = false;\n      // if the focus goes to somewhere else on the page - remove input string\n      if (this.input && document.activeElement.id !== this.internalId) {\n        this.input = '';\n      }\n    },\n\n    /** KEYBOARD FUNCTIONALITIES */\n\n    /**\n     * general function for checking key events like semicolon or tab\n     * @param {KeyboardEvent} event - the keydown event\n     */\n    checkKeyEvent(event) {\n      const { key } = event;\n      // this should (currently) never be the case (but it was in the past - on closeDropDownOnOptionSelect\n      // focus remained but drop down was closed) but just to be safe - set the input active as soon\n      // as user enters input\n      // TODO: what would happen if user selects an option, focus stays and user copy pastes? (but\n      // again - this is currently just hypothetical)\n      if (!['Tab', 'Enter', 'Shift'].includes(key)) {\n        this.chipsInputActive = true;\n      }\n      // if user pressed tab and thus input field leaves focus we would want to remove the input string\n      // so no confusion is created as to wether this string is part of a search or saved in form\n      // so we check for type of key and if input is present\n      if (key === 'Tab' && this.input\n        // and remove input if\n        // there is no other focusable element in the input (like the clear input button)\n        && (!this.clearable\n          // user is moving focus backwards from input to outside of input field (not from any\n          // other element in the input field)\n          || (event.shiftKey && event.target.tagName === 'INPUT')\n          // user is moving focus from clear input button to outside of the input\n          || (this.clearable && !event.shiftKey && event.target.tagName !== 'INPUT'))) {\n        // this.chipsInputActive = false;\n        this.input = '';\n      }\n    },\n    /**\n     * triggered on keydown enter event and will add\n     * a selected option\n     */\n    onEnter() {\n      // do nothing if dropdown should be closed on option select, and dropdown is not active\n      if (this.closeDropdownOnOptionSelect && !this.chipsInputActive) return;\n\n      // check if there is a currently active option\n      if (this.activeOption) {\n        this.addSelectedOption(this.activeOption);\n      }\n    },\n    /**\n     * event for keydown arrow (up, down) key use\n     *\n     * @param {KeyboardEvent} event - the keydown event\n     */\n    onArrowKey(event) {\n      // check if the list has any options\n      if (this.listInt.length) {\n        // if yes trigger the navigate function\n        this.activeOption = this.navigate(\n          this.listInt,\n          event.key === 'ArrowDown',\n          this.activeOptionIndex,\n          true,\n        );\n      }\n    },\n\n    /** OTHER FUNCTIONALITIES */\n\n    hoverBoxActive(value, entry) {\n      /**\n       * event emitted on show / hide hoverbox\n       *\n       * @property {boolean} value - value describing if hoverbox active is true or false\n       * @property {Object} option - the option for which the hoverbox was activated\n       */\n      this.$emit('hoverbox-active', { value, entry });\n    },\n    /**\n     * calculate the minimum width of the drop down element by getting the\n     * width of this element\n     */\n    calcDropDownMinWidth() {\n      // get the base input element\n      const inputElement = this.$refs.baseInput;\n      // see if it exists and has a width - if yes set drop down min width to the same\n      if (inputElement && inputElement.$el && inputElement.$el.clientWidth) {\n        this.dropDownMinWidth = `${inputElement.$el.clientWidth}px`;\n      }\n    },\n    /**\n     * close dropdown\n     */\n    closeDropDown() {\n      // optional close dropdown after selection\n      if (this.closeDropdownOnOptionSelect && this.chipsInputActive) {\n        this.chipsInputActive = false;\n        if (this.inputElem) {\n          this.inputElem.blur();\n        }\n      }\n    },\n    /**\n     * function to highlight characters of a string\n     * @param {string} word - the option that should be matched with query string\n     * @returns {string} - the string to fill into v-html\n     */\n    highlight(word) {\n      return highlightText({\n        word,\n        queryString: this.input,\n        // this is an empty object if prop `highlightStringTags` was not used\n        ...this.highlightTags,\n      });\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../../styles/variables\";\n\n  .base-chips-input {\n    position: relative;\n\n    .base-chips-input__drop-down {\n      background: white;\n    }\n\n    .base-chips-input__single-dropdown {\n      display: flex;\n      align-items: center;\n      padding: 0 $spacing-small;\n\n      .base-chips-input__single-dropdown-icon {\n        transition:  $drop-down-arrow-animation;\n        height: $icon-small;\n        width: $icon-small;\n        flex-shrink: 0;\n\n        &.base-chips-input__single-dropdown-icon-rotated {\n          transform: rotate(180deg);\n        }\n      }\n    }\n  }\n</style>\n"],"names":["_sfc_main","BaseIcon","m","BaseChipsInputField","InsertTextAsHtml","i18n","navigateMixin","val","chipsInput","ref","announcement","useAnnouncer","newProps","tempList","option","selected","createId","_a","elems","newSelected","updatedList","event","key","value","entry","inputElement","word","highlightText"],"mappings":"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"}