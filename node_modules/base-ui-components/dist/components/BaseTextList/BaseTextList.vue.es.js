import i from "../../directives/InsertTextAsHtml.es.js";
import o from "../../directives/cleanDomNodes.es.js";
import p from "../../mixins/i18n.es.js";
import "./BaseTextList.vue.es2.js";
import d from "../../_virtual/_plugin-vue2_normalizer.es.js";
const c = {
  name: "BaseTextList",
  components: {
    // eslint-disable-next-line import/no-self-import
    BaseTextList: () => Promise.resolve().then(() => x).then((l) => l.default || l),
    BaseLink: () => import("../BaseLink/BaseLink.vue.es.js").then((l) => l.default || l)
  },
  directives: {
    insertTextAsHtml: i,
    cleanDomNodes: o
  },
  mixins: [p],
  props: {
    /**
     * specify a list of array objects to render different types of text content
     *
     * single object structure: `{ label: {string, Object}, data: {string, Object, string[], Object[]} }`
     *  **label** - a heading for the list section
     * **data** property variants and their output (see readme.md for examples):
     * - `{string}` - renders as simple text
     * - `{Object}` - depending on object properties (see below) renders as chip | external ink | internal link | text | text with tooltip
     * - `{string[]}` - renders as unordered list
     * - `{Object[]}` - renders multiple objects (see above)
     *
     *  Possible object properties for `{ data : {Object, Object[]} }`:
     *  - **value** `string` - the displayed text for all types
     *  - **label** `string?` - an optional pretext in style of 'label:'
     *  - **altTitle** `string?` - if `interpretTextAsHtml` is set `true`, add a html-free version of the label
     *    here that can be used for hover title and assistive technologies (needed for type 'chip')
     * - **[identifierPropertyName]** `string?` - specify the id of a chip or the path for internal link - specify the object property name with prop `identifierPropertyName`
     * - **id** `string?` - for type chip - an identifier for the chip type (used in link generation)
     * - **path** `string?` - for type chip (used in link generation)
     * - **url** `string?` - for external link - the url to link to
     * - **additional** `Object?` - used for tooltip content generation - an array of objects with properties:
     *    `label`, `value` optionally `altTitle` (if `interpretTextAsHtml` is set true) and `url` (in case the item should render as link)
     *    **caveat**: even if tooltip content is created via slot this property (`tooltip`) needs to be present and filled in order for the tooltip to show
     *
     * Note: objects wrapped in an extra array are rendered as columns respecting the `cols` property.
     */
    data: {
      type: Array,
      default: () => []
    },
    /**
     * specify the object property that should be used as identifier
     *
     * Note: only applies for chips and internal links:
     * - chip: to build the link query data
     *         e.g.: query: `path?chip-link={[identifierPropertyName]:'keywordId',type:'dataObject.id',value:'keywordValue'}`
     * - internal: to set the link path
     */
    identifierPropertyName: {
      type: String,
      default: "source"
    },
    /**
     * specify a query parameter name for type chip links
     */
    chipQueryName: {
      type: String,
      default: "chip-link"
    },
    /**
     * render component as e.g.: 'h2' | 'h3'
     */
    renderLabelAs: {
      type: String,
      default: "div"
    },
    /**
     * set margin-bottom for the label
     */
    labelMarginBottom: {
      type: Boolean,
      default: !1
    },
    /**
     * specify the number of columns to render array nested objects
     */
    cols: {
      type: Number,
      default: 2,
      validator: (l) => l > 0
    },
    /**
     * specify the number of columns to render a single object typeof string
     */
    colsSingleTextObject: {
      type: Number,
      default: 1,
      validator: (l) => l > 0
    },
    /**
     * specify how the link element should be rendered - this needs to be a
     * valid vue link component (e.g. RouterLink, NuxtLink) and vue-router
     * is necessary
     * if no routing plugin is found the element will be rendered as <a> tag
     */
    renderLinkAs: {
      type: String,
      default: "RouterLink"
    },
    /**
     * specify how data-list (label, value) should be rendered
     * Note: Only applies to `{ data: {Object[]} }`.
     * @values horizontal, vertical
     */
    listType: {
      type: String,
      default: "horizontal",
      validator: (l) => ["horizontal", "vertical"].includes(l)
    },
    /**
     * specify the gap between content rows
     * @values large, small
     */
    rowGap: {
      type: String,
      default: "large",
      validator: (l) => ["large", "small"].includes(l)
    },
    /**
     * specify a threshold value in px for the [BaseTooltipBox](BaseTooltipBox) top position calculation
     *
     * Note: The value can also be set globally with the CSS variable `--base-tooltip-box-threshold-top`.
     *       The property will be overwritten by the CSS variable.
     */
    tooltipThresholdTop: {
      type: Number,
      default: 0
    },
    /**
     * set true to render `data` or `value` content as html
     *
     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use
     *    this prop on trusted content and never on user-provided content.
     */
    interpretTextAsHtml: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      /**
       * variable for handling columns class
       * Note: is finally evaluated in created lifecycle hook
       * @type {boolean}
       */
      hasColumns: !1
    };
  },
  computed: {
    /**
     * evaluate if data is a single object and typeof string
     * @returns {boolean}
     */
    isSingleTextObject() {
      return this.data.length === 1 && this.data[0].data && typeof this.data[0].data == "string";
    }
  },
  created() {
    this.hasColumns = this.$parent.$options.name === "BaseTextList";
  },
  methods: {
    /**
     * check if all array objects have a key label
     *
     * @param {array} data
     * @param {string} key
     * @returns {boolean}
     */
    containKeys(l, t) {
      return l.every((s) => Object.keys(s).includes(t));
    },
    /**
     * check if the link is type `tooltip`
     * @param {Object} item
     * @returns {boolean}
     */
    isTooltip(l) {
      return !!l.additional;
    }
  }
};
var u = function() {
  var t = this, s = t._self._c;
  return s("div", { class: [
    "base-text-list",
    "base-text-list--row-gap-" + t.rowGap,
    {
      "base-text-list--cols": t.hasColumns || t.isSingleTextObject && t.colsSingleTextObject > 1,
      "base-text-list--cols-single-content": t.isSingleTextObject && t.colsSingleTextObject > 1
    }
  ], style: t.isSingleTextObject ? { "--columns": t.colsSingleTextObject } : null }, t._l(t.data, function(e, n) {
    return s("div", { key: n, staticClass: "base-text-list__group" }, [e.label ? s(t.renderLabelAs, { tag: "component", class: ["base-text-list__label", { "base-text-list__label--mb": t.labelMarginBottom }] }, [t._v(" " + t._s(t.getLangLabel(e.label)) + " ")]) : t._e(), typeof e == "object" && typeof e[0] == "object" ? [s("BaseTextList", { ref: "baseTextList", refInFor: !0, style: { "--columns": t.cols }, attrs: { cols: t.cols, data: e, "identifier-property-name": t.identifierPropertyName, "label-margin-bottom": t.labelMarginBottom, "list-type": t.listType, "render-label-as": t.renderLabelAs, "interpret-text-as-html": t.interpretTextAsHtml } })] : e.data && typeof e.data == "string" ? s("p", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: e.data, interpretTextAsHtml: t.interpretTextAsHtml }, expression: "{ value: item.data, interpretTextAsHtml }" }], class: [
      "base-text-list__content",
      { "base-text-list__content--pre-line": !t.interpretTextAsHtml },
      // render single content in columns
      // eslint-disable-next-line vue/multiline-html-element-content-newline
      { "base-text-list--cols": t.data.length === 1 }
    ] }, [t._v(t._s(e.data))]) : e.data && typeof e.data == "object" && typeof e.data[0] == "string" ? s("ul", { staticClass: "base-text-list__content" }, t._l(e.data, function(a, r) {
      return s("li", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: { value: a, interpretTextAsHtml: t.interpretTextAsHtml }, expression: "{ value: arrayItem, interpretTextAsHtml }" }], key: r });
    }), 0) : e.data && typeof e.data == "object" ? [t.containKeys([].concat(e.data), "label") ? t._e() : [s("div", { staticClass: "base-text-list__content base-text-list__content--list" }, t._l([].concat(e.data), function(a, r) {
      return s("span", { directives: [{ name: "clean-dom-nodes", rawName: "v-clean-dom-nodes", value: { recursive: !1 }, expression: "{ recursive: false }" }], key: r, class: ["base-link__wrapper", { "base-link__wrapper--tooltip": t.isTooltip(a) }] }, [s("BaseLink", { class: ["base-text-list__link", { "base-link--chip-text-list": e.id }], attrs: { "identifier-property-name": t.identifierPropertyName, "identifier-property-value": a[t.identifierPropertyName], "chip-query-name": t.chipQueryName, path: e.path, tooltip: a.additional, type: e.id, url: a.url, value: a.value, "alt-title": a.altTitle, "interpret-text-as-html": t.interpretTextAsHtml }, scopedSlots: t._u([{ key: "tooltip", fn: function() {
        return [t.isTooltip(a) ? [t._t("tooltip", null, { data: a.additional })] : t._e()];
      }, proxy: !0 }], null, !0) }), s("span", { key: `${r}-space` }, [t._v(t._s(e.data.length && r !== e.data.length - 1 && !e.id ? ", " : ""))])], 1);
    }), 0)], t.containKeys([].concat(e.data), "label") ? [typeof e.data == "object" ? s("dl", { class: [
      "base-text-list__content",
      "base-text-list__content--" + t.listType
    ] }, [t._l([].concat(e.data), function(a, r) {
      return [s("dt", { key: "l" + r, staticClass: "base-text-list__content__label" }, [a.label ? [t._v(" " + t._s(t.getLangLabel(a.label)) + ":  ")] : t._e()], 2), s("dd", { key: "v" + r, staticClass: "base-text-list__content__label base-text-list__content__value" }, [s("BaseLink", { attrs: { "render-link-as": t.renderLinkAs, "identifier-property-name": t.identifierPropertyName, "identifier-property-value": a[t.identifierPropertyName], "chip-query-name": t.chipQueryName, path: e.path, tooltip: a.additional, "tooltip-threshold-top": t.tooltipThresholdTop, type: e.id, url: a.url, value: a.value, "alt-title": a.altTitle, "interpret-text-as-html": t.interpretTextAsHtml } }, [t._t("tooltip", null, { data: a.additional })], 2)], 1)];
    })], 2) : t._e()] : t._e()] : t._e()], 2);
  }), 0);
}, _ = [], f = /* @__PURE__ */ d(
  c,
  u,
  _,
  !1,
  null,
  "00efbe7e",
  null,
  null
);
const y = f.exports, x = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: y
}, Symbol.toStringTag, { value: "Module" }));
export {
  y as default
};
//# sourceMappingURL=BaseTextList.vue.es.js.map
