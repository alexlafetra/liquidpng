<template>
    <div
        :style="{height: listHeight,width:dropdownMatchSelectWidth?selectWidth:'256px'}"
        class="b-select-menu viewport"
        @scroll="handleScroll">
        <div
            :style="{height: scrollBarHeight}"
            class="scrollBar"></div>
        <div :style="{transform:`translate3d(0,${offset}px,0)`}" class="scroll-list">
            <ul ref="list" style="padding: 10px 0;">
                <li
                    v-for="(item, index) in visibleData"
                    :key="index"
                    :class="{
                        'b-select-menu-selected': isSelected(item),
                        'b-select-menu-highlight': item === menuList[highlightIndex]
                    }"
                    @click.stop="handleChoose(item)">
                    <span
                        v-b-tooltip="map[item].text||map[item]"
                        v-if="dropdownMatchSelectWidth"
                        class="b-select-menu-li-limitted"
                    >{{ map[item].text||map[item] }}</span>
                    <span v-else>{{ map[item].text||map[item] }}</span>
                    <i v-if="multiple" class="b-icon-tick"></i>
                </li>

                <li v-if="menuList.length === 0" class="empty-list-item">无匹配选项</li>
            </ul>
        </div>

    </div>

</template>

<script>
import KeyCodeMap from '../../util/keyCodeMap';
import {escapeRegExp} from '../../util/RegExp';

export default {
    props: {
        map: {
            type: Object,
            default: () => ({})
        },
        value: {
            type: [String, Number, Array],
            default: null
        },
        multiple: {
            type: Boolean,
            default: false
        },
        searchText: {
            type: String,
            default: ''
        },
        itemHeight: {
            type: Number,
            default: 30
        },
        padding: {
            type: Number,
            default: 10
        },
        renderCount: {
            type: Number,
            default: 8
        },
        dropdownMatchSelectWidth: {
            type: Boolean,
            default: false
        },
        selectWidth: {
            type: String,
            default: ''
        }
    },
    data() {
        return {
            highlightIndex: null,
            start: 0,
            end: 8,
            offset: 0,
            viewportS: 0
        };
    },

    computed: {
        valueList() {
            const {multiple, value} = this;

            return multiple ? (value || []) : (value ? [value] : []); // eslint-disable-line
        },
        menuList() {
            const vm = this;
            const {map: propsMap, searchText} = vm;
            const map = propsMap || {};
            if (searchText) {

                const reg = new RegExp(escapeRegExp(searchText), 'i');
                return Object.keys(map).filter((value) => {
                    if (map[value] && map[value].filter) {
                        return reg.test(map[value].filter) || reg.test(map[value].text);
                    }
                    return reg.test(map[value]);
                });
            }
            return Object.keys(map);
        },
        listHeight() {
            const vm = this;
            const {itemHeight, padding} = vm;
            return `${(vm.renderCount * itemHeight) + padding}px`;
        },
        scrollBarHeight() {
            const vm = this;
            const {itemHeight, padding, menuList} = vm;
            return `${(menuList.length * itemHeight) + padding}px`;
        },
        reservedCount() {
            const vm = this;
            return Math.floor(vm.renderCount / 2);
        },
        maxScrollTop() {
            const vm = this;
            const {menuList, itemHeight, padding} = vm;
            return ((menuList.length) * itemHeight) + padding;
        },
        valueIndexList() {
            const vm = this;
            const {menuList, valueList} = vm;

            return menuList.reduce((acc, curValue, curIndex) => {
                if (valueList.includes(curValue)) acc.push(curIndex);
                return acc;
            }, []);
        },

        visibleData() {
            const vm = this;
            const {start, end} = vm;
            return vm.menuList.slice(start, end);
        }
    },

    watch: {
        searchText(text) {
            const vm = this;
            const {menuList, map, valueList} = vm;
            if (menuList.includes(map[text])) {
                vm.initHighlight([map[text]]);
            } else {
                vm.initHighlight(valueList);
            }
        },

        value() {
            this.initHighlight(this.valueList);
        }
    },

    mounted() {
        const vm = this;
        vm.initHighlight(vm.valueList);
    },

    methods: {
        handleScroll() {
            const vm = this;
            const {itemHeight, renderCount} = vm;
            const scrollTop = vm.$el.scrollTop;
            vm.viewportS = scrollTop;
            // 计算开始
            vm.start = Math.floor(scrollTop / itemHeight);
            // 计算结束
            vm.end = vm.start + renderCount;
            // 计算偏移量
            vm.offset = vm.start * itemHeight;
        },

        initHighlight(valueList) {
            const vm = this;
            const {reservedCount, renderCount, menuList, padding, itemHeight, maxScrollTop} = vm;
            const curValueIndexList = menuList.reduce((acc, curValue, curIndex) => {
                if (valueList.includes(curValue)) acc.push(curIndex);
                return acc;
            }, []);
            const curFirstValueIndex = curValueIndexList.sort()[0];
            const highlightIndex = curFirstValueIndex > -1 ? curFirstValueIndex : 0;

            let initScrollTop = 0;
            if (highlightIndex > -1) {
                if (highlightIndex < reservedCount) {
                    initScrollTop = 0;
                } else if (highlightIndex > ((menuList.length - renderCount) + reservedCount) - 1) {
                    initScrollTop = maxScrollTop;
                } else {
                    initScrollTop = ((highlightIndex - reservedCount) * itemHeight) + padding;
                }
            }
            vm.highlightIndex = highlightIndex;
            vm.$nextTick(() => {
                vm.$el.scrollTop = initScrollTop;
            });
        },

        changeHighlight(direction) {
            const vm = this;
            const {$refs: {list}, highlightIndex, itemHeight, menuList, renderCount, maxScrollTop} = vm;

            const {scrollTop} = list;
            const contentMin = Math.floor(scrollTop / itemHeight);
            const contentMax = (contentMin + renderCount) - 1;

            const isOutOfContent = Boolean(highlightIndex < contentMin || highlightIndex > contentMax);
            let nextScrollTop = scrollTop;
            let nextHighlightIndex = highlightIndex;

            if (direction === 'up') {
                nextHighlightIndex = highlightIndex === 0 ? 0 : highlightIndex - 1;

                if (highlightIndex === contentMin) {
                    nextScrollTop = scrollTop - itemHeight;
                    nextScrollTop = nextHighlightIndex === 0 ? 0 : nextScrollTop;
                }
                if (isOutOfContent) {
                    nextScrollTop = ((nextHighlightIndex - renderCount) + 1) * itemHeight;
                    nextScrollTop = nextScrollTop > maxScrollTop ? maxScrollTop : nextScrollTop;
                }
            }

            if (direction === 'down') {
                nextHighlightIndex = highlightIndex + 1 === menuList.length ? highlightIndex : highlightIndex + 1;

                if (highlightIndex === contentMax) {
                    nextScrollTop = scrollTop + itemHeight;
                    nextScrollTop = nextHighlightIndex === menuList.length ? maxScrollTop : nextScrollTop;
                }
                if (isOutOfContent) {
                    nextScrollTop = nextHighlightIndex * itemHeight;
                    nextScrollTop = nextScrollTop < 0 ? 0 : nextScrollTop;
                }
            }

            vm.highlightIndex = nextHighlightIndex;
            vm.$nextTick(() => {
                vm.$el.scrollTop = nextScrollTop;
            });
        },

        handleChoose(value) {
            const vm = this;
            const {valueList} = vm;

            if (valueList.includes(value)) {
                vm.$emit('choose-selected', value);
            } else {
                vm.$emit('choose', value);
            }
        },

        handleClose() {
            const vm = this;
            vm.$emit('close');
        },

        handleKeyDown(keyCode) {
            const vm = this;
            const {highlightIndex, menuList} = vm;
            switch (keyCode) {
                case KeyCodeMap.up: {
                    vm.changeHighlight('up');
                    break;
                }
                case KeyCodeMap.down: {
                    vm.changeHighlight('down');
                    break;
                }
                case KeyCodeMap.enter: {
                    if (highlightIndex > -1 && menuList.length) {
                        vm.handleChoose(menuList[highlightIndex]);
                    } else {
                        vm.handleClose();
                    }
                    break;
                }
                default: {
                    break;
                }
            }
        },

        isSelected(value) {
            const {valueList} = this;
            return valueList.includes(value);
        }
    }
};
</script>

<style lang="scss">
.viewport {
    position: relative;

    .scrollBar {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        z-index: -1;
    }

    .scroll-list {
        top: 0;
        left: 0;
        position: absolute;
        width: 100%;
    }
}
</style>
