import { extractNestedPropertyValue as l } from "../../utils/utils.es.js";
import d from "../../mixins/navigateList.es.js";
import u from "../BaseImageBox/BaseImageBox.vue.es.js";
import c from "../../mixins/i18n.es.js";
import "./BaseResultBoxSection.vue.es2.js";
import h from "../../_virtual/_plugin-vue2_normalizer.es.js";
const p = {
  name: "BaseResultBoxSection",
  components: {
    BaseImageBox: u,
    BaseLoader: () => import("../BaseLoader/BaseLoader.vue.es.js").then((t) => t.default || t),
    BaseOptions: () => import("../BaseOptions/BaseOptions.vue.es.js").then((t) => t.default || t),
    BaseButton: () => import("../BaseButton/BaseButton.vue.es.js").then((t) => t.default || t),
    BasePagination: () => import("../BasePagination/BasePagination.vue.es.js").then((t) => t.default || t),
    BaseBoxButton: () => import("../BaseBoxButton/BaseBoxButton.vue.es.js").then((t) => t.default || t),
    BaseSelectOptions: () => import("../BaseSelectOptions/BaseSelectOptions.vue.es.js").then((t) => t.default || t)
  },
  mixins: [c, d],
  model: {
    prop: "entryList",
    event: "entries-changed"
  },
  props: {
    /**
     * actual entries list - if slot `result-box` is not used to use custom elements this
     * object array should have the following properties to be displayed
     * in a [BaseImageBox](BaseImageBox):
     *
     *    **id** `string` - a unique identifier
     *    **title** `?string` - the title of the box
     *    **subtext** `?string` - a subtitle
     *    **description** `?string` - text displayed at the bottom of the box
     *    **imageUrl** `?string` - url to display an image
     *    **text** `?string[]` - an array with strings that will be
     *    displayed if no image is provided
     *
     *    if a different schema is used please use the slot 'result-box' to create your own
     *    elements - only id and title should still be provided but can also
     *    be customized via `identifierPropertyName` and `titlePropertyName`
     */
    entryList: {
      type: Array,
      default: () => []
    },
    /**
     * if `false` the header row (title and options) will not be available
     *   **Caveat**: for draggable functionality this needs to be true
     */
    showHeader: {
      type: Boolean,
      default: !0
    },
    /**
     * title of section
     * it is recommended to also set the `headerText` even if slot `header` is used for header
     * for accessibility reasons
     */
    headerText: {
      type: String,
      default: ""
    },
    /**
     * define if options should be shown
     */
    showOptions: {
      type: Boolean,
      default: !0
    },
    /**
     * set text for the options button if `showOptions` is `true`
     *   this needs to be an object with `show` (displayed when options are hidden)
     *   and `hide` (displayed when options are visible) attributes
     */
    optionsButtonText: {
      type: Object,
      default: () => ({
        show: "edit",
        hide: "editReturn"
      }),
      validator: (t) => ["show", "hide"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * set the icon for the options button.
     * if `showOptions` is `true` this needs to be an object with `show`
     *  (displayed when options are hidden) and `hide` (displayed when
     *  options are visible) attributes
     */
    optionsButtonIcon: {
      type: Object,
      default: () => ({
        show: "edit",
        hide: "remove"
      }),
      validator: (t) => ["show", "hide"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * specify how many boxes should be displayed in a row in an array
     * with "tupples" (array with min-size and number of boxes).
     * depending on the size of the container (not screen width - unless
     * `calcBoxNumberRelativeToWindow` is set to `true`)
     * like the following:
     *   `[[0, [number of boxes]], [[min px size for this number of boxes], [number of boxes]], ...]`
     */
    boxBreakpoints: {
      type: Array,
      default: () => [
        [0, 2],
        [640, 4],
        [1024, 6]
      ],
      validator: (t) => t.every((e) => typeof e == "object" && e.length === 2 && e.every((s) => typeof s == "number"))
    },
    /**
     * set component loader active
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * flag if component should be in edit mode (dragging, deleting,
     * other custom options visible)
     *   the [`.sync` modifier](https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier) may be used on this prop
     */
    editMode: {
      type: Boolean,
      default: !1
    },
    /**
     * set this variable `true` if `background-color` should be white in edit mode
     */
    editModeWhiteBackground: {
      type: Boolean,
      default: !1
    },
    /**
         * provide a list of selected entries for select options (can
         * be entry objects or entry ids).
         *  the [`.sync` modifier](https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier) may be used on this prop
    
         */
    selectedList: {
      type: Array,
      default: () => []
    },
    /**
     * set a text for '[x] entries selected' and 'select all / none'
     */
    selectOptionsText: {
      type: Object,
      default: () => ({
        selectAll: "select all",
        selectNone: "select none",
        entriesSelected: "entries selected"
      })
    },
    /**
     * if slot `options-message-area` is not used this variable
     * can be used to customize message text.
     *   this should be a string or an object with the actions needed (default: `delete`,
     *   if `draggable` is `true` than also a `drag` property with suiting text is needed).
     *     in case of a string the same text is used for all actions
     */
    messageText: {
      type: String,
      default: "Drag or Select"
    },
    /**
     * if slot `options-message-area` is not used this variable
     * can be used to customize message subtext.
     *   this should be a string or an object with the actions needed (default: `delete`,
     *   if `draggable` is `true` than also a `drag` property with suiting text is needed).
     *     in case of a string the same text is used for all actions
     */
    messageSubtext: {
      type: String,
      default: "Drag'n Drop to reorder or select the relevant items and choose an action"
    },
    /**
     * determine if boxes can be dragged
     *   (only applicable if `showHeader` and `showOptions` is set to `true`)
     */
    draggable: {
      type: Boolean,
      default: !1
    },
    /**
     * set `true` if pagination should be used
     */
    usePagination: {
      type: Boolean,
      default: !1
    },
    /**
     * if `usePagination` is set `true` this will determine the number of
     * rows shown on one page
     *   (only applicable if `usePagination` is set `true`)
     */
    maxRows: {
      type: Number,
      default: 5
    },
    /**
     * set this `true` if only a limited number of boxes should be shown
     * and rest can be displayed by clicking a "show more" button
     */
    useExpandMode: {
      type: Boolean,
      default: !1
    },
    /**
     * if `useExpandMode` is `true` set the state of 'show more' from outside
     *   the [`.sync` modifier](https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier) may be used on this prop
     */
    expanded: {
      type: Boolean,
      default: !1
    },
    /**
     * Provide text that should be shown within the button with the
     * expand / collapse functionality.
     *   should be an object with props `expand` for text to expand
     *   and `collapse` for text to collapse
     */
    expandText: {
      type: Object,
      default: () => ({
        expand: "more objects",
        collapse: "collapse"
      })
    },
    /**
     * add a number of total elements (needed for `useExpandMode` and
     * `usePagination`)
     */
    total: {
      type: Number,
      default: null
    },
    /**
     * set the current page number from outside if `usePagination` is `true`.
     *   the [`.sync` modifier](https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier) may be used on this prop
     */
    currentPageNumber: {
      type: Number,
      default: null
    },
    /**
     * how many rows should be shown with show more button (expandMode)
     *   (only applicable with `useExpandMode true`)
     */
    maxShowMoreRows: {
      type: Number,
      default: 1
    },
    /**
     * define if the section should scroll to top on page change
     *   (only applicable with `usePagination true`)
     */
    jumpToTop: {
      type: Boolean,
      default: !1
    },
    /**
     * define if the big button box at the end of all attached items should be shown
     */
    showActionButtonBoxes: {
      type: Boolean,
      default: !1
    },
    /**
     * set some config for each action used - needs to be an array of objects with the
     *  following properties:
     *
     *   **text** `string` - the text displayed in the button
     *   **icon** `string` - the icon name to display
     *    (for available icons see [BaseIcon](BaseIcon) )
     *   **value** `string` - the value emitted on button click
     *   **[display='all']** `?string` - define where the action should be displayed:
     *     *top*: only in top row
     *     *bottom*: only in action button box at bottom of list
     *     *all*: on top as well as bottom
     *   **disabled** `?boolean` - disable button
     */
    actionButtonsConfig: {
      type: Array,
      default: () => [{
        text: "delete",
        icon: "waste-bin",
        value: "delete",
        display: "all",
        disabled: !1
      }],
      validator: (t) => t.every((e) => {
        const s = ["text", "icon", "value"], i = Object.keys(e);
        return s.every((o) => i.includes(o)) && (["all", "top", "bottom"].includes(e.display) || !e.display);
      })
    },
    /**
     * define a custom identifier property name for objects in your
     * `entryList` array.
     *   if relevant property is contained in a nested object the string can
     *   be in dot notation. e.g. `nestedObject.id`
     */
    identifierPropertyName: {
      type: String,
      default: "id"
    },
    /**
     * define a custom title property name for objects in your
     * `entryList` array.
     *   if relevant property is contained in a nested object the string can
     *   be in dot notation. e.g. `nestedObject.title`
     */
    titlePropertyName: {
      type: String,
      default: "title"
    },
    /**
     * specify if pagination elements should be a link element - if pagination element should
     * be a link element - please specify the kind of element (currently only Vue components (e.g.
     * [`RouterLink`](https://router.vuejs.org/guide/#router-link),
     * [`NuxtLink`](https://nuxtjs.org/docs/features/nuxt-components/#the-nuxtlink-component)) are supported)
     */
    usePaginationLinkElement: {
      type: [String, Boolean],
      default: !1,
      validator: (t) => typeof t == "boolean" && !t || typeof t == "string" && t
    },
    /**
     * set this variable `true` if pagination is used and data fetching is done per page
     */
    fetchDataExternally: {
      type: Boolean,
      default: !1
    },
    /**
     * specify an additional number of px for the position the page
     * should jump to on page change
     */
    scrollToOffset: {
      type: Number,
      default: 0
    },
    /**
     * specify an initial number of items per row that should be assumed before
     * rendering the page
     */
    // this is necessary because otherwise in SSR serverside and client side DOM tree
    // might not match
    initialItemsPerRow: {
      type: Number,
      default: 6
    },
    /**
     * add text for screen reader users that helps them navigate list and use edit mode
     * functionalities.
     * object should have the following properties:
     *
     *   **description**: Text read on edit mode activation
     *   **activated**: Text read after item was activated for reordering
     *    (selected by enter key)
     *    property moved can contain variable `{pos}` which will be filled with current
     *    position
     *   **moved**: Text read after item was moved
     *    property moved can contain variables `{pos}` (new position) and `{total}` (total number
     *    of list items)
     */
    assistiveText: {
      type: Object,
      default: () => ({
        description: "Select items via space bar to carry out actions or use enter key to select an item for reordering. Use Tab key to navigate between items.",
        activated: "Item at position {pos} selected for reordering. Use arrow keys to order item.",
        moved: "Item moved to position {pos} of {total}",
        loaderActive: "loading."
      })
    },
    /**
     * `BaseResultBoxSection` is for example used to display search results - which contain a link
     * to the entry - in this case the focus should be on the link element so that navigation to
     * route link triggers on enter and focus on the list element itself is disabled (if not edit
     * mode!)
     */
    disableListElementFocus: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      // internal representation of entry list to be able to
      // modify list via draggable
      entryListInt: [],
      // flag for edit mode activated
      editModeActive: !1,
      // current page number
      currentPageNumberInt: 1,
      // store the expand state internally
      expandedInt: !1,
      // store collapsed state on action start
      wasExpanded: !1,
      // how many items do fit in one row
      itemsPerRow: null,
      // try to only do initial box size calculation once
      initialBoxCalcDone: !1,
      // to manipulate selectedList internally
      selectedListInt: [],
      imageBoxesSelectable: !1,
      // unique id to assign javascript calculated styles to
      elementId: null,
      // store state if component is mounted and window is present
      initialized: !1,
      /**
       * variable for keyboard sorting - is element currently selected for moving
       * @type {?string}
       */
      movableElementId: null,
      /**
       * add assistive text especially to ease use of drag mode accessibly
       * @type {string}
       */
      currentAssistiveText: "",
      /**
       * control pagination display with this variable and only render after
       *  entryListInt was initialized from outside
       *  @type {boolean}
       */
      showPagination: !1
    };
  },
  computed: {
    /**
     * to lazy load vuedraggable only if draggable mode is set true
     *
     * @returns {string|(function(): Promise<U>)}
     */
    draggableComponent() {
      return this.draggable ? () => import("vuedraggable").then((t) => t.default || t) : "ul";
    },
    /**
     * get the entries that should be displayed in the section -
     * taking into consideration pagination and 'show more' functionality
     * @returns {Object[]}
     */
    visibleBoxes: {
      get() {
        return this.editModeActive && (this.draggable || !this.usePagination) ? [...this.entryListInt] : !this.editModeActive && this.useExpandMode && !this.expandedInt && this.expandNeeded ? this.entryListInt.slice(0, this.itemsPerRow * this.maxShowMoreRows - 1) : this.usePagination && !this.fetchDataExternally ? this.entryListInt.slice(
          (this.currentPageNumberInt - 1) * this.visibleNumberOfItems,
          this.currentPageNumberInt * this.visibleNumberOfItems
        ) : this.fetchDataExternally ? this.entryList.slice(0, this.visibleNumberOfItems) : this.entryListInt;
      },
      set(t) {
        this.entryListInt = [...t];
      }
    },
    /** PAGINATION AND EXPAND MODE */
    /**
     * the number of items that should be visible on one page
     * (if pagination is active)
     * @returns {number}
     */
    visibleNumberOfItems() {
      const t = this.itemsPerRow * this.maxRows;
      return this.editModeActive && this.showActionButtonBoxes ? t - this.actionButtonsConfig.length : !this.editModeActive && this.useExpandMode ? t - 1 : t;
    },
    /**
     * number of pages (if pagination is active)
     * @returns {number}
     */
    pages() {
      return (this.total || this.entryListInt.length) && this.visibleNumberOfItems >= 0 ? Math.ceil((this.total || this.entryListInt.length) / this.visibleNumberOfItems) : 1;
    },
    /**
     * determines if the total number of entries exceeds the number of entries that
     * can be displayed and thus if an expand button is needed
     */
    expandNeeded() {
      return this.itemsPerRow * this.maxShowMoreRows < this.entryList.length;
    }
  },
  watch: {
    entryList: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.entryListInt) && (this.entryListInt = [...t], this.showPagination || setTimeout(() => {
          this.showPagination = !0;
        }, 0));
      },
      immediate: !0,
      deep: !0
    },
    entryListInt: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.entryList) && this.$emit("entries-changed", t);
      },
      deep: !0
    },
    // watch selectedList prop and assign to internal value if changes occur
    selectedList: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.selectedListInt) && (this.selectedListInt = JSON.parse(JSON.stringify(t)));
      },
      immediate: !0
    },
    // watch selectedList prop and assign to internal value if changes occur
    selectedListInt(t) {
      JSON.stringify(t) !== JSON.stringify(this.selectedList) && this.$emit("update:selected-list", t);
    },
    // watch pages in case of deletion of items and take care
    // current page is not higher than total page number
    pages: {
      handler(t) {
        this.currentPageNumberInt > t && (this.currentPageNumberInt = t);
      },
      immediate: !0
    },
    // update internal page number if changed from outside
    currentPageNumber: {
      handler(t) {
        t !== this.currentPageNumberInt && (this.currentPageNumberInt = t > this.pages && !this.fetchDataExternally ? this.pages : t);
      },
      immediate: !0
    },
    /**
     * watch internal page number to inform parent about changes
     * @param {number} val
     */
    currentPageNumberInt: {
      handler(t) {
        t !== this.currentPageNumber && this.$emit("update:current-page-number", this.currentPageNumberInt);
      },
      immediate: !0
    },
    // if expanded variable is set from outside change
    // internal variable accordingly
    expanded: {
      handler(t) {
        t !== this.expandedInt && (this.expandedInt = t);
      },
      immediate: !0
    },
    // if internal value changes, reset page number and inform parent
    expandedInt(t) {
      t || (this.currentPageNumberInt = 1), t !== this.expanded && this.$emit("update:expanded", t);
    },
    editModeActive(t) {
      setTimeout(() => {
        this.imageBoxesSelectable = t;
      }, 50), setTimeout(() => {
        t && this.$nextTick(() => {
          this.$refs.resultBoxItem && this.$refs.resultBoxItem.length && (this.$refs.resultBoxItem.forEach((s) => {
            s.getElementsByTagName("input")[0].setAttribute("tabindex", "-1");
          }), this.$refs.resultBoxItem.find((s) => s.id.includes(this.visibleBoxes[0].id)).focus({ preventScroll: !0 }));
        });
      }, 500), t ? this.currentAssistiveText = this.assistiveText.description : (this.movableElementId = null, this.currentAssistiveText = ""), t !== this.editMode && this.$emit("update:edit-mode", t), this.initialized && (t ? window.addEventListener("keyup", this.escEventHandler) : window.removeEventListener("keyup", this.escEventHandler));
    },
    editMode: {
      handler(t) {
        t !== this.editModeActive && (this.editModeActive = t && this.showOptions && this.showHeader);
      },
      immediate: !0
    },
    showOptions(t) {
      t || (this.editModeActive = !1);
    },
    showHeader(t) {
      t || (this.editModeActive = !1);
    }
  },
  created() {
    this.useExpandMode || (this.expandedInt = !0), this.itemsPerRow = this.initialItemsPerRow;
  },
  mounted() {
    this.elementId = this._uid, !this.initialBoxCalcDone && this.$refs.resultBoxesArea && this.calcBoxNumber(), window.addEventListener("resize", this.resizeBoxes), this.initialized = !0;
  },
  updated() {
    !this.initialBoxCalcDone && this.$refs.resultBoxesArea && this.calcBoxNumber();
  },
  methods: {
    /** EDIT MODE FUNCTIONALITIES */
    /**
     * toggling of options when options are behind a 'options' button
     *
     * @param {Boolean} actionsVisible true for open, false for close
     */
    optionsToggle(t) {
      this.editModeActive = t, t ? this.wasExpanded = this.expandedInt : (this.expandedInt = this.wasExpanded, this.selectedListInt = []);
    },
    /**
     * function triggered when selecteAll was clicked in select mode
     *
     * @param {boolean} selectAll - true if everything was selected,
     * false if everything was deselected
     */
    selectAllTriggered(t) {
      if (t)
        this.selectedListInt = [.../* @__PURE__ */ new Set([
          ...this.selectedListInt,
          ...this.visibleBoxes.map((e) => this.getPropValue(this.identifierPropertyName, e))
        ])];
      else {
        const e = this.visibleBoxes.map((s) => this.getPropValue(this.identifierPropertyName, s));
        this.selectedListInt = this.selectedListInt.filter((s) => !e.includes(this.getPropValue(this.identifierPropertyName, s) || s));
      }
    },
    /**
     * triggered when an entry is selected or is clicked upon
     *
     * @param {string} entryId - the entry id of the selected entry
     * @param {boolean} [selected=undefined] - not provided and thus undefined
     * if entry was clicked
     */
    entrySelected(t, e) {
      e && !this.selectedListInt.includes(t) ? this.selectedListInt.push(t) : e || (this.selectedListInt = this.selectedListInt.filter((s) => s !== t));
    },
    /**
     * function to calc if image box is currently selected
     *
     * @param {Object} entry - the entry in question
     * @returns {Boolean}
     */
    isEntrySelected(t) {
      return this.selectedListInt.map((e) => this.getPropValue(this.identifierPropertyName, e) || e).includes(this.getPropValue(this.identifierPropertyName, t));
    },
    /**
     * function triggered when user has
     * clicked action button to go through with the action
     */
    submitAction(t) {
      this.$emit("submit-action", t);
    },
    /**
     * intercept escape key event and reset edit mode
     */
    escEventHandler(t) {
      t.key === "Escape" && (this.movableElementId ? this.cancelDragMode() : (this.editModeActive = !1, this.currentAssistiveText = ""));
    },
    /**
     * event handler on keydown 'Enter'
     * @param {KeyboardEvent} event - the keydown event
     * @param {Object} entry - the entry the event was triggered on
     * @param {number} index - the index of the entry in the visibleBoxes array
     */
    onEnterKey(t, e, s) {
      this.editModeActive && this.draggable ? (t.preventDefault(), this.movableElementId ? this.cancelDragMode() : (this.movableElementId = e.id, this.currentAssistiveText = this.assistiveText.activated.replace("{pos}", (s + 1).toString()))) : this.entryClicked(this.getPropValue(this.identifierPropertyName, e));
    },
    /**
     * event handler on keydown with arrow keys
     * @param {KeyboardEvent} event - the keydown event
     * @param {number} index - the index of the entry on which the event was triggered
     *  in the visibleBoxes array
     */
    moveEntry(t, e) {
      this.currentAssistiveText = "";
      const { key: s } = t, i = ["ArrowRight", "ArrowDown"].includes(s), n = e + (i ? 1 : -1);
      if (this.isWithinArrayLimit(this.visibleBoxes, i, n)) {
        const r = this.visibleBoxes;
        [r[e], r[n]] = [r[n], r[e]], this.visibleBoxes = r, this.$nextTick(() => {
          document.getElementById(`li-${this.movableElementId}`).focus();
        }), this.currentAssistiveText = this.assistiveText.moved.replace("{pos}", n + 1).replace("{total}", this.visibleBoxes.length);
      }
    },
    /**
     * reset drag related variable and assistive text
     */
    cancelDragMode() {
      this.movableElementId = null, this.currentAssistiveText = "";
    },
    /** BOX DISPLAY FUNCTIONALITIES */
    /**
     * timeout function for resize event to limit the number of times
     * box number is recalculated
     */
    resizeBoxes() {
      this.resizeTimeout && (clearTimeout(this.resizeTimeout), this.resizeTimeout = null), this.resizeTimeout = setTimeout(() => {
        this.calcBoxNumber();
      }, 300);
    },
    /**
     * calculate the box number according to available space and breaking points set
     */
    calcBoxNumber() {
      const t = this.$refs.resultBoxesArea && this.$refs.resultBoxesArea.$el ? this.$refs.resultBoxesArea.$el : this.$refs.resultBoxesArea;
      if (t) {
        const e = t.clientWidth, s = [...this.boxBreakpoints];
        this.itemsPerRow = s.sort((n, r) => n[0] > r[0]).reduce((n, [r, a]) => e > r ? a : n, 0), this.$el.style.setProperty("--items-per-row", this.itemsPerRow);
        const i = `base-result-box-section__box-style-${this.elementId}`;
        let o = document.getElementById(i);
        o || (o = document.createElement("style"), o.id = i, this.$el.appendChild(o)), o.innerHTML = `
          .base-result-box-section__box-item-${this.elementId}:nth-child(n + ${this.itemsPerRow + 1}) {
            margin-top: var(--spacing-regular);
          }
          .base-result-box-section__box-item-${this.elementId}:not(:nth-child(${this.itemsPerRow}n)) {
            margin-right: var(--spacing-regular);
          }`, this.initialBoxCalcDone = !0, this.$emit("items-per-row-changed", this.itemsPerRow);
      }
    },
    /** PAGINATION */
    /**
     * function triggered when page in pagination component is selected
     *
     * @param {number} number - the selected page number
     */
    setPage(t) {
      this.currentPageNumberInt = t, this.jumpToTop && window.scrollTo(0, this.$el.offsetTop - this.scrollToOffset);
    },
    /** GENERAL FUNCTIONALITIES */
    /**
     * triggered when an entry is clicked upon (edit mode not acive)
     *
     * @param {string} entryId - the entry id of the selected entry
     */
    entryClicked(t) {
      this.$emit("entry-clicked", { entryId: t });
    },
    /**
     * get an internationalized string
     *
     * @param {string|Object} localizationArguments - string or object to look
     * up in localization files
     *   if it is an object it should have the following properties:
     * @property {string} string - string to look up in a Locale messages file
     * @property {number} count - for pluralization
     * @property {Object} variables - locale string variables object
     * @returns {string}
     */
    getI18nString(t) {
      if (typeof t == "string")
        return this.getI18nTerm(t);
      const { string: e, count: s, variables: i } = { ...t };
      return this.getI18nTerm(e, s, i);
    },
    /**
     * to get a nested object property value from a string in dot notation
     *
     * @param {string} string - the nested object property path in dot notation
     * @param {Object} object - the object from which the property value should be extracted
     * @returns {*}
     */
    getPropValue(t, e) {
      return l(t, e);
    }
  }
};
var m = function() {
  var e = this, s = e._self._c;
  return s("div", { staticClass: "base-result-box-section" }, [e.isLoading ? s("div", { staticClass: "base-result-box-section__loading" }, [s("BaseLoader", { staticClass: "base-result-box-section__loader", attrs: { "text-on-loader-show": e.assistiveText.loaderActive } })], 1) : e._e(), s("div", { staticClass: "base-result-box-section__container" }, [e.showHeader ? s("div", { staticClass: "base-result-box-section__header-row" }, [e.showOptions ? s("BaseOptions", { attrs: { "show-options": e.editModeActive, "options-button-icon": e.optionsButtonIcon, "options-button-text": e.optionsButtonText, "use-options-button-on": "always" }, on: { "update:show-options": e.optionsToggle }, scopedSlots: e._u([{ key: "beforeOptions", fn: function() {
    return [e._t("header", function() {
      return [e.headerText ? s("h3", { staticClass: "base-result-box-section__header" }, [e._v(" " + e._s(e.headerText) + " ")]) : e._e()];
    })];
  }, proxy: !0 }, { key: "options", fn: function() {
    return [e._t("optionButtons", function() {
      return [e._l(e.actionButtonsConfig, function(i) {
        return [i.display === "top" || i.display === "all" || !i.display ? s("BaseButton", { key: i.text, attrs: { text: e.getI18nString(i.text), icon: i.icon, "has-background-color": !1, disabled: i.disabled, "icon-size": "large", "button-style": "single" }, on: { clicked: function(o) {
          return e.submitAction(i.value);
        } } }) : e._e()];
      })];
    }, { submitAction: e.submitAction })];
  }, proxy: !0 }], null, !0) }) : [e._t("header", function() {
    return [e.headerText ? s("h3", { staticClass: "base-result-box-section__header" }, [e._v(" " + e._s(e.headerText) + " ")]) : e._e()];
  })]], 2) : e._e(), s("div", { class: [
    "base-result-box-section__background",
    {
      "base-result-box-section__background--white": e.editModeWhiteBackground && e.editModeActive
    }
  ] }, [e.editModeActive ? s("div", { key: e.headerText + "_messageArea", staticClass: "base-result-box-section__message-area" }, [s("div", { staticClass: "base-result-box-section__message-area-text" }, [e._v(" " + e._s(e.messageText) + " ")]), s("span", { staticClass: "base-result-box-section__message-area-subtext" }, [e._v(e._s(e.messageSubtext))]), e._t("optionsMessageAreaAfter")], 2) : e._e(), e.editModeActive ? s("BaseSelectOptions", { key: e.headerText + "_selectOptions", attrs: { "selected-number-text": e.getI18nString(e.selectOptionsText.entriesSelected), "select-text": e.getI18nString(e.selectOptionsText.selectAll), "deselect-text": e.getI18nString(e.selectOptionsText.selectNone), list: e.visibleBoxes, "selected-list": e.selectedListInt }, on: { selected: e.selectAllTriggered } }) : e._e(), s("span", { staticClass: "assistive-text", attrs: { "aria-live": "assertive" } }, [e._v(" " + e._s(e.currentAssistiveText) + " ")]), e.entryListInt.length ? [s(e.draggableComponent, { ref: "resultBoxesArea", tag: "component", staticClass: "base-result-box-section__boxes-container", attrs: { animation: e.draggable ? 150 : !1, tag: e.draggable ? "ul" : !1, draggable: e.editModeActive ? ".base-result-box-section__result-box-item" : !1, "aria-label": e.headerText, tabindex: "0", handle: ".base-result-box-section__result-box-item__draggable .base-image-box", "force-fallback": "true", role: "list" }, model: { value: e.visibleBoxes, callback: function(i) {
    e.visibleBoxes = i;
  }, expression: "visibleBoxes" } }, [e._l(e.visibleBoxes, function(i, o) {
    return s("li", { key: e.getPropValue(e.identifierPropertyName, i), ref: "resultBoxItem", refInFor: !0, class: [
      "base-result-box-section__box-item",
      "base-result-box-section__result-box-item",
      { "base-result-box-section__box-item__hidden": !e.initialBoxCalcDone },
      `base-result-box-section__box-item-${e.elementId}`,
      {
        "base-result-box-section__result-box-item__draggable": e.draggable && e.editModeActive
      },
      {
        "base-result-box-section__result-box-item__dragging": e.movableElementId === i.id
      }
    ], attrs: { id: `li-${i.id}`, tabindex: e.editModeActive || !e.disableListElementFocus ? 0 : -1, "aria-label": e.getPropValue(e.titlePropertyName, i), "aria-grabbed": (e.movableElementId === i.id).toString(), "aria-selected": e.editModeActive ? e.isEntrySelected(i).toString() : !1 }, on: { keydown: [function(n) {
      return !n.type.indexOf("key") && e._k(n.keyCode, "enter", 13, n.key, "Enter") ? null : e.onEnterKey(n, i, o);
    }, function(n) {
      if (!n.type.indexOf("key") && e._k(n.keyCode, "up", 38, n.key, ["Up", "ArrowUp"]) && e._k(n.keyCode, "down", 40, n.key, ["Down", "ArrowDown"]) && e._k(n.keyCode, "left", 37, n.key, ["Left", "ArrowLeft"]) && e._k(n.keyCode, "right", 39, n.key, ["Right", "ArrowRight"]) || "button" in n && n.button !== 0 || "button" in n && n.button !== 2)
        return null;
      n.preventDefault(), e.editModeActive && e.draggable && e.movableElementId && e.moveEntry(n, o);
    }, function(n) {
      if (!n.type.indexOf("key") && e._k(n.keyCode, "space", 32, n.key, [" ", "Spacebar"]))
        return null;
      n.preventDefault(), e.editModeActive && e.entrySelected(
        e.getPropValue(e.identifierPropertyName, i),
        !e.isEntrySelected(i)
      );
    }, function(n) {
      return !n.type.indexOf("key") && e._k(n.keyCode, "tab", 9, n.key, "Tab") ? null : e.cancelDragMode.apply(null, arguments);
    }] } }, [e._t("resultBox", function() {
      return [s("BaseImageBox", { key: e.getPropValue(e.identifierPropertyName, i), attrs: { selectable: e.imageBoxesSelectable, draggable: e.editModeActive && e.draggable, selected: e.isEntrySelected(i), "box-size": { width: "auto" }, "box-ratio": 100, title: e.getPropValue(e.titlePropertyName, i), subtext: i.subtext, description: i.description, "image-url": i.imageUrl, "box-text": i.text, lazyload: !0 }, on: { "select-triggered": function(n) {
        e.entrySelected(
          e.getPropValue(e.identifierPropertyName, i),
          n
        );
      }, clicked: function(n) {
        e.entryClicked(e.getPropValue(e.identifierPropertyName, i));
      } } })];
    }, { item: i, index: o, selectActive: e.editModeActive, isEntrySelected: e.isEntrySelected, entrySelected: e.entrySelected })], 2);
  }), e.showActionButtonBoxes && e.editModeActive ? e._t("actionButtons", function() {
    return [e._l(e.actionButtonsConfig, function(i) {
      return [i.display === "bottom" || i.display === "all" || !i.display ? s("BaseBoxButton", { key: i.value, class: [
        "base-result-box-section__box-item",
        `base-result-box-section__box-item-${e.elementId}`
      ], attrs: { text: e.getI18nString(i.text), "box-size": { width: "calc(25% - 8rem/19 - (8rem/19/2))", height: "100%" }, icon: i.icon, "box-style": "small", "box-type": "button" }, on: { clicked: function(o) {
        return e.submitAction(i.value);
      } } }) : e._e()];
    })];
  }, { itemsPerRow: e.itemsPerRow, elementId: e.elementId }) : e.useExpandMode && !e.editModeActive && e.expandNeeded && e.initialBoxCalcDone ? s("BaseBoxButton", { class: [
    "base-result-box-section__box-item",
    `base-result-box-section__box-item-${e.elementId}`
  ], attrs: { "box-size": { width: "calc(25% - 8rem/19 - (8rem/19/2))", height: "100%" }, icon: "", text: "", "box-type": "button" }, on: { clicked: function(i) {
    e.expandedInt = !e.expandedInt;
  } }, scopedSlots: e._u([{ key: "default", fn: function() {
    return [e.editModeActive ? e._e() : s("div", { staticClass: "base-result-box-section__expand-button__content" }, [e.expandedInt ? e._e() : s("span", { staticClass: "base-result-box-section__expand-button__content-number" }, [e._v(" " + e._s(`+${(e.total || e.entryList.length) - e.visibleBoxes.length}`) + " ")]), s("span", { class: [e.expandedInt ? "base-result-box-section__expand-button__content-text-expanded" : "base-result-box-section__expand-button__content-text-collapsed"] }, [e._v(" " + e._s(e.expandedInt ? e.expandText.collapse : e.expandText.expand) + " ")])])];
  }, proxy: !0 }], null, !1, 500459990) }) : e._e()], 2), e.usePagination && e.showPagination && e.pages > 1 && (e.editModeActive && !e.draggable || !e.editModeActive && e.expandedInt) ? s("BasePagination", { key: "pagination-" + e.elementId, attrs: { total: e.pages, current: e.currentPageNumberInt, "use-link-element": e.usePaginationLinkElement }, on: { "set-page": e.setPage } }) : e._e()] : e._e()], 2)])]);
}, f = [], b = /* @__PURE__ */ h(
  p,
  m,
  f,
  !1,
  null,
  "17f515da",
  null,
  null
);
const I = b.exports;
export {
  I as default
};
//# sourceMappingURL=BaseResultBoxSection.vue.es.js.map
