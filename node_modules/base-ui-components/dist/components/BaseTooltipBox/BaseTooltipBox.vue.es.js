import d from "vue-click-outside";
import { ref as a, watchEffect as h } from "vue";
import { createId as c } from "../../utils/utils.es.js";
import { useTabKeyHandler as u } from "../../composables/useTabKeyHandler.es.js";
import b from "../BaseIcon/BaseIcon.vue.es.js";
import p from "../../mixins/popUpLock.es.js";
import "./BaseTooltipBox.vue.es2.js";
import f from "../../_virtual/_plugin-vue2_normalizer.es.js";
const m = {
  name: "BaseTooltipBox",
  components: {
    BaseIcon: b
  },
  directives: {
    ClickOutside: d
  },
  mixins: [p],
  props: {
    /**
     * HTMLElement to attach the tooltip
     * e.g.: vue ref element
     */
    attachTo: {
      type: null,
      // HTMLElement makes troubles with nuxt/nuxt-bridge
      required: !0
    },
    /**
     * define the default direction order
     */
    directionOrder: {
      type: Array,
      default: () => ["top", "bottom", "right", "left"],
      validator: (t) => [...t].sort().toString() === ["top", "bottom", "right", "left"].sort().toString()
    },
    /**
     * add additional styling
     * **caveat**: properties `top`, `left` and `right` will be overwritten due position calculation
     */
    styles: {
      type: Object,
      default: () => ({})
    },
    /**
     * title of the modal popup on mobile
     * if more customization is needed, use the slot `header-title` instead
     */
    modalTitle: {
      type: String,
      default: ""
    },
    /**
     * specify how the component is rendered on mobile resolutions
     *
     * **box**: component is rendered at the `attachTo` HTMLElement
     * **modal**: component is rendered as a modal popup
     * **fullscreen**: component is rendered as ap popup with max height and width
     */
    typeOnMobile: {
      type: String,
      default: "modal",
      validator: (t) => ["box", "fullscreen", "modal"].includes(t)
    },
    /**
     * specify a threshold value in px for the box top position calculation
     * Useful to prevent top alignment of the TooltipBox, for example, when there is a fixed-positioned header (BaseHeader).
     *
     * Note: The value can also be set globally with the CSS variable `--base-tooltip-box-threshold-top`.
     *       The property will be overwritten by the CSS variable.
     */
    thresholdTop: {
      type: Number,
      default: 0
    },
    /**
     * customize the tooltipbox id.
     *  if you are using the `header-title` slot this should also be set as id on your custom title element
     *  (it is also available via slot binding)
     */
    headerId: {
      type: [String, Number],
      default: "popup-title"
    },
    /**
     * specify the id of the element containing a description - for accessibility only
     */
    descriptionElementId: {
      type: String,
      default: "popup-body"
    },
    /**
     * define if the overlay background should be visible
     * (semitransparent black) - this only applies to `typeOnMobile` 'modal'
     */
    overlayBackgroundVisible: {
      type: Boolean,
      default: !1
    },
    /**
     * define a custom size (in px) when the component should switch to mobile view
     */
    mobileSize: {
      type: Number,
      default: 640
    },
    /**
     * HTMLElement to focus after opening the tooltip
     * Note: If empty, the header title will be focused by default.
     *       If using the slot for a custom header, be sure to
     *       define an id attribute with the value `headerId`
     *       The value should be a valid CSS selector.
     */
    initialFocusElement: {
      type: String,
      default: ""
    },
    /**
     * list of focusable HTML elements using tab key navigation
     */
    focusableElements: {
      type: Array,
      // also add all elements in general that have a tabindex, except the ones with value -1
      default: () => ["a[href]", "button:enabled", "input:enabled", '*[tabindex]:not([tabindex="-1"])']
    },
    /**
     * specify to disable the tab key handler within the component
     */
    disableTabKeyHandler: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const e = `base-tooltip-box-${c()}`, i = a(null), { focusableHTMLTags: s, disableHandler: o } = u(i, t.focusableElements.join(", "), t.disableTabKeyHandler);
    return h(() => {
      s.value = t.focusableElements, o.value = t.disableTabKeyHandler;
    }), {
      internalId: e,
      popUpBody: i
    };
  },
  data() {
    return {
      isActive: !1,
      direction: null,
      css: {
        top: "0",
        left: "-10000px"
      },
      thresholdX: 2,
      // px, distance between tooltip and attachTo element
      thresholdY: 2,
      // px, distance between tooltip and attachTo element
      spacing: 8,
      // px, distance from window's left or right boundary
      bodyHeight: null,
      bodyInnerHeight: null,
      fadeOutTop: !1,
      fadeOutBottom: !1,
      // resize observer for specific element
      resizeObserver: null,
      // mutation observer for specific element
      mutationObserver: null,
      // guard for click-outside-event
      isClickOutsideActive: !1,
      // this is needed for popUpLock mixin
      targetName: "popUpBody",
      showInt: !1,
      // HTML element that should be focused when the component is closed
      prevActiveElement: void 0
    };
  },
  computed: {
    /**
     * compare body and inner height and evaluate if body is scrollable
     * @returns {boolean}
     */
    isScrollable() {
      return this.bodyInnerHeight > this.bodyHeight;
    },
    /**
     * get the thresholdTop value from the CSS variables if defined,
     * create a temporary ghost element and evaluate the computed style value,
     * otherwise use the component prop
     * @returns {number}
     */
    getThresholdTop() {
      const e = getComputedStyle(document.body).getPropertyValue("--base-tooltip-box-threshold-top");
      if (!e)
        return this.thresholdTop;
      if (/^\d+$/.test(e))
        return Number(e);
      const i = document.createElement("div");
      i.style.position = "absolute", i.style.top = e, i.style.visibility = "hidden", document.body.appendChild(i);
      const s = window.getComputedStyle(i).top, o = Number(s.replace(/\D/g, ""));
      return i.remove(), o;
    }
  },
  watch: {
    /**
     * watch if attachTo has changed and calculate the component position again
     */
    attachTo() {
      this.$nextTick(() => {
        this.calcContentHeight(), this.calcFadeOuts(), this.calcPosition();
      });
    }
  },
  mounted() {
    this.prevActiveElement = document == null ? void 0 : document.activeElement, document.querySelector("body").appendChild(this.$el), setTimeout(() => {
      this.isClickOutsideActive = !0;
    }, 0), setTimeout(() => {
      this.calcPosition(), this.isActive = !0, this.showInt = this.isPopUpLockEnabled(), this.initObserver(), this.focusInitialElement(), this.$refs.body.addEventListener("scroll", this.scrollHandler), window.addEventListener("resize", this.resizeHandler), window.addEventListener("keyup", this.escEventHandler);
    }, 0);
  },
  beforeDestroy() {
    this.isActive = !1, this.showInt = !1, this.prevActiveElement && JSON.stringify(this.prevActiveElement.classList) !== JSON.stringify(document.activeElement.classList) && this.prevActiveElement.focus(), this.resizeObserver && this.resizeObserver.unobserve(this.$refs.bodyInner), this.mutationObserver && this.mutationObserver.disconnect(), this.$refs.body.removeEventListener("scroll", this.scrollHandler), window.removeEventListener("resize", this.resizeHandler), window.removeEventListener("keyup", this.escEventHandler);
  },
  methods: {
    /**
     * check if popup scroll lock handler is enabled
     * @returns {boolean}
     */
    isPopUpLockEnabled() {
      return (this.typeOnMobile === "modal" || this.typeOnMobile === "fullscreen") && window.innerWidth < 640;
    },
    /**
     * calc content related heights
     */
    calcContentHeight() {
      !this.$refs.body || !this.$refs.bodyInner || (this.bodyHeight = Math.ceil(this.$refs.body.getBoundingClientRect().height), this.bodyInnerHeight = Math.ceil(this.$refs.bodyInner.getBoundingClientRect().height));
    },
    /**
     * calc absolute tooltip and inner triangle position
     */
    calcPosition() {
      this.css = {};
      const t = this.attachTo.getBoundingClientRect(), e = this.$el, i = e.offsetWidth, s = e.offsetHeight, o = parseFloat(window.getComputedStyle(e, ":after").height) / 2, l = parseFloat(window.getComputedStyle(e, ":after").width) / 2, { scrollY: n } = window;
      if (this.directionOrder.every((r) => r === "left" && t.left > i + l && !(t.top + t.height / 2 - this.getThresholdTop < s / 2) && !(window.innerHeight - (t.top + t.height / 2) < s / 2) ? (this.direction = "left", this.css.top = `${t.top + t.height / 2 - s / 2 + n}px`, this.css.left = `${t.left - i - l - this.thresholdX}px`, !1) : r === "right" && window.innerWidth - t.right > i + l && !(t.top + t.height / 2 - this.getThresholdTop < s / 2) && !(window.innerHeight - (t.top + t.height / 2) < s / 2) ? (this.direction = "right", this.css.top = `${t.top + t.height / 2 - s / 2 + n}px`, this.css.left = `${t.right + l + this.thresholdX}px`, !1) : r === "top" && t.top - this.getThresholdTop > s + o + this.thresholdY ? (this.direction = "top", this.css.top = `${t.top - s - o - this.thresholdY + n}px`, this.css.left = `${t.left + t.width / 2 - i / 2}px`, !1) : r === "bottom" && window.innerHeight - t.bottom > s + o + this.thresholdY + this.spacing ? (this.direction = "bottom", this.css.top = `${t.bottom + o + this.thresholdY + n}px`, this.css.left = `${t.left + t.width / 2 - i / 2}px`, !1) : !0), this.css["--triangle-left"] = "50%", !!["top", "bottom"].includes(this.direction)) {
        if (t.x < i / 2) {
          this.css.left = `${this.spacing}px`, this.css.right = "", this.css["--triangle-left"] = `${t.left + t.width / 2 - this.spacing}px`;
          return;
        }
        t.left + t.width / 2 + i / 2 > window.innerWidth && (this.css.left = "", this.css.right = `${this.spacing}px`, this.css["--triangle-left"] = `${i + this.spacing - (document.body.clientWidth - (t.right - t.width / 2))}px`);
      }
    },
    /**
     * evaluate if fade-outs (top, bottom) are displayed based on current scroll position
     */
    calcFadeOuts() {
      if (!this.isScrollable || !this.$refs.body)
        return;
      const { scrollTop: t } = this.$refs.body;
      this.fadeOutTop = t >= 1, this.fadeOutBottom = !(t + this.bodyHeight >= this.bodyInnerHeight);
    },
    /**
     * trigger event to remove/close the component
     */
    close() {
      this.$emit("close");
    },
    /**
     * intercept click-outside event and close the component
     */
    clickedOutside() {
      this.isClickOutsideActive && this.close();
    },
    /**
     * create resize/mutation observer for the content container
     */
    initObserver() {
      const t = new ResizeObserver(() => {
        this.calcContentHeight(), this.calcFadeOuts();
      }), e = new MutationObserver(() => {
        this.calcContentHeight(), this.calcFadeOuts(), this.calcPosition();
      });
      t.observe(this.$refs.bodyInner), e.observe(this.$refs.bodyInner, { childList: !0, subtree: !0 }), this.resizeObserver = t, this.mutationObserver = e;
    },
    /**
     * determine which element should be focused when opening the component
     */
    focusInitialElement() {
      setTimeout(() => {
        const t = this.$el.id;
        let e = t ? document == null ? void 0 : document.getElementById(t) : void 0;
        this.typeOnMobile !== "box" && this.isMobile() && (e = this.headerId ? this.$el.querySelector(`#${this.headerId}`) : void 0), this.initialFocusElement && this.$el.querySelector(this.initialFocusElement) && (e = this.$el.querySelector(this.initialFocusElement)), e && e.focus();
      }, 0);
    },
    /**
     * intercept resize event and close the component
     */
    resizeHandler() {
      this.calcPosition();
    },
    /**
     * intercept scroll event and set fade-outs
     */
    scrollHandler() {
      this.calcFadeOuts();
    },
    /**
     * intercept escape key event and reset edit mode
     */
    escEventHandler(t) {
      t.key === "Escape" && this.close();
    },
    /**
     * check if the window has a mobile resolution
     * @returns {boolean}
     */
    isMobile() {
      return (window == null ? void 0 : window.innerWidth) <= this.mobileSize;
    }
  }
};
var y = function() {
  var e = this, i = e._self._c;
  return i("div", { directives: [{ name: "click-outside", rawName: "v-click-outside", value: () => e.clickedOutside(), expression: "() => clickedOutside()" }], ref: "popUpBody", class: [
    "base-tooltip-box",
    { "base-tooltip-box--background-visible": e.overlayBackgroundVisible },
    "base-tooltip-box--" + e.direction,
    { "base-tooltip-box--modal-on-mobile": e.typeOnMobile === "modal" || e.typeOnMobile === "fullscreen" },
    { "base-tooltip-box--fullscreen-on-mobile": e.typeOnMobile === "fullscreen" },
    { "base-tooltip-box--active": e.isActive }
  ], style: { ...e.styles, ...e.css }, attrs: { id: e.internalId, role: "dialog", tabindex: "-1", "aria-labelledby": e.headerId, "aria-describedby": e.descriptionElementId } }, [i("div", { staticClass: "base-tooltip-box__inner", attrs: { id: e.descriptionElementId } }, [i("div", { staticClass: "base-tooltip-box__header" }, [e._t("header-title", function() {
    return [i("div", { staticClass: "base-tooltip-box__header__title", attrs: { id: e.headerId, tabindex: "-1" } }, [e._v(" " + e._s(e.modalTitle) + " ")])];
  }, { headerId: e.headerId }), i("button", { staticClass: "base-tooltip-box__button", attrs: { title: "close" }, on: { click: e.close } }, [i("BaseIcon", { staticClass: "base-tooltip-box__button__icon", attrs: { name: "remove" } })], 1)], 2), i("div", { ref: "body", class: [
    "base-tooltip-box__body",
    { "base-tooltip-box__body--fade-out": e.fadeOutTop || e.fadeOutBottom },
    { "base-tooltip-box__body--fade-out--top": e.fadeOutTop },
    { "base-tooltip-box__body--fade-out--bottom": e.fadeOutBottom }
  ] }, [i("div", { ref: "bodyInner", staticClass: "base-tooltip-box__body__inner" }, [e._t("default", function() {
    return [i("i", [e._v("use default slot")])];
  })], 2)])])]);
}, g = [], v = /* @__PURE__ */ f(
  m,
  y,
  g,
  !1,
  null,
  "12e91bf4",
  null,
  null
);
const I = v.exports;
export {
  I as default
};
//# sourceMappingURL=BaseTooltipBox.vue.es.js.map
