import m from "../BaseIcon/BaseIcon.vue.es.js";
import p from "./BaseCollapsedFilterItem.vue.es.js";
import { hasData as f } from "../../utils/utils.es.js";
import "./BaseCollapsedFilterRow.vue.es2.js";
import u from "../../_virtual/_plugin-vue2_normalizer.es.js";
const b = {
  name: "BaseCollapsedFilterRow",
  components: {
    BaseCollapsedFilterItem: p,
    BaseIcon: m
  },
  props: {
    /**
     * provide a list of filters in array form, every array object that needs the following properties:
     *  **idInternal** `string` - a filter identifier
     *  **labelInternal** `string` - a label shown for the filter
     *  **filter_values** `{
     *    values: { labelInternal: string|boolean, idInternal: string? }[]|{ values: {}, fieldId: string, fieldType: string }[]
     *    fieldId: string,
     *    fieldType: string,
     *   }[]` - the values that were selected for the filter (set by BaseAdvancedSearch internally), this is again
     *    an array of objects with the properties
     *      `values` - either containing the actual values to display (with `labelInternal` and `idInternal` (optional) properties)
     *      OR in case of field groups to have nested another object array with `fieldType`, `fieldId` and `values` properties
     *      again (see below for description)
     *    `fieldId`: the property of the form field in question
     *    `fieldType`: the type of the field in question
     */
    filters: {
      type: Array,
      default: () => [],
      validator: (t) => {
        const e = ["idInternal", "labelInternal", "filter_values"], s = ["values", "fieldType", "fieldId"];
        return !t.some((l) => {
          const a = Object.keys(l), n = Object.keys(l.filter_values);
          let r = e.some((i) => !a.includes(i));
          return r || (r = s.some((i) => !n.includes(i)), r || (r = l.filter_values.values.some((i) => {
            var o;
            if (((o = i == null ? void 0 : i.values) == null ? void 0 : o.length) >= 0) {
              const c = Object.keys(i);
              return i.values.length !== 0 && s.some((d) => !c.includes(d)) && i.values.some((d) => !Object.keys(d).includes("labelInternal"));
            }
            return !Object.keys(i).includes("labelInternal");
          }))), r;
        });
      }
    },
    /**
     * set the text displayed for date or time values of ranges where only one field is
     * filled.
     */
    dateTimeText: {
      type: Object,
      default: () => ({
        from: "from",
        until: "until",
        range: "to"
      }),
      validator: (t) => !["from", "until", "range"].some((e) => !Object.keys(t).includes(e))
    },
    /**
     * if necessary selected chip text can be rendered as v-html directive
     * can be `true` (all fields will have html rendering enabled) `false` or a list
     *  of field names for which rendering should be enabled, for nested fields
     *  specify an object with a list of child field names.
     *  e.g. :interpretLabelAsHtml="['field1', { [field2]: ['childField1'] }]"
     */
    interpretLabelAsHtml: {
      type: [Boolean, Array],
      default: !1
    },
    /**
     * **removeFiltersLabel**: add a descriptive label used for the remove all
     *  filters icon in collapsed row
     * **filterRemovedNotification**: notification that is read by screenreaders when a filter
     *  value was removed. Add the string {value} to read the filter value that was removed and
     *  {label} to read the label of the filter from which the value was removed.
     * **appliedFiltersLabel**: description for the filters in the collapsed filter row.
     * **booleanFilterLabel**: Set text that should be read for a boolan filter value. You may add
     *      the string {label} which will be replaced by the filter label.
     * **optionToRemoveSelected**: text read when an option is focused (and thus selected), should
     *  announce to the screen reader user that option can now be removed via Backspace or Delete.
     */
    assistiveText: {
      type: Object,
      default: () => ({
        removeFiltersLabel: "Remove all filters.",
        filterRemovedNotification: "Filter value {value} was removed from filter {label}.",
        appliedFiltersLabel: "Currently applied Filters",
        booleanFilterLabel: "Filter {label} was set",
        optionToRemoveSelected: "Press delete or backspace to remove."
      })
    }
  },
  data() {
    return {
      /**
       * internal representation of filters list, for a list of object properties see
       *  prop `filters`
       * @type Object[]
       */
      filtersInt: [],
      /**
       * variable to steer filter mobile display fade outs
       * also if element is scrollable is determined from this variable (see computed
       * prop filterListScrollable)
       * @type {Object}
       * @property {boolean} filterFade.left - left fade out
       * @property {boolean} filterFade.right - right fade out
       */
      filterFade: {
        left: !1,
        right: !0
      },
      /**
       * store the element scroll and mouse cursor position, needed for drag scrolling
       * @type {Object}
       * @property {number} top - element scrollTop value
       * @property {number} left - element scrollLeft value
       * @property {number} x - cursor x position
       * @property {number} y - cursor y position
       */
      pos: { top: 0, left: 0, x: 0, y: 0 },
      /**
       * store the scroll drag element
       * @type {?HTMLElement}
       */
      scrollContainer: null,
      /**
       * set cursor styling according to current scroll state
       * use variable instead of setting css class directly so child component
       *  BaseCollapsedFilter item can also be steered easily
       */
      isScrolling: !1,
      /**
       * Resize Observer to trigger fade out calculations
       * @type {?ResizeObserver}
       */
      resizeObserver: null,
      /**
       * assistive text set when a chip was removed to be read
       * by screenreader
       * @type {string}
       */
      chipRemovedAssistiveText: ""
    };
  },
  computed: {
    /**
     * determine from fade out calculations if element is scrollable
     * @returns {boolean}
     */
    filterListScrollable() {
      return this.filterFade.right || this.filterFade.left;
    }
  },
  watch: {
    /**
     * keep filters in sync with parent component and vice versa
     */
    filters: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.filtersInt) && (this.filtersInt = JSON.parse(JSON.stringify(t)));
      },
      immediate: !0
    },
    /**
     * keep filters in sync with parent component and vice versa
     */
    filtersInt: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.filters) && this.$emit("update:filters", [...t]), this.$nextTick(() => this.calcFadeOut());
      },
      deep: !0
    }
  },
  mounted() {
    this.$refs.filterList && (this.scrollContainer = this.$refs.filterList), this.initResizeObserver();
  },
  beforeDestroy() {
    this.resizeObserver && this.resizeObserver.unobserve(this.$refs.filterList);
  },
  methods: {
    /**
     * if 'remove all' icon was triggered just emit event to parent to take care of this
     */
    removeFilters() {
      this.$emit("remove-all");
    },
    /**
     * function to remove one specific value from a filter in the filters list
     * @param {number} filterIndex - the index of the filter
     * @param {number} valueIndex - the index of the specific value
     * @param {number?} groupIndex - in case filter is from form group, this is the index of the field
     *  within the group
     */
    removeChip(t, e, s) {
      const { fieldType: l, values: a } = this.filtersInt[t].filter_values, n = this.filtersInt[t].labelInternal, r = l === "group" ? a[e].values[s].labelInternal : a[e].labelInternal;
      if (l === "group") {
        const i = a.reduce((o, { values: c }) => o.concat(c.filter((d) => f(d))), []);
        i.length < 2 && this.filtersInt.length < 2 ? this.removeFilters() : i.length > 1 ? a[e].fieldType.includes("date") || a[e].fieldType.includes("time") ? this.filtersInt[t].filter_values.values[e].values[s].labelInternal = "" : this.filtersInt[t].filter_values.values[e].values.splice(s, 1) : this.filtersInt.splice(t, 1);
      } else
        this.filtersInt.length === 1 && a.length === 1 ? this.removeFilters() : a.length === 1 ? this.filtersInt.splice(t, 1) : l.includes("date") || l.includes("time") ? a.filter((i) => f(i)).length < 2 ? this.filtersInt.splice(t, 1) : this.filtersInt[t].filter_values.values[e].labelInternal = "" : this.filtersInt[t].filter_values.values.splice(e, 1);
      this.chipRemovedAssistiveText = this.assistiveText.filterRemovedNotification.replace("{label}", n).replace("{value}", r), setTimeout(() => {
        this.chipRemovedAssistiveText = "";
      }, 300);
    },
    /** SCROLL RELATED FUNCTIONALITIES */
    /**
     * set up resize observer for filterList to be able to adjust filter fade out
     * and scroll functionality
     */
    initResizeObserver() {
      const t = new ResizeObserver(this.calcFadeOut);
      t.observe(this.$refs.filterList), this.resizeObserver = t;
    },
    /**
     * function triggered by mouse down on filter list, triggering scroll functionality
     * @param {MouseEvent} event - the mouse down event
     */
    mouseDownHandler(t) {
      var e, s;
      this.filterListScrollable && (this.pos = {
        // The current scroll
        left: this.scrollContainer.scrollLeft,
        top: this.scrollContainer.scrollTop,
        // Get the current mouse position
        x: t.clientX ?? (t.touches ? (e = t.touches[0]) == null ? void 0 : e.clientX : 0),
        y: t.clientY ?? (t.touches ? (s = t.touches[0]) == null ? void 0 : s.clientY : 0)
      }, t.type === "touchstart" ? (document.addEventListener("touchmove", this.mouseMoveHandler), document.addEventListener("touchend", this.mouseUpHandler)) : (document.addEventListener("mousemove", this.mouseMoveHandler), document.addEventListener("mouseup", this.mouseUpHandler)), this.isScrolling = !0);
    },
    /**
     * function triggered by document mouse move after event listeners were added
     * in mouse down filter list element event
     * @param {MouseEvent} e
     */
    mouseMoveHandler(t) {
      var n, r;
      const e = t.clientX ?? (t.touches ? (n = t.touches[0]) == null ? void 0 : n.clientX : 0), s = t.clientY ?? (t.touches ? (r = t.touches[0]) == null ? void 0 : r.clientY : 0), l = e - this.pos.x, a = s - this.pos.y;
      this.scrollContainer.scrollTop = this.pos.top - a, this.scrollContainer.scrollLeft = this.pos.left - l, this.calcFadeOut();
    },
    /**
     * function triggered by document mouse up after event listeners were added
     * in mouse down filter list element event
     */
    mouseUpHandler() {
      document.removeEventListener("mousemove", this.mouseMoveHandler), document.removeEventListener("mouseup", this.mouseUpHandler), document.removeEventListener("touchmove", this.mouseMoveHandler), document.removeEventListener("touchend", this.mouseUpHandler), this.isScrolling = !1;
    },
    /**
     * function to calculate if filterList fade out should be shown on element left and/or right border
     */
    calcFadeOut() {
      const t = Math.floor(this.scrollContainer.scrollLeft), e = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;
      this.filterFade = {
        // show fade out left as soon as scroll position is different from 0
        left: t !== 0,
        // show fade out right as soon as scroll position is different from maximum position
        // but only if element exceeds available space
        right: e !== 0 && t !== e
      };
    },
    /** OTHER METHODS */
    /**
     * determine if the provided filter values array has any label data in it
     * (could be kept in the filter values list even if empty in order to be able
     * to map again to the original formFieldValues)
     * @param {Object[]} filterValues
     * @returns {boolean}
     */
    filterValuesHaveData(t) {
      return f(t);
    },
    getRangeIndicator(t, e) {
      if (t.values.length === 2 && ["date", "time"].includes(t.fieldType)) {
        if (t.values[0].labelInternal && t.values[1].labelInternal && e === 1)
          return this.dateTimeText.range;
        if (!t.values[1].labelInternal && t.values[0].labelInternal)
          return this.dateTimeText.from;
        if (!t.values[0].labelInternal && t.values[1].labelInternal)
          return this.dateTimeText.until;
      }
      return "";
    },
    /**
     * we need to check if `interpretLabelAsHtml` was set true for a subform field when
     *  the prop was provided as [{ [parentField]: ['subfield1'] }]
     * @param {string} filterId - the filter id as provided to this component (in the form
     *  [fieldname]-group-[index])
     * @param {string} valueId - the property name of the actual subformfield
     * @returns {boolean}
     */
    calcSubFormChipHtmlRender(t, e) {
      const s = t.split("-").slice(0, 1).join("-"), l = this.interpretLabelAsHtml.find((a) => typeof a == "object" && Object.keys(a).includes(s));
      return !!l && l[s].includes(e);
    }
  }
};
var h = function() {
  var e = this, s = e._self._c;
  return s("div", { staticClass: "base-collapsed-filter-row" }, [s("div", { ref: "filterListContainer", class: [
    "base-collapsed-filter-row__filter-list-container",
    {
      "base-collapsed-filter-row__filter-list-container__fade-right": e.filterFade.right
    },
    {
      "base-collapsed-filter-row__filter-list-container__fade-left": e.filterFade.left
    }
  ] }, [s("ul", { ref: "filterList", class: [
    "base-collapsed-filter-row__filter-list",
    { "base-collapsed-filter-row__filter-list__scrollable": e.filterListScrollable },
    { "base-collapsed-filter-row__filter-list__scrolling": e.isScrolling }
  ], attrs: { "aria-description": e.assistiveText.appliedFiltersLabel }, on: { mousedown: e.mouseDownHandler, touchstart: e.mouseDownHandler } }, e._l(e.filtersInt, function(l, a) {
    var n;
    return s("li", { key: l.idInternal, class: [
      "base-collapsed-filter-row__filter",
      { "base-collapsed-filter-row__filter__boolean": l.filter_values.fieldType === "boolean" }
    ], attrs: { "aria-describedby": `${l.idInternal}-label`, role: "listitem", tabindex: "0" } }, [l.filter_values && e.filterValuesHaveData(l.filter_values.values) ? [s("div", { staticClass: "base-collapsed-filter-row__filter-label", attrs: { id: `${l.idInternal}-label` } }, [e._v(" " + e._s(l.labelInternal) + " ")]), s("ul", { staticClass: "base-collapsed-filter-row__chips-list" }, [e._l((n = l.filter_values) == null ? void 0 : n.values, function(r, i) {
      return [l.filter_values.fieldType === "group" ? [e._l(r.values, function(o, c) {
        return [o.labelInternal ? s("BaseCollapsedFilterItem", { key: o.idInternal || `${o.labelInternal}-${i}-${c}`, attrs: { value: o, type: r.fieldType, "range-indicator": e.getRangeIndicator(r, c), scrollable: e.filterListScrollable, "is-scrolling": e.isScrolling, "date-time-text": e.dateTimeText, "interpret-label-as-html": typeof e.interpretLabelAsHtml == "boolean" && e.interpretLabelAsHtml || typeof e.interpretLabelAsHtml == "object" && e.calcSubFormChipHtmlRender(l.idInternal, r.fieldId), "assistive-text": {
          booleanFilterLabel: e.assistiveText.booleanFilterLabel ? e.assistiveText.booleanFilterLabel.replace("{label}", l.labelInternal) : o.labelInternal.toString(),
          optionToRemoveSelected: e.assistiveText.optionToRemoveSelected
        } }, on: { "remove-chip": function(d) {
          return e.removeChip(a, i, c);
        } } }) : e._e()];
      })] : [r.labelInternal ? s("BaseCollapsedFilterItem", { key: r.idInternal || `${r.labelInternal}-${i}`, attrs: { value: r, type: l.filter_values.fieldType, "range-indicator": e.getRangeIndicator(l.filter_values, i), scrollable: e.filterListScrollable, "is-scrolling": e.isScrolling, "date-time-text": e.dateTimeText, "interpret-label-as-html": typeof e.interpretLabelAsHtml == "boolean" && e.interpretLabelAsHtml || typeof e.interpretLabelAsHtml == "object" && e.interpretLabelAsHtml.includes(l.idInternal), "assistive-text": {
        booleanFilterLabel: e.assistiveText.booleanFilterLabel ? e.assistiveText.booleanFilterLabel.replace("{label}", l.labelInternal) : r.labelInternal.toString(),
        optionToRemoveSelected: e.assistiveText.optionToRemoveSelected
      } }, on: { "remove-chip": function(o) {
        return e.removeChip(a, i);
      } } }) : e._e()]];
    })], 2)] : e._e()], 2);
  }), 0)]), e.chipRemovedAssistiveText ? s("span", { staticClass: "assistive-text", attrs: { "aria-live": "assertive" } }, [e._v(" " + e._s(e.chipRemovedAssistiveText) + " ")]) : e._e(), s("button", { staticClass: "base-collapsed-filter-row__remove", attrs: { title: e.assistiveText.removeFiltersLabel }, on: { click: e.removeFilters } }, [s("BaseIcon", { staticClass: "base-collapsed-filter-row__remove-icon", attrs: { name: "remove" } })], 1)]);
}, v = [], _ = /* @__PURE__ */ u(
  b,
  h,
  v,
  !1,
  null,
  "23cce083",
  null,
  null
);
const I = _.exports;
export {
  I as default
};
//# sourceMappingURL=BaseCollapsedFilterRow.vue.es.js.map
