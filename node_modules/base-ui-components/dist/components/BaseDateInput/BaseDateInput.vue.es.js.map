{"version":3,"file":"BaseDateInput.vue.es.js","sources":["../../../src/components/BaseDateInput/BaseDateInput.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"baseDateInput\"\n    class=\"base-date-input\">\n    <div\n      v-if=\"showLabelRow\"\n      :class=\"['base-date-input__label-row',\n               { 'base-date-input__label-row--visible': showLabel }]\">\n      <legend\n        v-if=\"showLabel\"\n        ref=\"label\"\n        class=\"base-date-input__label\"\n        @click.prevent=\"\">\n        {{ label }}\n      </legend>\n      <div\n        :class=\"['base-date-input__label-additions',\n                 {'base-date-input__label-additions--switch-height': isSwitchableFormat },\n                 {'base-date-input__label-additions--wrap': wrapLabelRow }]\">\n        <div\n          ref=\"labelAdditions\"\n          :class=\"['base-date-input__label-additions-inner',\n                   {'base-date-input__label-additions-inner--switch': isSwitchableFormat },\n                   {'base-date-input__label-additions-inner--no-label-switch': isSwitchableFormat\n                     && !showLabel }]\">\n          <!-- @slot to add additional elements to the label row -->\n          <slot name=\"label-addition\" />\n          <BaseSwitchButton\n            v-if=\"isSwitchableFormat\"\n            v-model=\"dateFormatInt\"\n            :options=\"tabSwitchOptions\"\n            :label=\"formatTabsLegend\"\n            :active-tab=\"dateFormatInt\"\n            class=\"base-date-input__switch-buttons\" />\n        </div>\n      </div>\n    </div>\n\n    <!-- FORM FIELDS -->\n    <!-- keydown event is counter productive to workflow here -->\n    <!-- eslint-disable-next-line vuejs-accessibility/click-events-have-key-events -->\n    <div\n      v-click-outside=\"clickedOutside\"\n      class=\"base-date-input__field-wrapper\"\n      @click=\"clickedInside\">\n      <!-- @slot to add elements within form field but before the input element line for an example see [BaseInput](BaseInput)-->\n      <slot name=\"pre-input-field\" />\n      <div class=\"base-date-input__input-fields\">\n        <!-- @slot add elements within input form field but before all other elements - this field wraps if necessary for an example see [BaseInput](BaseInput) -->\n        <slot name=\"input-field-addition-before\" />\n        <div class=\"base-date-input__input-line\">\n          <!-- @slot add elements directly in the input line (no wrapping) for an example see [BaseInput](BaseInput)-->\n          <slot name=\"input-field-inline-before\" />\n          <!-- INPUT FROM -->\n          <BaseInput\n            :id=\"`input-${internalId}-from`\"\n            v-model=\"inputFrom\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"fromOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :input-class=\"inputClass\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutFrom\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('from', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputFrom\"\n                  :placeholder=\"isFromTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"fromOpen\"\n                  :type=\"isFromTimeField ? 'time' : minDateView\"\n                  :format=\"isFromTimeField ? 'HH:mm' : datePickerValueFormat\"\n                  :value-type=\"isFromTimeField ? 'format' : datePickerValueFormat\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('from')\"\n                  @click.native.prevent=\"onInputClick\"\n                  @change=\"isFromTimeField ? closeTimePicker('from', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                    component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"`input-${internalId}-from`\"\n                      ref=\"inputFrom\"\n                      :value=\"inputFrom\"\n                      :placeholder=\"isFromTimeField ? placeholder.time ?? placeholder\n                        : placeholder.date ?? placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-' + internalId\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      enterkeyhint=\"done\"\n                      autocomplete=\"off\"\n                      @input=\"checkDate($event, 'From')\"\n                      @keydown=\"handleInputKeydown($event, 'From')\"\n                      @blur=\"onInputBlur($event, 'from')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of datepicker\n                  is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                ref=\"baseIcon\"\n                :name=\"isFromTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"fromOpen = !fromOpen\" />\n            </template>\n          </BaseInput>\n\n          <span\n            v-if=\"type === 'daterange' || type === 'timerange'\"\n            class=\"base-date-input__separator\">{{ rangeSeparator }}</span>\n\n          <!-- INPUT TO -->\n          <BaseInput\n            v-if=\"type !== 'single'\"\n            :id=\"`input-${internalId}-to`\"\n            v-model=\"inputTo\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"toOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutTo\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('to', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputTo\"\n                  :placeholder=\"isToTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"toOpen\"\n                  :type=\"isToTimeField ? 'time' : minDateView\"\n                  :format=\"isToTimeField ? 'HH:mm' : datePickerValueFormat\"\n                  :value-type=\"isToTimeField ? 'format' : datePickerValueFormat\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('to')\"\n                  @click.native.prevent=\"onInputClick\"\n                  @change=\"isToTimeField ? closeTimePicker('to', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                      component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"`input-${internalId}-to`\"\n                      ref=\"inputTo\"\n                      :value=\"inputTo\"\n                      :placeholder=\"isToTimeField ? placeholder.time ?? placeholder\n                        : placeholder.date ?? placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-to-' + internalId\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      enterkeyhint=\"done\"\n                      autocomplete=\"off\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      @input=\"checkDate($event, 'To')\"\n                      @keydown=\"handleInputKeydown($event, 'To')\"\n                      @blur=\"onInputBlur($event, 'to')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of\n                  datepicker is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                :name=\"isToTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"toOpen = !toOpen\" />\n            </template>\n          </BaseInput>\n        </div>\n      </div>\n      <!-- @slot for adding elements after input -->\n      <slot name=\"post-input-field\" />\n    </div>\n\n    <div class=\"base-date-input__below\">\n      <!-- @slot to add elements below input fields e.g. add drop down -->\n      <slot name=\"below-input\" />\n    </div>\n  </div>\n</template>\n\n<script>\nimport ClickOutside from 'vue-click-outside';\nimport DatePicker from 'vue2-datepicker';\nimport { capitalizeString, createId, debounce } from '@/utils/utils';\n\nimport en from 'vue2-datepicker/locale/en';\nimport de from 'vue2-datepicker/locale/de';\nimport fr from 'vue2-datepicker/locale/fr';\n\nimport BaseInput from '@/components/BaseInput/BaseInput';\nimport BaseIcon from '@/components/BaseIcon/BaseIcon';\n\n/**\n * Form Input Field Component for Date, Date - Date, Date - Time, or Time - Time\n *\n * for date also a format switch between date | year is available\n *\n */\n\nexport default {\n  name: 'BaseDateInput',\n  components: {\n    BaseInput,\n    BaseIcon,\n    BaseSwitchButton: () => import('@/components/BaseSwitchButton/BaseSwitchButton').then(m => m.default || m),\n    DatePicker,\n  },\n  directives: {\n    ClickOutside,\n  },\n  model: {\n    prop: 'input',\n    event: 'selected',\n  },\n  props: {\n  /**\n   * select date or datetime or a range\n   */\n    type: {\n      type: String,\n      default: 'single',\n      validator(val) {\n        return ['daterange', 'datetime', 'single', 'timerange'].includes(val);\n      },\n    },\n    /**\n     * input field settable from outside.\n     *   attention: if this is an object it needs to contain all the\n     *   properties (e.g. date_from, time_to) already otherwise only\n     *   a string will be returned\n     */\n    input: {\n      type: [Object, String, Date],\n      required: true,\n    },\n    /** label for input field, required for usability purposes, handle\n     * showing of label with property showLabel\n     */\n    label: {\n      type: String,\n      required: true,\n    },\n    /**\n     * defines if input label should be visible\n     */\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * set a placeholder for the input field (object with date and time attribute respectively)\n     */\n    placeholder: {\n      type: [Object, String],\n      default: () => ({ date: 'Select Date', time: 'Select Time' }),\n    },\n    /**\n     * define the range separator\n     */\n    rangeSeparator: {\n      type: String,\n      default: '–',\n    },\n    /**\n     * specify date format.\n     *\n     *  **date_year**: display tabs that allow for toggle between only choosing year\n     *   or complete date\n     *  **date_month_year**: display tabs that allow for toggle between choosing only year,\n     *   year and month or complete date\n     */\n    format: {\n      type: String,\n      default: 'day',\n      validator(val) {\n        return ['day', 'month', 'year', 'date_year', 'date_month_year'].includes(val);\n      },\n    },\n    /**\n     * specify labels displayed instead of 'DD.MM.YYYY' and 'YYYY'\n     *   should have the form `{ date: 'xxx', month: 'zzz', year: 'yyy' }`\n     */\n    dateFormatLabels: {\n      type: Object,\n      default: () => ({ date: 'DD.MM.YYYY', month: 'MM.YYYY', year: 'YYYY' }),\n      validator(val) {\n        const labelKeys = Object.keys(val);\n        return labelKeys.includes('date') && labelKeys.includes('year');\n      },\n    },\n    /**\n     * a legend for the date format switch buttons\n     */\n    formatTabsLegend: {\n      type: String,\n      default: 'Switch between date formats',\n    },\n    /**\n     * set calendar language (ISO 639-1).\n     * **caveat**: currently only `en`, `de` and `fr` are supported\n     *  @values de, en, fr\n     */\n    language: {\n      type: String,\n      default: 'en',\n      validator: val => ['de', 'en', 'fr'].includes(val),\n    },\n    /**\n     * set id\n     */\n    id: {\n      type: [Number, String],\n      default: '',\n    },\n    /**\n     * define if standard form field styling should be\n     * used (otherwise no border, no box shadow)\n     */\n    useFormFieldStyling: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * option to have the border of the input field not displayed\n     */\n    showInputBorder: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * mark as required field (currently only used for aria-required)\n     */\n    required: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * mark the form field as invalid and ideally also provide an error message\n     * to display below the form field\n     * for an example see [BaseInput](BaseInput)\n     */\n    invalid: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set `true` if input field should be disabled\n     * for an example see [BaseInput](BaseInput)\n     */\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * add an error message to be displayed below form field if field is invalid\n     * for an example see [BaseInput](BaseInput)\n     */\n    errorMessage: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define if error icon should be shown\n     * for an example see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once\n     * for an example see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * specify additional input field styling\n     */\n    inputClass: {\n      type: String,\n      default: '',\n    },\n    /**\n     * use this prop to deactivate automatic setting of focus as soon as input element\n     * becomes active - this might require external handling of focus setting!\n     */\n    setFocusOnActive: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * in order to be able to set input field active state from outside\n     */\n    isActive: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * use this prop to set a delay in ms before calender is displayed\n     */\n    isActiveDelay: {\n      type: Number,\n      default: 0,\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal input representation with all possible values for\n       * date and time\n       * @typedef {Object} inputInt\n       * @property {string} inputInt.date - attribute a single date or datetime date is stored in\n       * @property {string} inputInt.date_from - storing daterange from\n       * @property {string} inputInt.date_to - storing daterange to\n       * @property {string} inputInt.time - storing the time for datetime type\n       * @property {string} inputInt.time_from - storing timerange from\n       * @property {string} inputInt.time_to - storing timerange to\n       */\n      inputInt: {\n        date: '',\n        date_from: '',\n        date_to: '',\n        time: '',\n        time_from: '',\n        time_to: '',\n      },\n      /**\n       * variable for toggling format between date and year for date_year format\n       * @type {string}\n       */\n      dateFormatInt: '',\n      /**\n       * variable to store the date when switching from date to year in order to be\n       * able to restore exact date when switching back\n       * @type {inputInt}\n       */\n      tempDateStore: {},\n      /**\n       * to steer closing of datepicker from input field once date is selected\n       * @type {boolean}\n       */\n      fromOpen: false,\n      /**\n       * to steer closing of datepicker to input field once date is selected\n       * @type {boolean}\n       */\n      toOpen: false,\n      /**\n       * variable to keep active state in sync with potential parent prop\n       * (this is needed as independent variable from toOpen and fromOpen for example in\n       * BaseAdvancedSearchRow to keep dropdown open even if datepicker is closed)\n       */\n      isActiveInt: false,\n      /**\n       * variable to steer if input fade out of from field should be shown\n       * @type {boolean}\n       */\n      useFadeOutFrom: false,\n      /**\n       * variable to steer if input fade out of to field should be shown\n       * @type {boolean}\n       */\n      useFadeOutTo: false,\n      /**\n       * variable to steer if icons should be shown (becoming false if not enough\n       * space)\n       * @type {boolean}\n       */\n      showIcons: true,\n      /**\n       * variable to store icon size which is calculated in the beginning and might be\n       * hidden later\n       * @type {number}\n       */\n      iconSize: 24,\n      /**\n       * Resize Observer to trigger fade out calculations when component is resized\n       * @type {?ResizeObserver}\n       */\n      resizeObserver: null,\n      /**\n       * function needs to be triggered when date switch is populated\n       * @type {?ResizeObserver}\n       */\n      labelAdditionsObserver: null,\n      /**\n       * datepicker localisations\n       *   using object fixes problem of missing localisation files in rollup-esm-build\n       */\n      lang: {\n        de,\n        en,\n        fr,\n      },\n      /**\n       * variable to set css class according to label elements wrapping or not\n       * @type {boolean}\n       */\n      wrapLabelRow: false,\n    };\n  },\n  computed: {\n    internalId() {\n      return this.id || createId();\n    },\n    /**\n     * this is the format we want to store computed based on what\n     * was specified in format and what date toggle tabs (via dateFormatInt) might say\n     * TODO: check if this is still needed with custom input\n     * @returns {string}\n     */\n    datePickerValueFormat() {\n      if (this.format === 'year' || this.dateFormatInt === 'YYYY') {\n        // use single letter for year here to allow negative dates\n        return 'Y';\n      }\n      if (this.format === 'month' || this.dateFormatInt === 'MM.YYYY') {\n        // use single letter for year here to allow negative dates\n        return 'MM.Y';\n      }\n      // use single letter for year here to allow negative dates\n      return 'DD.MM.Y';\n    },\n    /**\n     * if the format is settable this.format is date_year and can not be\n     * used directly for the date picker component\n     * @returns {string}\n     */\n    minDateView() {\n      if (this.isSwitchableFormat && this.dateFormatInt === 'YYYY') {\n        return 'year';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'MM.YYYY') {\n        return 'month';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'DD.MM.YYYY') {\n        return 'day';\n      }\n      return this.format;\n    },\n    /**\n     * compute the properties of the object provided in input prop\n     * @returns {string[]}\n     */\n    inputProperties() {\n      // if input is object return those keys // else for a single date it\n      // could also be a string - then just return an empty array\n      return typeof this.input === 'object' ? Object.keys(this.input) : [];\n    },\n    /**\n     * check if input is just a single date or an object\n     * @returns {boolean}\n     */\n    isInputTypeString() {\n      return typeof this.input === 'string' || !this.inputProperties.length;\n    },\n    /**\n     * handle input for the 'from' input field\n     */\n    inputFrom: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string} - a date in the format DD.MM.YYYY\n       */\n      get() {\n        // if it is a time field just return the time_from value\n        if (this.isFromTimeField) {\n          return this.inputInt.time_from;\n        }\n        // else it is a date (either single or date_from) --> convert it into the\n        // correct format for display (DD.MM.YYYY instead of the saved DD-MM-YYY)\n        return this.parseToDateDisplay(this.inputInt.date || this.inputInt.date_from);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       * @param {string} oldValue - the previous value of inputFrom\n       */\n      set(val, oldValue) {\n        let newDate = val;\n        if (this.isFromTimeField) {\n          this.inputInt.time_from = newDate;\n        } else {\n          newDate = this.parseToDateStorage(val);\n          if (this.inputProperties.includes('date_from')) {\n            this.inputInt.date_from = newDate;\n          } else {\n            this.inputInt.date = newDate;\n          }\n        }\n        // watching of computed values does not work so emit event for altered inputInt right here\n        // the actual value is not needed here since data were transformed and\n        // original object structure with correct data is retrieved with function getInputData\n        if (newDate !== oldValue) {\n          this.emitData();\n        }\n      },\n    },\n    /**\n     * as above - if there is only a single time field get value from 'time' variable\n     * if it is a range use 'time_to''\n     */\n    inputTo: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string}\n       */\n      get() {\n        // check if a to time field exists\n        if (this.isToTimeField) {\n          // return the appropriate attribute value\n          return this.inputInt.time || this.inputInt.time_to;\n        }\n        // else return the date_to attribute value\n        return this.parseToDateDisplay(this.inputInt.date_to);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       * @param {string} oldValue - the previous value of inputTo\n       */\n      set(val, oldValue) {\n        let newValue = val;\n        // check if field is date field\n        if (!this.isToTimeField) {\n          newValue = this.parseToDateStorage(newValue);\n          // if so, set date_to attribute value and transform value appropriately\n          // TODO: this could be insufficient since currently no validity checks on input string\n          this.inputInt.date_to = newValue;\n          // else check if type is timerange\n        } else if (this.inputProperties.includes('time_from')) {\n          this.inputInt.time_to = newValue;\n          // else assume the type is datetime\n        } else {\n          this.inputInt.time = newValue;\n        }\n        // watching of computed values does not work so emit event for altered inputInt right here\n        // the actual value is not needed here since data were transformed and\n        // original object structure with correct data is retrieved with function getInputData\n        if (newValue !== oldValue) {\n          this.emitData();\n        }\n      },\n    },\n    /**\n     * determine if the initially provided date is a year or a full date\n     * (used to set the correct date display format and date/year switch button)\n     * @returns {boolean}\n     */\n    isDateFormatYear() {\n      return (this.isInputTypeString && this.inputInt.date\n          && /^(-?[0-9]{1,4}|-[0-9]{0,4})$/.test(this.inputInt.date))\n        || (this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key] && /^(-?[0-9]{1,4}|-[0-9]{0,4})$/.test(this.inputInt[key])));\n    },\n    isDateFormatMonth() {\n      return ((this.isInputTypeString && this.inputInt.date\n          && /^(-?[0-9]{1,4}|-[0-9]{0,4})-[0-1]?[0-9]$/.test(this.inputInt.date))\n        || this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key]\n          && /^(-?[0-9]{1,4}|-[0-9]{0,4})-[0-1]?[0-9]$/.test(this.inputInt[key])));\n    },\n    /**\n     * check if format switch tabs should be shown\n     * @returns {boolean}\n     */\n    isSwitchableFormat() {\n      return this.format === 'date_month_year' || this.format === 'date_year';\n    },\n    /**\n     * return the format options for date, month, year switches\n     * @returns {[{label: string, value: string}]}\n     */\n    tabSwitchOptions() {\n      // minimal options\n      const options = [\n        { label: this.dateFormatLabels.date, value: 'DD.MM.YYYY' },\n        { label: this.dateFormatLabels.year, value: 'YYYY' },\n      ];\n      // if format can be month as well, add month option\n      if (this.format === 'date_month_year') {\n        options.splice(1, 0, {\n          label: this.dateFormatLabels.month,\n          value: 'MM.YYYY',\n        });\n      }\n      return options;\n    },\n    /**\n     * determine if the from field is a time field\n     * @returns {boolean}\n     */\n    isFromTimeField() {\n      return this.type === 'timerange';\n    },\n    /**\n     * determine if the to field is a time field\n     * @returns {boolean}\n     */\n    isToTimeField() {\n      return this.type === 'datetime' || this.type === 'timerange';\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    inputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // and add custom listeners\n        ...{\n          // stop these BaseInput originating events to substitute them with the\n          // correct events in search container element\n          'clicked-outside': (event) => {\n            event.stopPropagation();\n          },\n          // need to stop the event triggered in original BaseInput and only trigger\n          // when component isActiveInt has changed\n          'update:is-active': () => {},\n          // stop BaseInput input event since BaseDateInput will propagate their own\n          input: () => {},\n        },\n      };\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    dateInputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // stop native input event here and emit own event (in inputInt watcher)\n        // with just the values\n        input: () => {},\n      };\n    },\n    /**\n     * check if label-addition slot exists is filled\n     */\n    labelRowSlotsHaveData() {\n      // get label-addition slot\n      const slotElements = this.$slots['label-addition'];\n      // check if slot exists and has data and actually has content\n      // (this did not work with SSR otherwise...)\n      return !!slotElements && !!slotElements.length\n        && slotElements.some(elem => elem.tag || elem.text?.trim());\n    },\n    /**\n     * determines if label row should be shown\n     * @returns {Boolean|boolean}\n     */\n    showLabelRow() {\n      // show label when prop is set true or a label addition was added via slot\n      return this.showLabel || this.isSwitchableFormat || this.labelRowSlotsHaveData;\n    },\n  },\n  watch: {\n    inputInt: {\n      handler() {\n        /**\n         * Event emitted on input, passing input string\n         *\n         * @event input\n         * @param {string} - the input event value however\n         * passing only the event.target.value\n         *\n         */\n        this.$emit('input', this.getInputData());\n      },\n      deep: true,\n    },\n    /**\n     * watch format and set correct dateFormat\n     */\n    format: {\n      handler(val) {\n        if (val === 'year') {\n          this.dateFormatInt = 'YYYY';\n          return;\n        }\n        if (val === 'month') {\n          this.dateFormatInt = 'MM.YYYY';\n          return;\n        }\n        this.dateFormatInt = 'DD.MM.YYYY';\n      },\n      immediate: true,\n    },\n    /**\n     * watch input set from outside and set internal inputInt accordingly as well as\n     * set the correct display format\n     */\n    input: {\n      handler(val) {\n        // check if input string is different from inputInt\n        if (JSON.stringify(val) !== JSON.stringify(this.getInputData())) {\n          const isDateTimeField = this.type === 'datetime';\n          this.inputFrom = isDateTimeField\n            ? val.date : val.date ?? val.date_from ?? val.time ?? val.time_from ?? val ?? '';\n          this.inputTo = isDateTimeField ? val.time : val.date_to ?? val.time_to ?? '';\n          // check if external input was year format and set internal format accordingly\n          if (this.isSwitchableFormat) {\n            if (this.isDateFormatYear) {\n              this.dateFormatInt = 'YYYY';\n            } else if (this.isDateFormatMonth) {\n              this.dateFormatInt = 'MM.YYYY';\n            } else {\n              this.dateFormatInt = 'DD.MM.YYYY';\n            }\n          }\n        }\n      },\n      // to not need to do extra assignment in created()\n      immediate: true,\n    },\n    /**\n     * in order to allow user to restore previous date after switching\n     * from date to year and back store in temp variable (but only if previous date was full date\n     * (check necessary for starting with year where format is switched to 'YYYY'\n     * but no previous full date avaliable))\n     * @param {string} val - the changed dateFormatInt value\n     * @param {string} old - the previous value\n     */\n    dateFormatInt(val, old) {\n      // in order to allow user to restore previous date after switching\n      // from date to year and back store in temp variable if\n      // a) date is not just format 'YYYY' & switch was made from full date\n      if (!this.isDateFormatYear && old === 'DD.MM.YYYY') {\n        this.tempDateStore = { ...this.inputInt };\n        // b) tab switch was made from month to year\n      } else if (!this.isDateFormatYear\n        && (val === 'YYYY' && old === 'MM.YYYY')) {\n        // if there is no previous stored date just store everything\n        if (!this.tempDateStore) {\n          this.tempDateStore = { ...this.inputInt };\n          // if there was a previous stored date check for every date prop in inputInt\n          // if stored date should be overwritten\n        } else {\n          Object.keys(this.inputInt).filter(key => !!key.includes('date'))\n            .forEach((dateKey) => {\n              // date should be overwritten if month or year are different from\n              // the already stored date\n              if (!this.monthAndYearIdent(\n                // check if the positive dates are identical\n                this.removeYearMinusFromStorageDate(this.inputInt[dateKey], old),\n                (/^-/.test(this.tempDateStore[dateKey]) ? this.tempDateStore[dateKey].replace('-', '') : this.tempDateStore[dateKey]),\n                // and also check if the operator in front of year is identical\n              ) && this.isNegativeStorageDate(this.inputInt[dateKey], old)\n                === /^-/.test(this.tempDateStore[dateKey])) {\n                this.$set(this.tempDateStore, dateKey, this.inputInt[dateKey]);\n              }\n            });\n        }\n      }\n      this.convertDate(old);\n      // since inputInt is manipulated directly in this case (easier with Date conversions)\n      // inputFrom and inputTo setters are not triggered and we need to emit the new data manually\n      this.emitData();\n    },\n    /**\n     * watch for changes in input field active variable to keep in sync with parent\n     * @param {boolean} val - the changed internal is active variable\n     */\n    isActiveInt(val) {\n      /**\n       * replace BaseInput state with BaseDateInput field active state and\n       * propagate this one\n       *\n       * @event update:is-active\n       * @param {boolean} - is input field active\n       */\n      this.$emit('update:is-active', val);\n    },\n    /**\n     * also adjust internal variable when active state changes from outside\n     * @param {boolean} val - the changed isActive prop\n     */\n    isActive: {\n      handler(val) {\n        if (val !== this.isActiveInt) {\n          this.isActiveInt = val;\n          // if is active is set from outside also open the first date field\n          this.fromOpen = val;\n        }\n        // if isActive is set false from outside also close date picker\n        if (!val) {\n          this.fromOpen = false;\n          this.toOpen = false;\n        }\n      },\n      immediate: true,\n    },\n  },\n  mounted() {\n    if (this.$refs.baseIcon) {\n      this.iconWidth = this.$refs.baseIcon.$el.clientWidth;\n    }\n    // initialize the resize observer to calculate fade out and label row when component is resized\n    this.initObservers();\n  },\n  updated() {\n    // this hack is necessary because otherwise keyboard navigation was impaired by the datepicker\n    // pop up elements\n    // check if datepicker element is actually open\n    if (this.fromOpen || this.toOpen) {\n      // wait until elements are rendered\n      this.$nextTick(() => {\n        // get all focusable elements that have the 'mx-' in the class name\n        // had to add 'div's as well because of some strange effect in Firefox\n        const keyboardfocusableElements = [...this.$el.querySelectorAll(\n          'div, a, button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])',\n        )]\n          .filter(el => !el.hasAttribute('disabled'))\n          .filter(el => el.className.includes('mx-'));\n        // iterate through the elements and add tabindex -1\n        keyboardfocusableElements.forEach((element) => {\n          element.setAttribute('tabindex', -1);\n        });\n      });\n    }\n  },\n  beforeDestroy() {\n    if (this.resizeObserver) this.resizeObserver.disconnect();\n    if (this.labelAdditionsObserver) this.labelAdditionsObserver.disconnect();\n  },\n  methods: {\n    /**\n     * since the complete datepicker lies within the BaseInput, the BaseInput click event\n     *  is triggered also when a date is picked from the date picker - this leads to the undesired\n     *  side effect that the date picker pop up is reopened when a date was selected there\n     *  therefore we only allow the click event to pass on when the user clicks on the input field\n     *  DIRECTLY\n     * @param {PointerEvent} event - the native click event\n     */\n    onInputClick(event) {\n      if (event.target.tagName !== 'INPUT') {\n        event.stopPropagation();\n      }\n    },\n    /**\n     * in general input field active styling is handled via focusin and\n     * clicked-outside, however for special case iOS touch  devices have\n     * up and down arrows that do not trigger any event other than blur and will\n     * cause the dropdowns of input fields to remain open\n     * @param {FocusEvent} event - the native blur event\n     * @param {string} origin - did event emit from 'from' or 'to' date field\n     */\n    onInputBlur(event, origin) {\n      const relatedTargetInput = event.relatedTarget?.parentElement ? event.relatedTarget.parentElement\n        .getElementsByTagName('input') : null;\n      // so since these arrows only navigate between input fields we check if there is a\n      // related target and if this related target is an input field and if yes we make sure\n      // the id is different from the input id of this component (the one the event originated from)\n      if (event.relatedTarget\n        && ((event.relatedTarget.tagName === 'INPUT'\n            && (!event.relatedTarget?.id || event.relatedTarget.id !== event.target.id))\n          // additionally also set input active false when the BaseInput 'remove' button\n          // (displayed if `clearable` is true) is triggered in the other date field of the range\n          || (event.relatedTarget?.className === 'base-input__remove-icon-wrapper'\n            && relatedTargetInput && relatedTargetInput[0]?.id !== event.target.id))) {\n        // set input active state false\n        this[`${origin}Open`] = false;\n      }\n    },\n    initObservers() {\n      // create an observer with the fade out calc function\n      const tempResizeObserver = new ResizeObserver(debounce(50, () => {\n        if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n          this.calcLabelAdditionsWidth();\n        }\n        this.calcFadeOut(['From', 'To']);\n      }));\n      // put it on the relevant element\n      tempResizeObserver.observe(this.$refs.baseDateInput);\n      // store it in variable\n      this.resizeObserver = tempResizeObserver;\n\n      if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n        // second observer to trigger label additions width calc as soon as element is rendered\n        const tempLabelAdditionsObserver = new ResizeObserver(debounce(50, (entries, observer) => {\n          // only do calc when element is filled\n          if (entries[0].contentRect.width > 0) {\n            this.calcLabelAdditionsWidth(this.$refs.baseDateInput.clientWidth);\n            // only do this once as soon as elements are rendered - then disconnect!\n            observer.disconnect();\n          }\n        }));\n        tempLabelAdditionsObserver.observe(this.$refs.labelAdditions);\n        this.labelAdditionsObserver = tempLabelAdditionsObserver;\n      }\n    },\n    /**\n     * transform the date to the correct display format\n     * @param {string} dateString - the date string in YYYY-MM-DD format\n     */\n    parseToDateDisplay(dateString) {\n      // if no date string was provided just return an empty string\n      if (!dateString) return '';\n      // now check if year is negative\n      const isNegativeYear = this.isNegativeStorageDate(dateString);\n      // if so, create a positive date string\n      const positiveDateString = isNegativeYear\n        ? this.removeYearMinusFromStorageDate(dateString) : dateString;\n      // now do the transformation and add the minus to the year again if necessary\n      return this.addYearMinusToDateDisplay(\n        positiveDateString.split('-').reverse().join('.'),\n        isNegativeYear,\n      );\n    },\n    /**\n     * transform the date to the correct storage format\n     * @param {string} dateString - the date string in DD.MM.YYYY format\n     */\n    parseToDateStorage(dateString) {\n      return dateString ? dateString.split('.').reverse().join('-') : '';\n    },\n    /**\n     * checks done on keydown events\n     * a) tab key needs separate handling and only needs to set input field close when\n     * there is no clearable button (or shift key was used for going to previous field)\n     * b) prevent user from entering chars other than number or period (date) or colon (time)\n     * and not more characters than the date format requires\n     * @param {KeyboardEvent} event - the keydown event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    handleInputKeydown(event, origin) {\n      let currentInputString = event.target.value;\n      // get the key triggering the event\n      const { key } = event;\n      // now check for the specific input key to preventDefault and prevent unwanted\n      // characters\n      // create boolean to determine if it is a time field (otherwise date is assumed)\n      const isTimeField = this.isTimeInputField(origin);\n      // if time ':' is allowed in input regex - otherwise '.'\n      const allowedFieldKey = isTimeField ? ':' : '\\\\.';\n      // check if '-' should be an allowed key\n      let allowMinus = false;\n      if ((this.dateFormatInt === 'DD.MM.YYYY' && /^\\d{2}\\.\\d{2}\\.\\d{0,4}$/.test(currentInputString))\n        || (this.dateFormatInt === 'MM.YYYY' && /^\\d{2}\\.\\d{0,4}$/.test(currentInputString))\n        || (this.dateFormatInt === 'YYYY' && /^\\d{0,4}$/.test(currentInputString))) {\n        allowMinus = true;\n      }\n      // create regex for allowed keys\n      const allowedKeysRegex = new RegExp(`([0-9${allowMinus ? '-' : ''}]|${allowedFieldKey}|Backspace|Delete|Tab|Enter|ArrowRight|ArrowLeft)`);\n      // create regex that should not be allowed if max length is reached\n      const disallowedKeysOnLengthRegex = new RegExp(`([0-9]|${allowedFieldKey})`);\n      // get the max length for the respective format (for time: 'HH:mm' = 5)\n      // also check for a minus\n      let formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n      if (!isTimeField && this.isNegativeDisplayDate(currentInputString)) {\n        // add one extra to formatLength for the '-' if date is negative\n        formatLength += 1;\n      }\n      // check if\n      // * key was not any of the allowed keys\n      // * or was an allowed key but the length is to long for the format in\n      //    question (and no text was selected = will be replaced)\n      // * if type is date and key was period and date format is year or last char in string was\n      //    already a period\n      // * if type is time and key was colon and last char was already a colon\n      // * and also make sure copy & paste is allowed!\n      if ((!allowedKeysRegex.test(key)\n        || (disallowedKeysOnLengthRegex.test(key) && currentInputString.length >= formatLength\n          && document.activeElement.selectionEnd - document.activeElement.selectionStart === 0)\n        || (!isTimeField && key === '.' && (this.dateFormatInt === 'YYYY'\n          || currentInputString.charAt(currentInputString.length - 1) === '.'))\n        || (isTimeField && key === ':' && currentInputString.charAt(currentInputString.length - 1) === ':'))\n        && !(['c', 'v', 'x'].includes(key) && event.ctrlKey)) {\n        event.preventDefault();\n      }\n      // when the user tries to leave the field check if input string is valid\n      if (key === 'Enter') {\n        this.checkDateValidity(origin);\n        currentInputString = this[`input${origin}`];\n      }\n      // check if key was tab because of reasons specified above and close picker if necessary\n      if (key === 'Enter' || (key === 'Tab' && (event.shiftKey || !this.clearable\n        || !currentInputString))) {\n        // if yes set the relevant input field open status to false\n        this[`${origin.charAt(0).toLowerCase()}${origin.slice(1)}Open`] = false;\n      }\n    },\n    /**\n     * this function is triggered with the input event - it checks the length of the value and\n     * adds the '.' (date) or (':') or '0' in the correct places or removes '-' that was added at\n     * a wrong position if necessary\n     * @param {InputEvent} event - the input event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDate(event, origin) {\n      // get the value in question\n      let modifiedValue = event.target.value;\n      // this is a workaround necessary because of the manual input event triggered in BaseInput\n      // (~line 610) but since input has not changed with this event we can easily filter it out\n      // by only applying the operations if input has changed\n      if (modifiedValue === this[`input${origin}`]) return;\n      // otherwise continue to check the input\n      // determine if input is coming from a time or date field\n      const isTimeField = this.isTimeInputField(origin);\n      // depending on that different characters need to be added\n      const charToAdd = isTimeField ? ':' : '.';\n      // check if value is present and if input type is other than 'deleteContentBackward' because\n      // otherwise the dots can not be deleted anymore\n      if (modifiedValue && event.inputType !== 'deleteContentBackward') {\n        // remove a non-matching '-' character\n        if (modifiedValue !== '-' && !this.isNegativeDisplayDate(modifiedValue)) {\n          modifiedValue = modifiedValue.replace('-', '');\n        }\n        // now check the date format and if input so far matches the appropriate regex\n        if ((!isTimeField && this.dateFormatInt === 'DD.MM.YYYY' && /^(\\d{2}$|\\d{2}\\.\\d{2})$/.test(modifiedValue))\n            || ((this.dateFormatInt === 'MM.YYYY' || isTimeField) && /^\\d{2}$/.test(modifiedValue))) {\n          // if so - add a period character\n          modifiedValue = `${modifiedValue}${charToAdd}`;\n        }\n        const firstTwoDigitsRegex = new RegExp(`^[1-9]${isTimeField ? ':' : '\\\\.'}$`);\n        // check if input was a period - if yes - check date validity and add zeros if necessary\n        if (firstTwoDigitsRegex.test(modifiedValue)) {\n          modifiedValue = `0${modifiedValue}`;\n        } else if (/^\\d{2}\\.\\d\\.$/.test(modifiedValue)) {\n          const [day, month, year] = modifiedValue.split('.');\n          modifiedValue = `${day}.0${month}.${year}`;\n        }\n      }\n      this[`input${origin}`] = modifiedValue;\n    },\n    /**\n     * this function is triggered with the blur event on the input and does a last check on the\n     * validity of the value\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDateValidity(origin) {\n      // important and mostly different checks to make depending if value is date or time\n      // so save that in variable\n      const isTimeField = this.isTimeInputField(origin);\n      // since Date() has problems with negative dates just remove the '-' and add it again after!\n      let positiveDate = this.removeYearMinusFromDisplayDate(this[`input${origin}`]);\n      // check if there is a value present\n      if (positiveDate) {\n        // also save the current format length\n        const formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n        // get the separator depending on time or date field\n        const separator = isTimeField ? ':' : '.';\n        // get the array length of array with string split up by separator (should be same for\n        // format and value string)\n        const numberFormatParts = isTimeField ? 2 : this.dateFormatInt.split('.').length;\n        // first check if periods (date) or colons (time) are too many\n        if (positiveDate.split(separator).length > numberFormatParts) {\n          // just remove all the periods or colons - there the next check will add some again\n          positiveDate = positiveDate.replaceAll('.', '');\n        }\n        // check if there are too little separators\n        if (numberFormatParts > positiveDate.split(separator).length) {\n          // check if day and month (for DDMMYYYY) or month and year (for MMYYYY) or time\n          // are without period or colon respectively\n          if (formatLength !== 4 && /^\\d{3}/.test(positiveDate)) {\n            // this assumes the first two digits are for day or month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            positiveDate = `${positiveDate.slice(0, 2)}${separator}${positiveDate.slice(2, positiveDate.length)}`;\n          }\n          // check if there is a second period between month and year (for DDMMYYYY)\n          if (this.dateFormatInt === 'DD.MM.YYYY' && formatLength !== 4 && /^\\d{2}\\.\\d{3}/.test(positiveDate)) {\n            // this assumes there are two digits for day and month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            positiveDate = `${positiveDate.slice(0, 5)}.${positiveDate.slice(5, positiveDate.length)}`;\n          }\n        }\n        // second check if the length of the value is correct\n        if (positiveDate.length !== formatLength) {\n          // distinguish between date and time string\n          if (isTimeField) {\n            // check if minutes are missing\n            if (/^\\d{1,2}:?$/.test(positiveDate)) {\n              const [hours] = positiveDate.split(':');\n              positiveDate = `${hours}:00`;\n            }\n            // check if zeros out front are missing from hour\n            if (/^\\d:\\d{1,2}$/.test(positiveDate)) {\n              const [hours, minutes] = positiveDate.split(':');\n              positiveDate = `0${hours}:${minutes}`;\n            }\n            // check if zeros out front are missing from minute\n            if (/^\\d{2}:\\d$/.test(positiveDate)) {\n              const [hours, minutes] = positiveDate.split(':');\n              positiveDate = `${hours}:0${minutes}`;\n            }\n          } else {\n            // first check reason for length mismatch is year is\n            // completely missing for date format\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^\\d{1,2}\\.\\d{1,2}\\.?(\\d{0,3})$/.test(positiveDate)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [day, month, year] = positiveDate.split('.');\n              if (!year) {\n                // repair date and add the year if it is missing\n                positiveDate = `${day}.${month}.${currentYear}`;\n                // else assume there are digits missing from the year and add 0\n              } else {\n                positiveDate = `${day}.${month}.${year.padStart(4, '0')}`;\n              }\n            }\n            // for month format\n            if (this.dateFormatInt === 'MM.YYYY' && /^\\d{1,2}\\.?(\\d{0}|\\d{2})$/.test(positiveDate)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [month, year] = positiveDate.split('.');\n              // repair date and add first two year digits - if date more than 10 years to the\n              // future - make it current century - otherwise last century\n              const century = (currentYear).toString().slice(0, 2);\n              positiveDate = `${month}.${year > (currentYear + 10).toString().slice(2, 4)\n                ? Number(century - 1) : century}${year || currentYear.toString().slice(2, 4)}`;\n            }\n            // second check if the reason for the length not matching is that the day is\n            // missing a zero\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^[1-9]\\.\\d{1,2}\\.\\d{4}$/.test(positiveDate)) {\n              // get the values\n              const [day, month, year] = positiveDate.split('.');\n              // repair date and add a zero to day\n              positiveDate = `0${day}.${month}.${year}`;\n            }\n            // second check if the reason for mismatching length is that the zero in month\n            // is missing\n            if (['DD.MM.YYYY', 'MM.YYYY'].includes(this.dateFormatInt) && /^\\d{2}?\\.?[1-9]\\.\\d{4}$/.test(positiveDate)) {\n              // get values, reverse in order to be able to get also correct values for format\n              // 'month'\n              const [year, month, day] = positiveDate.split('.').reverse();\n              // repair date and add missing zero to month\n              positiveDate = `${day}.0${month}.${year}`;\n            }\n            // if format is year assume there are zeros in the year missing\n            if (this.dateFormatInt === 'YYYY') {\n              positiveDate = `${positiveDate.padStart(4, '0')}`;\n            }\n          }\n          // now check if time/date has now the correct length - if not still remove the value\n          if (positiveDate.length !== formatLength) {\n            positiveDate = '';\n          }\n        }\n        // now check for general validity\n        if (isTimeField) {\n          // just add random date to see if time is valid\n          if (Number.isNaN(Date.parse(`1212-12-12T${positiveDate}`))) {\n            let [hours, minutes] = positiveDate.split(':');\n            // check if valid hours\n            if (!/^([0-1][0-9]|2[0-4])$/.test(hours)) {\n              hours = '00';\n            }\n            // check if valid minutes\n            if (!/^[0-5][0-9]$/.test(minutes)) {\n              minutes = '00';\n            }\n            // construct a new time\n            const newTime = `${hours}:${minutes}`;\n            // now check again if time is valid now if yes assign, if no delete the string\n            positiveDate = Number.isNaN(Date.parse(`1212-12-12T${newTime}`)) ? '' : newTime;\n          }\n        } else {\n          // now truly check if date is a valid date\n          if (Number.isNaN(Date.parse(this.parseToDateStorage(positiveDate)))) {\n            // TODO: check if date has appropriate number of periods\n            const [year, month, day] = positiveDate.split('.').reverse();\n            if (this.dateFormatInt === 'DD.MM.YYYY') {\n              // TODO: could this check already be done on input???\n              // check if something is wrong with the day\n              if (!/^(0[1-9]|[1-2][0-9]|3[0-1])/.test(day)) {\n                // replace day with appropriate value\n                positiveDate = `01.${month}.${year}`;\n              }\n            } if (this.dateFormatInt !== 'YYYY') {\n              // check if something is wrong with the month\n              if (!/^(0[1-9]|1[0-2])/.test(month)) {\n                // replace month with appropriate value\n                positiveDate = `${day ? `${day}.` : ''}01.${year}`;\n              }\n            }\n          }\n          // since technically invalid dates (like 30.02.2000) will also be considered a\n          // valid date by Date.parse() just convert to Date and back one more time\n          // new Date(input) will always convert to the actual day in the next month\n          // e.g. 31.06. --> 01.07. ; 30.02. --> 02.03.\n          const tempDate = this.getDateString(this.convertToDate(this.parseToDateStorage(positiveDate)));\n          if (!Number.isNaN(Date.parse(this.parseToDateStorage(tempDate)))) {\n            positiveDate = tempDate;\n          } else {\n            positiveDate = '';\n          }\n        }\n        // now add the minus again if necessary\n        this[`input${origin}`] = this.addYearMinusToDateDisplay(\n          positiveDate,\n          this.isNegativeDisplayDate(this[`input${origin}`]),\n        );\n        // after everything also still check if the new date/time string needs a fade out\n        this.calcFadeOut([origin]);\n      }\n      const data = this.getInputData();\n      /**\n       * this event is emitted when the value was validated in case input should just be considered\n       * after date validation\n       *\n       * @event value-validated\n       * @param {string, Object} - the validated string or input object\n       */\n      this.$emit('value-validated', data);\n    },\n    /**\n     * a function to have the time picker close automatically as soon as minutes\n     * are selected\n     * @param {string} origin - is it from the 'from' or 'to' part of the picker\n     * @param {any} time - the selected time (not needed here but passed by event)\n     * @param {string} type - was 'hour' or 'minute' selected\n     */\n    closeTimePicker(origin, time, type) {\n      if (type === 'minute') {\n        // get capitalized origin here since needed 2x\n        const uppercaseOrigin = capitalizeString(origin);\n        // check date validity\n        this.checkDateValidity(uppercaseOrigin);\n        // close the drop down\n        this[`${origin}Open`] = false;\n        // check if the new date/time string needs a fade out\n        this.calcFadeOut([uppercaseOrigin]);\n      }\n    },\n    /**\n     * function triggered on datepicker 'pick' event, handling date picker closing\n     * and date validation\n     *  caveat: this event is just triggered for DATE picker - not time!\n     * @param origin\n     */\n    datePicked(origin) {\n      this[`${origin}Open`] = false;\n      // need this here because on blur() date is not updated\n      this.checkDateValidity(capitalizeString(origin));\n    },\n    /**\n     * handle click outside event and adjust input active variable accordingly\n     * @param {MouseEvent} event - the event provided by the click outside directive\n     */\n    clickedOutside(event) {\n      this.isActiveInt = false;\n      /**\n       * emit a custom clicked-outside event instead of BaseInput event (propagation stopped)\n       *\n       * @event clicked-outside\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('clicked-outside', event);\n    },\n    /**\n     * handle click inside the component and adjust input active variable accordingly\n     * @param {MouseEvent} event - event triggered by mouse click\n     */\n    clickedInside(event) {\n      this.isActiveInt = true;\n      /**\n       * event additionally triggered to BaseInput default click-input-field to also\n       * set field active if component sourroundings are clicked\n       *\n       * @event click-input-field\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('click-input-field', event);\n    },\n    /**\n     * data emit function, transforming data before emit event\n     */\n    emitData() {\n      // get a data object that only contains fields that were also present\n      // in external input\n      const data = this.getInputData();\n      /**\n       * emit an event when focus leaves the input\n       *\n       * @event selected\n       * @param {string, Object} - the input string or object\n       */\n      this.$emit('selected', data);\n    },\n    /**\n     * convert function triggered on format tab switch\n     */\n    convertDate(oldFormat) {\n      // go over each property of inputInt (that includes date - since not applicable to time\n      // values)\n      Object.entries(this.inputInt).filter(([key]) => !!key.includes('date'))\n        .forEach(([dateKey, dateValue]) => {\n          // get the date to convert and remove the minus if there is one\n          const dateToConvert = this.removeYearMinusFromStorageDate(dateValue, oldFormat);\n          if (dateToConvert) {\n            if (this.minDateView === 'year') {\n              // convert date string to real date in order to get year and convert back to string\n              this.$set(this.inputInt, dateKey, this.addYearMinusToDateStorage(\n                this.convertToDate(dateToConvert).getFullYear().toString(),\n                this.isNegativeStorageDate(dateValue, oldFormat),\n              ));\n              return;\n            }\n            let useStorageDate;\n            const storageDate = this.tempDateStore ? this.tempDateStore[dateKey] : null;\n            const isNegativeTempStorageDate = !!storageDate && /^-/.test(storageDate);\n            const isNegativeNewDateValue = this.isNegativeStorageDate(dateValue, oldFormat);\n            const positiveTempStorageDate = isNegativeTempStorageDate ? storageDate.replace('-', '') : storageDate;\n            if (this.minDateView === 'month') {\n              useStorageDate = !!positiveTempStorageDate\n                // get stored date if\n                // a) previous date was full date and month and year\n                // are identical with stored year and month\n                && ((!this.isDateFormatYear\n                    && this.monthAndYearIdent(positiveTempStorageDate, dateToConvert))\n                  // b) previous date was year and it is identical with stored year\n                  || (new Date(positiveTempStorageDate)\n                    .getFullYear().toString() === dateToConvert))\n                // also check that they have the identical sign\n                && (isNegativeTempStorageDate === isNegativeNewDateValue);\n              // assume the format is 'date'\n            } else {\n              // check if a previous date was stored and year (coming from year)\n              useStorageDate = !!positiveTempStorageDate && ((this.isDateFormatYear\n                && new Date(positiveTempStorageDate).getFullYear().toString() === dateToConvert\n                  && isNegativeTempStorageDate === this.isNegativeStorageDate(dateValue, oldFormat))\n                // or month and year (coming from month) was changed or is still the same\n                || (this.isDateFormatMonth\n                && this.monthAndYearIdent(positiveTempStorageDate, dateToConvert)\n                  && (isNegativeTempStorageDate === isNegativeNewDateValue)));\n              // if a previous date was stored use this one else use the input date\n            }\n            const newDate = useStorageDate ? positiveTempStorageDate : dateToConvert;\n            // now assign the new date to the input variable\n            this.$set(\n              this.inputInt,\n              dateKey,\n              this.addYearMinusToDateStorage(\n                this.getDateString(this.convertToDate(newDate)),\n                // use the original dates here before minus was removed, depending on which date was used\n                (useStorageDate ? isNegativeTempStorageDate : isNegativeNewDateValue),\n              ),\n            );\n          }\n        });\n    },\n    /**\n     * if input was just a single string return that otherwise\n     * only return the properties provided by external input\n     * if input is empty set value to empty string instead of null (default vue2-datepicker)\n     * @returns {string | Object}\n     */\n    getInputData() {\n      if (this.isInputTypeString) {\n        return this.inputInt.date !== null ? this.inputInt.date : '';\n      }\n      const data = {};\n      this.inputProperties.forEach(key => this.$set(data, key, this.inputInt[key] !== null ? this.inputInt[key] : ''));\n      return data;\n    },\n    /**\n     * convert a value to a date in local time at zero hours\n     *\n     * @param {string} value - the date string stored in db (format YYYY-MM-DD) - this needs to\n     *  be a positive date value!! (remove minus from negative years before applying this function)\n     * @returns {Date} - (e.g. Fri Jul 30 2021 00:00:00 GMT+0200 (Central European Summer Time))\n     */\n    convertToDate(value) {\n      return new Date(`${value}T00:00:00.000`);\n    },\n    /**\n     * a function to convert a date to a string in the format YYYY-MM-DD\n     *\n     * @param {Date} date in format\n     * @returns {string} - returns a string in format YYYY-MM-DD\n     */\n    getDateString(date) {\n      // there is always a year // add padStart to always have 4 digits\n      let dateString = `${date.getFullYear().toString().padStart(4, '0')}`;\n      // if date format is not 'year' only - add month\n      if (this.dateFormatInt !== 'YYYY') {\n        const month = (date.getMonth() + 1).toString();\n        dateString = `${dateString}-${month.length < 2 ? '0' : ''}${month}`;\n      }\n      // if date format is 'date' - add day\n      if (this.dateFormatInt === 'DD.MM.YYYY') {\n        const day = date.getDate().toString();\n        dateString = `${dateString}-${day.length < 2 ? '0' : ''}${day}`;\n      }\n      return dateString;\n    },\n    /**\n     * compare 2 dates for identical month and year values respectively\n     *  these dates need to be positive values (remove the minus from the date\n     *  before applying this function)\n     * @param {string} date1 - a string in YYYY-MM-DD format\n     * @param {string} date2 - a string in YYYY-MM-DD format\n     * @returns {boolean}\n     */\n    monthAndYearIdent(date1, date2) {\n      const convertedDate1 = this.convertToDate(date1);\n      const convertedDate2 = this.convertToDate(date2);\n      const monthDate1 = convertedDate1.getMonth();\n      const monthDate2 = convertedDate2.getMonth();\n      const yearDate1 = convertedDate1.getFullYear();\n      const yearDate2 = convertedDate2.getFullYear();\n      return monthDate1 === monthDate2 && yearDate1 === yearDate2;\n    },\n    /**\n     * check for a negative year in the date that is displayed\n     * @param {string} date - date string in the format DD.MM.YYYY\n     * @returns {boolean}\n     */\n    isNegativeDisplayDate(date) {\n      if (!date) return false;\n      if (this.dateFormatInt === 'MM.YYYY') {\n        return /^\\d{0,2}\\.-\\d{0,4}$/.test(date);\n      }\n      if (this.dateFormatInt === 'YYYY') {\n        return /^-\\d{0,4}$/.test(date);\n      }\n      return /^\\d{0,2}\\.\\d{0,2}\\.-\\d{0,4}$/.test(date);\n    },\n    /**\n     * check if year is negative in the stored date\n     * @param {string} date - a date string in the format YYYY-MM-DD\n     * @param {string} [format=undefined] - in case not the current format (this.dateFormatInt) should\n     *  be used for evaluation provide it with this param\n     * @returns {boolean}\n     */\n    isNegativeStorageDate(date, format = undefined) {\n      // if there is no date to evaluate just return false\n      if (!date) return false;\n      // either use the format provided as param or the currently set format in dateFormatInt\n      const formatToCheck = format || this.dateFormatInt;\n      if (formatToCheck === 'MM.YYYY') {\n        return /^-\\d{0,4}-\\d{0,2}$/.test(date);\n      }\n      if (formatToCheck === 'YYYY') {\n        return /^-\\d{0,4}$/.test(date);\n      }\n      return /^-\\d{0,4}-\\d{0,2}-\\d{0,2}$/.test(date);\n    },\n    /**\n     * since minus has to be temporarily removed for some actions add it again\n     *  after with this function (for displayed date)\n     * @param {string} date - date in the format DD.MM.YYYY\n     * @param {boolean} [isNegative=true] - optionally do not add minus when calling this\n     *  function\n     * @returns {string}\n     */\n    addYearMinusToDateDisplay(date, isNegative = true) {\n      if (isNegative) {\n        const [year, month, day] = date.split('.').reverse();\n        return `${day !== undefined ? `${day}.` : ''}${month !== undefined ? `${month}.` : ''}-${year}`;\n      }\n      return date;\n    },\n    /**\n     * since minus has to be temporarily removed for some actions add it again\n     *  after with this function (for stored date)\n     * @param {string} date - date in the format YYYY-MM-DD\n     * @param {boolean} [isNegative=true] - optionally do not add minus when calling this\n     *  function\n     * @returns {string}\n     */\n    addYearMinusToDateStorage(date, isNegative = true) {\n      if (isNegative) {\n        return `-${date}`;\n      }\n      return date;\n    },\n    /**\n     * remove the minus from the date since some functions (especially Date() ) can\n     *  not cope with negative dates (for displayed date)\n     * @param {string} date - the date string in format DD.MM.YYYY\n     * @returns {string}\n     */\n    removeYearMinusFromDisplayDate(date) {\n      return this.isNegativeDisplayDate(date)\n        ? date.replace('-', '') : date;\n    },\n    /**\n     * remove the minus from the date since some functions (especially Date()) can\n     *  not cope with negative dates (for stored date)\n     * @param {string} date - the date string in format YYYY-MM-DD\n     * @param {string} [format=undefined] - in case not the currently selected format should be used\n     *  for date evaluation provide the format with this param\n     * @returns {string}\n     */\n    removeYearMinusFromStorageDate(date, format = undefined) {\n      return this.isNegativeStorageDate(date, format)\n        ? date.replace('-', '') : date;\n    },\n    isTimeInputField(origin) {\n      return this.type === 'timerange' || (this.type === 'datetime' && origin.toLowerCase() === 'to');\n    },\n    /**\n     * function to calculate if fade out in the input fields should be shown, needs to be\n     * recalculated after resize or if input changes\n     */\n    calcFadeOut(inputFields) {\n      // now iterate through the relevant fields\n      inputFields.forEach((field) => {\n        // check if element exists\n        if (this.$refs[`input${field}`]) {\n          // now get the input field value\n          const inputValue = this.$refs[`input${field}`].value;\n          // for width (and fade out) calculation either use that or the placeholder visible\n          // in the field (this is saved in a separate variable from inputValue because for\n          // show icons only input value is relevant)\n          const text = inputValue || this.$refs[`input${field}`].getAttribute('placeholder');\n          // now check if any of the two exists\n          if (text) {\n            // create a span\n            const span = document.createElement('span');\n            // hide the span\n            span.setAttribute('class', 'hide');\n            // add the input extracted text to this span\n            span.innerHTML = text;\n            // add the element to the document body\n            document.body.appendChild(span);\n            // get the width of that element\n            const textWidth = span.offsetWidth;\n            // remove the element again\n            document.body.removeChild(span);\n            // now also get the input width\n            const inputWidth = this.$refs[`input${field}`].offsetWidth;\n            // check if the input value or placeholder width exceeds input width\n            if (textWidth > inputWidth) {\n              // if yes and there is input and icons are shown\n              if (inputValue && this.showIcons) {\n                // remove icons\n                this.showIcons = false;\n                // otherwise use fade out\n              } else {\n                this[`useFadeOut${field}`] = true;\n              }\n              // if input value or placeholder fit the input width\n            } else if (textWidth <= inputWidth) {\n              // check first if the fade out is used\n              if (this[`useFadeOut${field}`]) {\n                // if so - disable this one first\n                this[`useFadeOut${field}`] = false;\n                // else check if the icon would actually fit in the input together with the\n                // input width - if so - show icons\n              } else if (!this.showIcons && textWidth + this.iconWidth <= inputWidth) {\n                this.showIcons = true;\n              }\n            }\n          }\n        }\n      });\n    },\n    /**\n     * function to correctly style the date format switch buttons and prevent\n     * overlay with label\n     */\n    calcLabelAdditionsWidth() {\n      // get the complete element width\n      const observableWidth = this.$refs.baseDateInput.clientWidth;\n      // get the label margin\n      const labelMargin = this.showLabel\n        ? Number(getComputedStyle(this.$refs.label)['margin-right'].replace('px', '')) : 0;\n      const labelWidth = this.showLabel ? this.$refs.label.clientWidth : 0;\n      // calculate the remaining container space after label, label margin and date switch width\n      const spacingLeft = observableWidth\n        - labelWidth\n        - labelMargin\n        - this.$refs.labelAdditions.clientWidth;\n      // if no space is left set a class that sets label additions width to 100% so element has to wrap\n      this.wrapLabelRow = spacingLeft < 0;\n    },\n    /**\n     * add delay before value is set\n     *\n     * @param {String} origin - is event originating from 'from' or 'to' field\n     * @param {boolean} value\n     */\n    isActiveHandler(origin, value) {\n      // if false set value immediately\n      if (!value) {\n        this[`${origin}Open`] = value;\n        this.isActiveInt = this.fromOpen || this.toOpen;\n        // check for date validity here instead of blur event (necessary for time input\n        // which is not triggered otherwise)\n        this.checkDateValidity(capitalizeString(origin));\n        return;\n      }\n\n      // otherwise add a delay\n      setTimeout(() => {\n        this[`${origin}Open`] = value;\n        this.isActiveInt = this.fromOpen || this.toOpen;\n      }, this.isActiveDelay);\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import '../../styles/variables.scss';\n\n  .base-date-input {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    position: relative;\n\n    .base-date-input__label-row {\n      display: flex;\n      flex-wrap: wrap;\n      width: 100%;\n      height: 100%;\n      justify-content: space-between;\n      align-items: center;\n\n      &.base-date-input__label-row--visible {\n        margin-bottom: $spacing-small-half;\n      }\n\n      .base-date-input__label {\n        color: $font-color-second;\n        margin-bottom: $spacing-small-half;\n        text-align: left;\n        align-self: flex-end;\n        margin-right: 50px;\n      }\n\n      .base-date-input__label-additions {\n        position: relative;\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        justify-content: flex-end;\n        flex: 1 1 auto;\n        height: $line-height;\n\n        &.base-date-input__label-additions--switch-height {\n          height: calc(#{$line-height} + #{$spacing-small-half});\n\n          &.base-date-input__label-additions--wrap {\n            margin-top: 2px;\n          }\n        }\n\n        &.base-date-input__label-additions--wrap {\n          width: 100%;\n        }\n      }\n\n      .base-date-input__label-additions-inner {\n        position: absolute;\n        right: 0;\n        display: flex;\n        align-items: center;\n        margin-bottom: $spacing-small-half;\n\n        &.base-date-input__label-additions-inner--switch {\n          bottom: 0;\n          margin-bottom: calc(-#{$spacing-small-half} / 2);\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} - 2px);\n          }\n        }\n        &.base-date-input__label-additions-inner--no-label-switch {\n          margin-bottom:  2px;\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} + 1px);\n          }\n        }\n\n        .base-date-input__switch-buttons {\n          bottom: 0;\n          display: flex;\n          line-height: $line-height;\n        }\n      }\n    }\n\n    .base-date-input__field-wrapper {\n      display: flex;\n      align-items: baseline;\n      width: 100%;\n\n      .base-date-input__input-fields {\n        display: flex;\n        align-items: center;\n        flex: 1 1 auto;\n        flex-wrap: wrap;\n\n        .base-date-input__input-line {\n          display: flex;\n          flex: 1 1 auto;\n          align-items: center;\n\n          .base-date-input__input-wrapper {\n\n            & + .base-date-input__input-wrapper {\n              margin-left: $spacing;\n            }\n\n            .base-date-input__datepicker {\n              flex-grow: 1;\n              width: auto;\n              font-family: inherit;\n              font-size: inherit;\n              line-height: $row-height-small;\n\n              .base-date-input__input {\n                padding: $spacing-small-half 0;\n                min-height: $row-height-small;\n                width: 100%;\n              }\n            }\n\n            .base-date-input__icon-wrapper::before {\n              content: '';\n            }\n\n            .base-date-input__date-icon {\n              position: relative;\n              width: $icon-large;\n              height: $icon-large;\n              color: $font-color-second;\n              cursor: pointer;\n              flex-shrink: 0;\n              align-self: center;\n              margin-left: $spacing-small;\n            }\n          }\n\n          .base-date-input__separator {\n            padding: 0 $spacing;\n          }\n        }\n      }\n    }\n\n    .base-date-input__below {\n      position: relative;\n    }\n  }\n\n  @media screen and (max-width: $mobile) {\n    .base-date-input .base-date-input__label-row .base-date-input__label-additions {\n      align-items: center;\n    }\n  }\n</style>\n\n<style lang=\"scss\">\n  @import '../../styles/_datepicker.scss';\n</style>\n"],"names":["_sfc_main","BaseInput","BaseIcon","m","DatePicker","ClickOutside","val","labelKeys","de","en","fr","createId","oldValue","newDate","newValue","key","options","event","slotElements","elem","_a","isDateTimeField","old","dateKey","el","element","origin","relatedTargetInput","_b","_c","_d","tempResizeObserver","debounce","tempLabelAdditionsObserver","entries","observer","dateString","isNegativeYear","positiveDateString","currentInputString","isTimeField","allowedFieldKey","allowMinus","allowedKeysRegex","disallowedKeysOnLengthRegex","formatLength","modifiedValue","charToAdd","day","month","year","positiveDate","separator","numberFormatParts","hours","minutes","currentYear","century","newTime","tempDate","data","time","type","uppercaseOrigin","capitalizeString","oldFormat","dateValue","dateToConvert","useStorageDate","storageDate","isNegativeTempStorageDate","isNegativeNewDateValue","positiveTempStorageDate","value","date","date1","date2","convertedDate1","convertedDate2","monthDate1","monthDate2","yearDate1","yearDate2","format","formatToCheck","isNegative","inputFields","field","inputValue","text","span","textWidth","inputWidth","observableWidth","labelMargin","labelWidth","spacingLeft"],"mappings":"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"}