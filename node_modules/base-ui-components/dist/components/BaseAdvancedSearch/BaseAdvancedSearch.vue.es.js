import { defineAsyncComponent as c, ref as f } from "vue";
import { sort as h, hasData as u, createId as y, extractNestedPropertyValue as m, debounce as F } from "../../utils/utils.es.js";
import b from "../../directives/InsertTextAsHtml.es.js";
import g from "./BaseAdvancedSearchRow.vue.es.js";
import { useAnnouncer as v } from "../../composables/useAnnouncer.es.js";
import "./BaseAdvancedSearch.vue.es2.js";
import N from "../../_virtual/_plugin-vue2_normalizer.es.js";
const O = {
  name: "BaseAdvancedSearch",
  components: {
    BaseAdvancedSearchRow: g,
    BaseCollapsedFilterRow: c(() => import("./BaseCollapsedFilterRow.vue.es.js").then((t) => t.default || t)),
    BaseForm: c(() => import("../BaseForm/BaseForm.vue.es.js").then((t) => t.default || t)),
    BaseButton: c(() => import("../BaseButton/BaseButton.vue.es.js").then((t) => t.default || t))
  },
  directives: {
    insertTextAsHtml: b
  },
  props: {
    /**
     * define the appearance and functionality of the component here.
     * **`list`**: search offers advanced search with 'filters' to select from drop down, each filter is added
     *    as a separate row.
     * **`form`**: advanced search is displayed as a form below only one single search row. Offers a condensed view
     *    of the form within a single scrollable row below main row.
     */
    mode: {
      type: String,
      default: "list",
      validator: (t) => ["list", "form"].includes(t)
    },
    /**
     * this variable is just used in mode `list`, for mode `form` leave it empty and use variable `formFilterList`
     *  to provide a list of filters instead.
     * provide a list of available filters, needs to be an array of objects with the following properties:
     *
     *    **label** `string` - the label of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      `labelPropertyName.filter`.
     *    **id** `string` - the identifier of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      `identifierPropertyName.filter`.
     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.
     *    **hidden** `boolean` - filters with this attribute true will be filtered from
     *      displayed filter list.
     *    **freetext_allowed** `boolean` - determines if predetermined options from `options`
     *      property are used or autocomplete is used.
     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled
     *      vocabulary options.
     *     **subsets** `string[]` - if a filter of `type` 'text' or 'chips' with
     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which
     *      the autosuggest results should also be shown - add the filter identifiers here
     */
    filterList: {
      type: Array,
      default: () => [],
      validator: (t) => !t.length || t.every((e) => !!e.type && (!["chips", "chipssingle"].includes(e.type) || e.freetext_allowed || !!e.options))
    },
    /**
     * this variable is just used in mode `list`, for mode `form` leave it empty and use property `formFilterValues`
     *  to provide values per filter instead.
     * possibility to set applied filters from outside, for necessary object properties
     * see `filterList` (except `options` - this property is not necessary for applied filters)
     */
    appliedFilters: {
      type: Array,
      default: () => [],
      // don't check for options on applied filters - not necessary
      validator: (t) => !t.length || t.every((e) => e.type)
    },
    /**
     * in mode `list` specify a default value for a filter that is set when none of the
     * available filters is selected, should have the following properties:
     *
     *    **label** `string` - the label of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      `labelPropertyName.filter`.
     *    **id** `string` - the identifier of the filter (displayed
     *      if not main search) - this prop can be customized by specifying
     *      `identifierPropertyName.filter`.
     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.
     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled
     *      vocabulary options.
     *    **filter_values** `Object[], string[], Object` - the values selected - object for date
     *    or array of objects or strings for type `text`, type `chips` and `chipssingle`,
     *
     *    defaultFilter does not need the property `subsets` since results for all filters are
     *    shown per default
     *
     *  this property is not relevant in mode `form`
     */
    defaultFilter: {
      type: Object,
      default: () => ({
        label: "Fulltext",
        id: "default",
        type: "text",
        options: [],
        filter_values: []
      }),
      validator: (t) => t === null || t.type && (!["chips", "chipssingle"].includes(t.type) || t.options)
    },
    /**
     * this variable is just used in mode `form`, for mode `list` leave it empty and use property `filterList`
     *  to provide a list of filters instead.
     * for mode 'form' provide a specification for the form fields in the form of [OpenAPi
     *  schema object](https://swagger.io/specification/#schema-object).
     *  see also [BaseForm](BaseForm) `form-field-json` prop - currently all field types except
     *    `multiline` and `chips-below` and for date/time fields only single date, date range and date time fields
     *    are supported. Also field groups are supported but maximum nesting level is 1.
     */
    formFilterList: {
      type: Object,
      default: () => ({})
    },
    /**
     * this variable is just used in mode `form`, for mode `list` leave it empty and use property `appliedFilters`
     *  to provide values per filter instead.
     * provide values for the fields specified in `formFilterList`. Main filter can be filled by adding a `default` property.
     */
    formFilterValues: {
      type: Object,
      default: () => ({})
    },
    /**
     * pass props for [BaseForm](BaseForm) directly via this prop, for example `autocompleteResults`,
     *  `isLoading` or `fieldProps` (except `valueList` and `formFieldJson` which are passed separately
     *   since they are also utilized (and modified) in this component).
     */
    formProps: {
      type: Object,
      default: () => ({})
    },
    /**
     * provide the component with the fetched autocomplete results
     * (drop down options).
     * this needs to be an object array with the properties specified in
     * `autocompletePropertyNames`.
     */
    autocompleteResults: {
      type: Array,
      default: () => []
    },
    /**
     * specify a language (ISO 639-1) (used for label if label is language specific object
     * e.g. `{ de: 'xxx', en: 'yyy' }`) or for date display conversion in mode 'form'.
     */
    language: {
      type: String,
      default: "en"
    },
    /**
     * set the row loader from outside per row index
     */
    isLoadingIndex: {
      type: Number,
      default: -1
    },
    /**
     * specify informational texts for the component - this needs to be an object with the following
     * properties (if you don't want to display any text leave an empty string):
     *
     *     **title**: text shown as first line on the drop-down in filters area for mode `list`.
     *     **subtext**: text shown as second line on the drop-down in filters area for mode `list`.
     *     **availableOptions**: text shown with chips options for controlled vocabulary
     *     search` for mode `list`.
     *     **collapsedDateTime**: for mode `form`: set the text for the collapsed filter row which is
     *      displayed for date or time values of ranges when only one field is filled. (e.g. `until 12.12.2023`)
     *     **advancedButtonLabel**: button text displayed for Advanced Search Toggle button for mode `form`.
     *
     *  The values of this object might be plain text or a key for an i18n file.
     */
    advancedSearchText: {
      type: Object,
      default: () => ({
        title: "Advanced Search",
        subtext: "Select a filter",
        availableOptions: "Available options",
        collapsedDateTime: {
          from: "from",
          until: "until",
          range: "to"
        },
        advancedButtonLabel: "Advanced Search"
      })
    },
    /**
     * specify informational texts for the drop-down - this needs to be an object with the following
     * properties:
     *
     *     **autocompleteNoOptions**: info text shown when autocomplete search does not yield
     *        any results.
     *     **autocompleteOngoing**: info text displayed while autocomplete search is ongoing
     *        (and no previous results are displayed).
     *     **autocompleteInitial**: info text shown when user first opens the search
     *        component.
     *     **chipsNoOptions**: info text shown when no options for controlled vocabulary search
     *        are available (anymore).
     *     **chipsMaxOptions**: text displayed if more than max number of options that can be
     *        displayed are available (configure via prop `maxNumberControlledOptions`).
     *     **chipsNoMatch**: text displayed if string in input does not match any options.
     *     **chipsOngoing**: info text shown when controlled vocabulary chips are being
     *        fetched.
     *
     *  The values of this object might be plain text or a key for an i18n file
     * This prop can be ignored when the `no-options` slot is used.
     */
    dropDownInfoTexts: {
      type: Object,
      default: () => ({
        autocompleteNoOptions: "No matching options found",
        autocompleteOngoing: "Autocomplete is being fetched...",
        autocompleteInitial: "Please start typing or select a filter to see options",
        chipsNoOptions: "No more options available",
        chipsMaxOptions: "Please start typing to see options",
        chipsNoMatch: "No matching options were found",
        chipsOngoing: "Options are being loaded..."
      }),
      // checking if all necessary properties are part of the provided object
      validator: (t) => [
        "autocompleteNoOptions",
        "autocompleteOngoing",
        "autocompleteInitial",
        "chipsNoOptions",
        "chipsOngoing",
        "chipsMaxOptions",
        "chipsNoMatch"
      ].every((e) => Object.keys(t).includes(e))
    },
    /**
     * add a placeholder for the search input, either a string used for every row or
     * add separate values for main filter row and already added filters
     * properties:
     *     **filterRow**: for already added filter rows.
     *     **main**: for the primary search input field.
     *
     *  each of these specific placeholders can again be a string or an object with different
     *  placeholders for each search type (`text`, `chips`, `date`)
     */
    placeholder: {
      type: [Object, String],
      default: () => ({
        filterRow: "Add values to your filter",
        main: "Search and Discover"
      }),
      validator: (t) => typeof t == "string" || ["filterRow", "main"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * specify the object property that can be used for identification of filters,
     * autocomplete options and controlled vocabulary options.
     *   Could be a string (used for all the mentioned objects) or an object with the following
     *   properties:
     *     **filter**: identifier property name in filter objects.
     *     **autocompleteOption**: identifier property name in autocomplete option objects.
     *     **controlledVocabularyOption**: identifier property name in controlled
     *     vocabulary option objects.
     *     **formInputs**: for mode 'form' in case the form contains chips or autocomplete input fields,
     *      the object properties for label and identifier need to be set here (in case they are different
     *      from the input components default (e.g. see [BaseChipsInput](BaseChipsInput) `identifierPropertyName`))
     *      if `identifierPropertyName` is also set via `fieldProps` the latter is the preferred value.
     *  Caveat: Please note that the property `idInternal` is used for internal handlings and the property
     *    might be overwritten
     */
    identifierPropertyName: {
      type: [Object, String],
      default: () => ({
        filter: "id",
        autocompleteOption: "id",
        controlledVocabularyOption: "id",
        formInputs: "source"
      })
    },
    /**
     * specify the object property that should be used for label display of filters,
     * autocomplete options and controlled vocabulary options.
     *   Could be a string (used for all the mentioned objects) or an object with the following
     *   properties:
     *     **filter**: label property name in filter objects.
     *     **autocompleteOption**: label property name in autocomplete option objects.
     *     **controlledVocabularyOption**: label property name in controlled
     *     vocabulary option objects.
     *     **formInputs**: for mode 'form' in case the form contains chips or autocomplete input fields,
     *      the object properties for label and identifier need to be set here (in case they are different
     *      from the input components default (e.g. see [BaseChipsInput](BaseChipsInput) `labelPropertyName`))
     *      if `labelPropertyName` is also set via `fieldProps` the latter is the preferred value.
     *    Caveat: Please note that the property `labelInternal` is used for internal handlings and the property
     *    might be overwritten
     */
    labelPropertyName: {
      type: [Object, String],
      default: () => ({
        filter: "label",
        autocompleteOption: "title",
        controlledVocabularyOption: "label",
        formInputs: "label"
      })
    },
    /**
     * autocomplete results need a label, and id and a data property that contains all the actual
     * autocomplete results for that specific category
     * TODO: make category optional
     */
    autocompletePropertyNames: {
      type: Object,
      default: () => ({
        label: "label",
        id: "id",
        data: "data"
      }),
      // check if all the necessary attributes are included in the provided object
      validator: (t) => ["id", "label", "data"].every((e) => Object.keys(t).includes(e))
    },
    /**
     * this prop gives the option to add assistive text for screen readers for
     *  the BaseSearch component.
     * properties:
     * **addFilter**: text/label used for add filter icon for mode `list`.
     * **removeFilter**: text/label used for remove filter icon for mode `list`.
     * **selectFilterLabel**: label (not visible) used for filter chips input field for mode `list`.
     * **searchLabel**: label (not visible) used for search input field.
     * **selectedOption**: text read when a selected option is focused (currently only
     *  working for type chips with autocomplete (=freetext_allowed))
     * **loaderActive**: text that is announced when autocomplete results are being fetched (prop
     *  `isLoading` is set `true`)
     * **autocompleteResultsRetrieved**: text announced when autocomplete results are returned.
     *  use {optionsNumber} and {collectionsNumber} in the string to announce the number of
     *  total options and collections found respectively.
     * **autocompleteNoResults**: Text announced when no results were found with a given
     *  search string.
     * **autocompleteInitial**: Text announced when no search string was provided for
     *  autocomplete.
     * **categoryAnnouncement**: Text announced when a new category is entered in the
     *  autocomplete drop down options list with keyboard navigation. string '{label}' will
     *  be replaced by the actual specified category label
     * **optionsAnnouncement**: announced together with category when in category selection
     *  mode (after using arrowLeft key on autocomplete input) - to give the user a feeling
     *  how many options were found for the announced category. string '{number}' will be
     *  replaced by the number of entries in that category.
     * **autocompleteOptionFilledToForm**: text announced when an option was selected from the autocomplete
     *  dropdown, and it is filled into the respective form field. (only for mode `form`)
     * **advancedButtonDescription**: button description for Advanced Search Toggle button for mode `form`.
     *      For accessibility purposes. You may add the string {state} which will be replaced with the respective
     *      'open' and 'close' value specified in `formState` (see below). Only relevant for mode `form`.
     * **formState**: an object with properties `open` (text that is read when form is closed and button
     *      functionality is to open the form) and `close` (text that is read when form is open and button
     *      functionality is to close the form). Only relevant for mode `form`.
     * **removeAllFiltersLabel**: label for the remove icon in the collapsed filter row.
     *     Only relevant for mode `form`. For accessibility purposes
     * **removeFilterValueNotification**: notification that is read by screen readers when a filter
     *      value was removed. Add the string {value} to read the filter value that was removed and
     *      {label} to read the label of the filter from which the value was removed. Only relevant for mode `form`.
     * **collapsedFilterRowRemovedNotification**: notification read when the last filter was removed from
     *      the collapsed filter row. Or remove row was clicked. Only relevant for mode `form`.
     * **collapsedAppliedFiltersLabel**: description for the filters in the collapsed filter row.
     *      Only relevant for mode `form`. For accessibility purposes.
     * **collapsedBooleanFilterValue**: Set text that should be read for a boolean filter value. You may add
     *      the string {label} which will be replaced by the filter label.
     *      Only relevant for mode `form`. For accessibility purposes.
     * **collapsedOptionToRemoveSelected**: text read when an option is focused (and thus selected), should
     *  announce to the screen reader user that option can now be removed via Backspace or Delete.
     * **results**: provide text that should be announced when the search has
     *  yielded results (or not).
     *
     * Caveat: `results` has a watcher attached to trigger the
     *    announcement so make sure the property values are reset after filling them
     *    by using update:assistive-text or resetting it manually (after a timeout)
     */
    assistiveText: {
      type: Object,
      default: () => ({
        addFilter: "Add filter",
        removeFilter: "Remove filter",
        selectFilterLabel: "Select filter",
        searchLabel: "Search for Entries",
        selectedOption: "",
        autocompleteLoaderActive: "loading options.",
        autocompleteResultsRetrieved: "{optionsNumber} options found in {collectionsNumber} categories.",
        autocompleteNoResults: "No results found.",
        autocompleteInitial: "Please start typing to see suggestions.",
        categoryAnnouncement: "category {label}.",
        optionsAnnouncement: "{number} options.",
        autocompleteOptionFilledToForm: "option {optionLabel} filled to field {fieldLabel}.",
        advancedButtonDescription: "Click to {state} advanced search form.",
        formState: {
          open: "open",
          close: "close"
        },
        removeAllFiltersLabel: "Remove all filters.",
        removeFilterValueNotification: "Filter value {value} was removed from filter {label}.",
        collapsedFilterRowRemovedNotification: "All search filters were reset.",
        collapsedAppliedFiltersLabel: "Currently applied Filters",
        collapsedBooleanFilterValue: "Filter {label} was set",
        collapsedOptionToRemoveSelected: "Press delete or backspace to remove.",
        results: ""
      })
    },
    /**
     * if desired the box shadow around the search rows can be deactivated here
     */
    applyBoxShadow: {
      type: Boolean,
      default: !0
    },
    /**
     * use this prop to set a delay in ms before date input calendar is displayed
     */
    dateFieldDelay: {
      type: Number,
      default: 0
    },
    /**
     * prop only relevant for mode `form`
     * set advanced search (form) visibility from outside
     * this can also be used to not show the advanced search after initial loading
     */
    advancedFormOpen: {
      type: Boolean,
      default: !0
    },
    /**
     * set this flag to `true` to highlight autocomplete option characters that match
     *  the current search input string
     */
    highlightAutocompleteMatch: {
      type: Boolean,
      default: !1
    },
    /**
     * if `highlightAutocompleteMatch` is set `true`
     *  provide tag names to style the matched characters
     *  (without '<' and '>', e.g. ['b'] for <b>)
     */
    highlightAutocompleteTags: {
      type: Array,
      default: () => []
    },
    /**
     * mode `form`: if necessary selected chip text can  be rendered as v-html directive
     *  either set this prop `true` or `false`
     *
     * this will only be applied to chips with an identifier property and of course
     *   can only apply to form field field_type `chips`
     *
     * if only chips of certain form fields should be rendered as html use prop
     *  `formProps.fieldProps.interpretChipsLabelAsHtml` or if certain fields should
     *  be excluded set this prop to `true` and set `formProps.fieldProps.interpretChipsLabelAsHtml`
     *  for that field `false`
     */
    interpretFormChipsLabelAsHtml: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["search", "fetch-autocomplete", "fetch-form-autocomplete", "update:applied-filters", "update:form-filter-values", "update:advanced-form-open"],
  setup() {
    const t = f(null), { announcement: e } = v(t);
    return {
      searchContainer: t,
      announcement: e
    };
  },
  data() {
    return {
      /**
       * internal variable to handle applied filters also when set from outside
       * @type {Filter[]}
       */
      appliedFiltersInt: [],
      /**
       * the filter used in the main search field - not added to applied filters yet
       * @type {Filter}
       */
      mainFilter: null,
      /**
       * store the autocomplete results for each filter in this variable to have
       * it available even when other filter was used in the meantime
       * @type {Object[]}
       */
      filtersAutocompleteResults: [],
      /**
       * a variable storing the info for which filter autocomplete results were
       * requested
       * @type {number}
       */
      autocompleteIndex: -1,
      originalMainFilter: null,
      /**
       * variable to control showing of advanced search form in mode 'form'
       * @type {boolean}
       */
      formOpen: !0,
      /**
       * internal representation of formFilterValues in order to be able to modify
       * @type {Object}
       */
      formFilterValuesInt: {},
      /**
       * store filter values to see if filter values changed before triggering search
       * @type {Object}
       */
      originalFilterValues: null,
      /**
       * render BaseForm with delay to reduce flickering and flinching
       * @type {boolean}
       */
      formMounted: !1,
      /**
       * resize observer for specific element (instead of window)
       * (only mode `form`)
       */
      resizeObserver: null,
      /**
       * button text should only be shown if enough space is available
       * (only mode `form`)
       */
      showAdvancedSearchButtonText: !0,
      /**
       * variable to contain assistive text to inform user of actions
       * @type {string}
       */
      assistiveTextNotification: ""
    };
  },
  computed: {
    amendedFormProps() {
      if (!this.interpretFormChipsLabelAsHtml)
        return this.formProps;
      const t = this.formProps.fieldProps || {}, e = this.renderFormChipsLabelAsHtml.reduce((s, i) => ({
        ...s,
        ...this.addNewPropertyValueToNestedObject(
          i,
          t || {},
          "interpretChipsLabelAsHtml",
          !0,
          // individually set fields should always have priority
          // over `interpretFormChipsLabelAsHtml`
          !1
        )
      }), {});
      return {
        // add all other specified form props
        ...this.formProps,
        // and the modified fieldprops
        fieldProps: {
          // also don't lose the field props of non-chips fields or not
          // modified ones
          ...t,
          // and add the modified ones
          ...e
        }
      };
    },
    /**
     * store the loading state of every filter
     *
     * @returns {boolean[]}
     */
    filtersLoadingState() {
      return [
        ...this.appliedFiltersInt.map((t, e) => this.autocompleteIndex === e),
        // add one at the end for main search field (not added to applied filters array yet)
        this.autocompleteIndex === this.appliedFiltersInt.length
      ];
    },
    /**
     * the actually displayed filter categories (visible in the filter drop down for mode 'list')
     * @returns {Filter[]}
     */
    displayedFilters() {
      const t = [...this.filterList].filter((e) => !e.hidden);
      return h(t, this.labelPropertyName.filter);
    },
    /**
     * main filter is always added to the emitted filter array last to maintain same order
     *  to what is rendered (main filter lowest) so we need to get the last filter index
     * @returns {number}
     */
    mainFilterIndex() {
      const t = this.appliedFilters.length - 1;
      return t > 0 ? t : 0;
    },
    /**
     * transform values to collapsed form and back
     */
    collapsedFiltersArray: {
      /**
       * use formFieldValuesInt to create the correct structure for BaseCollapsedFilterRow
       * @returns {{
         *  filter_values: { values: Object[], fieldType: string, fieldId: string },
         *  label: string,
         *  id: string,
       *  }[]}
       */
      get() {
        return Object.entries(this.formFilterValuesInt).filter(([, t]) => u(t)).sort(([t], [e]) => this.formFilterList[t] && this.formFilterList[e] && this.formFilterList[t]["x-attrs"].order > this.formFilterList[e]["x-attrs"].order ? 1 : -1).map(([t, e]) => {
          const s = this.formFilterList[t], i = s.type === "array" && !s["x-attrs"].field_type.includes("chips");
          return (i ? e : [e]).map((o, l) => ({
            // label that will be displayed on top of each collapsed filter
            labelInternal: s.title,
            // add a special id that allows to identify repeatable fields (applied in reverse mapping
            // ~line 555)
            idInternal: `${t}${i ? `-group-${l}` : ""}`,
            // the actual filter values and filter information for each field (important for field groups)
            filter_values: this.getCollapsedFilterValue(o, s, t)
          }));
        }).flat();
      },
      /**
       * maps changes that were made to collapsed filters back to formFilterValuesInt
       * @param {{ filter_values: Object[]|Object[[]], label: string, id: string, type: string|string[] }[]} val - changed collapsed filter values
       */
      set(t) {
        this.formFilterValuesInt = t.reduce((e, s) => {
          const [, i, r] = s.idInternal.match(/(.*?)(-group-\d*)?$/), o = this.formFilterList[i], l = this.setFormFilterValues(s.filter_values, o), a = r && e && e[i] ? e[i] : [];
          return {
            ...e,
            // if field is repeatable join the previous values with the new values otherwise just
            // set currently retrieved values
            [i]: r ? a.concat(l) : l
          };
        }, {}), this.search();
      }
    },
    renderFormChipsLabelAsHtml() {
      const { fieldProps: t } = this.formProps;
      if (!t)
        return this.interpretFormChipsLabelAsHtml;
      const e = this.filterHtmlRenderFields(this.formFilterList);
      return e.length ? e : this.interpretFormChipsLabelAsHtml;
    },
    /**
     * create an internal row id for unique identification of added filter rows
     *
     * @returns {string}
     */
    rowId() {
      return y();
    },
    /**
     * advanced button description for mode `form`
     * @returns {string}
     */
    advancedButtonDescription() {
      return this.assistiveText.advancedButtonDescription ? this.assistiveText.advancedButtonDescription.replace("{state}", this.assistiveText.formState[this.formOpen ? "close" : "open"]) : "";
    }
  },
  watch: {
    /**
     * watch prop autocompleteResults to assign it to the correct filter row
     */
    autocompleteResults(t) {
      this.autocompleteIndex >= 0 && (this.$set(this.filtersAutocompleteResults, this.autocompleteIndex, [...t]), this.autocompleteIndex = -1);
    },
    /**
     * have appliedFilters in sync with parent to be able to set them from outside
     */
    appliedFiltersInt: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.appliedFilters.slice(1)) && this.$emit("update:applied-filters", [...t, this.mainFilter]);
      },
      deep: !0
    },
    /**
     * have appliedFilters in sync with parent to be able to set them from outside
     */
    appliedFilters: {
      handler(t) {
        t && JSON.stringify(t.slice(0, -1)) !== JSON.stringify(this.appliedFiltersInt) && ([, ...this.appliedFiltersInt] = JSON.parse(JSON.stringify([t, ...t.slice(0, -1)]))), t && t.length >= 1 && JSON.stringify(this.mainFilter) !== JSON.stringify(t[this.mainFilterIndex]) ? [this.mainFilter] = JSON.parse(JSON.stringify(t.slice(-1))) : (!t || t < 1) && (this.mainFilter = { ...this.defaultFilter });
      },
      immediate: !0
    },
    /**
     * watch main filter since changes are not directly handled via update:applied-filters
     * event and trigger search if anything changed
     * @param {Filter} val - the updated main filter
     */
    mainFilter(t) {
      if (t && t.filter_values) {
        const e = u(t.filter_values), s = !!this.originalMainFilter && !!this.originalMainFilter.filter_values && u(this.originalMainFilter.filter_values);
        this.originalMainFilter && (e && this.originalMainFilter[this.identifierPropertyName.filter] !== t[this.identifierPropertyName.filter] || e !== s || e && s && JSON.stringify(this.originalMainFilter.filter_values !== JSON.stringify(t.filter_values))) && (this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter)), this.search(!0));
      }
      this.$emit("update:applied-filters", [...this.appliedFiltersInt, t]), this.$emit("update:form-filter-values", { ...this.formFilterValuesInt, default: this.mainFilter.filter_values });
    },
    /**
     * have formFilterValues in sync with parent to be able to set them from outside
     */
    formFilterValuesInt: {
      handler(t) {
        const e = { ...this.formFilterValues };
        this.$delete(e, "default"), JSON.stringify(t) !== JSON.stringify(e) && this.$emit("update:form-filter-values", { ...t, default: this.mainFilter.filter_values });
      },
      deep: !0
    },
    /**
     * have formFilterValues in sync with parent to be able to set them from outside
     */
    formFilterValues: {
      handler(t) {
        if (this.mode === "form" && t && JSON.stringify(t) !== JSON.stringify({
          ...this.formFilterValuesInt,
          default: this.mainFilter.filter_values
        })) {
          const { default: e, ...s } = t;
          this.formFilterValuesInt = JSON.parse(JSON.stringify(s)), this.$set(this.mainFilter, "filter_values", t.default || [""]), this.search();
        }
      },
      immediate: !0
    },
    advancedFormOpen: {
      handler(t) {
        this.formOpen = t;
      },
      immediate: !0
    },
    formOpen(t) {
      this.$emit("update:advanced-form-open", t);
    },
    /**
     * function to automatically reset the assistiveTextNotification
     * after using it
     * @param {string} val
     */
    assistiveTextNotification(t) {
      t && setTimeout(() => {
        this.assistiveTextNotification = "";
      }, 300);
    }
  },
  created() {
    this.mainFilter || (this.mainFilter = JSON.parse(JSON.stringify(this.defaultFilter))), this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));
  },
  mounted() {
    this.mode === "form" && this.initObserver();
  },
  beforeDestroy() {
    this.resizeObserver && this.resizeObserver.unobserve(this.$refs.searchContainer);
  },
  methods: {
    extractNestedPropertyValue: m,
    /**
     * GENERAL FUNCTIONALITIES
     */
    /**
     * initialize resize observer to steer advanced search button appearance
     */
    initObserver() {
      const t = new ResizeObserver(F(50, ([e]) => {
        this.showAdvancedSearchButtonText = e.contentRect.width >= 460;
      }));
      t.observe(this.$refs.searchContainer), this.resizeObserver = t;
    },
    /**
     * @param {string} input - the search string to autocomplete
     * @param {Filter} filter - the filter the autocomplete was triggered for
     * @param {number} index - the index of the filter
     */
    fetchAutocomplete({ input: t, filter: e }, s) {
      t ? this.autocompleteIndex = s : this.$set(this.filtersAutocompleteResults, s, []), this.$emit("fetch-autocomplete", { searchString: t, filter: e, index: s });
    },
    /**
     * search function
     * @param {boolean} alwaysTrigger - set true if search should be triggered irrespective of
     *  appliedFiltersInt changes (needed for changes in mainFilter which is checked in the
     *  mainFilter watcher already)
     */
    search(t = !1) {
      const e = this.mode === "form" ? this.formFilterList : this.filterList;
      let s = [];
      if (this.mode === "form" ? s = Object.entries(this.formFilterValuesInt).filter(([, i]) => u(i)).map(([i, r]) => {
        var o, l, a;
        return {
          [this.identifierPropertyName.filter]: i,
          type: ((l = (o = e[i]) == null ? void 0 : o["x-attrs"]) == null ? void 0 : l.field_type) ?? "text",
          // only keep filter values that actually have values (relevant for groups!)
          filter_values: typeof r == "object" && r.length && !((a = e[i]) != null && a.type.includes("chips")) ? r.filter((n) => u(n)) : r
        };
      }) : s = this.appliedFiltersInt.map((i) => ({
        [this.identifierPropertyName.filter]: i[this.identifierPropertyName.filter],
        type: i.type,
        filter_values: i.filter_values
      })), t || JSON.stringify(this.originalFilterValues) !== JSON.stringify(s)) {
        this.originalFilterValues = JSON.parse(JSON.stringify(s));
        const i = {
          [this.identifierPropertyName.filter]: this.mainFilter[this.identifierPropertyName.filter],
          type: this.mainFilter.type,
          filter_values: this.mainFilter.filter_values
        };
        this.$emit("search", [...s, i]);
      }
    },
    /**
     * MODE 'LIST' FUNCTIONALITIES
     */
    /**
     * function to add a filter row after '+' icon was triggered
     */
    addFilterRow({ filter: t, input: e }) {
      let s = t.type.includes("date") ? t.filter_values : [...t.filter_values], i = !1;
      t.type === "text" && e.trim() && (!t.filter_values || !t.filter_values.length || this.mainFilter.filter_values[0] !== e.trim()) ? (s = [e], i = !0) : t.type === "chips" && t.freetext_allowed && e.trim() && (s = [
        ...t.filter_values,
        {
          [this.labelPropertyName.autocompleteOption]: e
        }
      ], i = !0), this.appliedFiltersInt.push({
        ...t,
        filter_values: s
      }), this.mainFilter = {
        ...this.defaultFilter,
        filter_values: null
      }, this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter)), i && this.search(), this.$nextTick(() => {
        Array.from(this.$refs.mainSearch.$el.getElementsByTagName("input")).find((o) => o.id.includes("search-input")).focus();
      });
    },
    /**
     * remove filter after 'x' was triggered
     * @param {Filter} filter - the filter to remove
     * @param {number} index - the index of the filter
     */
    removeFilter(t, e) {
      this.appliedFiltersInt.splice(e, 1), this.search();
    },
    /**
     * for mode 'list'
     * function called when a filter object within a filter row changes
     * @param {Filter} filter - the filter that was altered
     * @param {number} index - the index of the filter
     */
    updateFilter(t, e) {
      this.$set(this.appliedFiltersInt, e, JSON.parse(JSON.stringify(t))), this.search();
    },
    /**
     * MODE 'FORM' FUNCTIONALITIES
     */
    /**
     * function called when an option was selected from main search autocomplete OR on
     *  search input TAB keydown
     *
     * @param {Object} entry - the selected option
     * @param {string} collectionId - the option category selected - this needs to match a
     *  formFilter id
     */
    fillOptionToForm({ entry: t, collectionId: e }) {
      var s, i;
      if (this.mode === "form" && e && !((s = this.formFilterValuesInt[e]) != null && s.map((r) => r[this.identifierPropertyName.formInputs]).includes(t[this.identifierPropertyName.autocompleteOption]))) {
        const r = this.formFilterList[e];
        if (r) {
          const o = r["x-attrs"];
          if (o.field_type === "chips") {
            const l = ((i = this.formProps.fieldProps) == null ? void 0 : i[e]) || {}, a = l.labelPropertyName || this.labelPropertyName.formInputs, n = l.identifierPropertyName || this.identifierPropertyName.formInputs, p = {
              // map search autocomplete result to chips form field required values
              [a]: t[this.labelPropertyName.autocompleteOption],
              [n]: t[this.identifierPropertyName.autocompleteOption],
              // HOWEVER - in order to enable customization of the properties used in the front
              // end - e.g. to add discriminatory terms html we also leave the rest of the
              // object properties and actually give them PRIORITY over the newly created ones!
              // (so e.g. if the property `displayLabel` was already added to the autocomplete option
              // with the appropriate tags and styling then this will not be overwritten by
              // entry[this.labelPropertyName.autocompleteOption] but be retained
              ...t
            };
            r.type === "array" ? this.formFilterValuesInt[e] ? this.formFilterValuesInt[e].push(p) : this.$set(this.formFilterValuesInt, e, [p]) : r.type === "object" && this.$set(this.formFilterValuesInt, e, p);
          } else
            (!o || o.field_type === "text") && this.$set(
              this.formFilterValuesInt,
              e,
              t[this.labelPropertyName.autocompleteOption] ?? t
            );
          if (this.mainFilter.filter_values = [], this.assistiveText.autocompleteOptionFilledToForm) {
            const l = t[this.labelPropertyName.autocompleteOption], a = r.title;
            this.announcement = this.assistiveText.autocompleteOptionFilledToForm.replace("{optionLabel}", l).replace("{fieldLabel}", a);
          }
          this.search();
        } else
          this.$set(
            this.mainFilter,
            "filter_values",
            [t]
          ), this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter)), this.search(!0);
      }
    },
    /**
     * function called from form if one of the form fields needs autocomplete
     *
     * @param {Object} params - see event for object properties sent to parent
     */
    fetchFormAutocomplete(t) {
      this.$emit("fetch-form-autocomplete", t);
    },
    /**
     * for mode 'form'
     * update the form filters when an event is received from form that values have changed
     * @param {Object} newFilterValueList - the new filter values object
     */
    updateFormFilters(t) {
      this.formFilterValuesInt = JSON.parse(JSON.stringify(t)), this.search();
    },
    /**
     * function called by BaseCollapsedFilter row if 'x' was clicked to remove all filters
     */
    removeAllFilters() {
      this.formFilterValuesInt = {}, this.assistiveTextNotification = this.assistiveText.collapsedFilterRowRemovedNotification || "", this.search();
    },
    /**
     * reduce the flickering and flinching from base form fields rendering by
     *  only making the element visible after component mount and additionally
     *  apply a timeout
     */
    formIsMounted() {
      setTimeout(() => {
        this.formMounted = !0;
      }, 200);
    },
    /**
     * function triggered when 'advanced search' button is clicked in 'form' mode
     */
    openAdvancedSearch() {
      this.$refs.mainSearch.isActive = !1, this.formOpen = !this.formOpen;
    },
    /**
     * function to retrieve the filter values in reduced form the way CollapsedFilterRow needs them
     * @param {any} values - the form field values
     * @param {Object} fieldData - the OpenAPI json field information
     * @param {string} fieldId - the id of the field to transform
     * @param {string[]} parentFields - if field is a field group we also need the parent field name(s)
     *  (in theory there could be many but BaseAdvancedSearch is currently only supporting one nesting level)
     * @returns {[string, unknown]|[{label: string}]|string|{label: *}[]|boolean[]|[{label: (string|string)}]|*}
     */
    getCollapsedFilterValue(t, e, s, i = []) {
      const r = e["x-attrs"].field_type;
      if (r === "integer" || r === "float" || typeof t == "number")
        return {
          values: [{
            labelInternal: t.toString()
          }],
          fieldId: s,
          fieldType: r
        };
      if (r === "boolean" || typeof t == "boolean")
        return {
          values: [{
            labelInternal: t
          }],
          fieldId: s,
          fieldType: r
        };
      if (r === "text" || r === "autocomplete" || typeof t == "string") {
        let o = t;
        return r === "date" && t && (o = this.formatToDisplayDate(t)), {
          values: [{
            // if fieldType is date convert to de date locale for display
            labelInternal: o
          }],
          fieldId: s,
          fieldType: r
        };
      }
      if (r === "chips") {
        const o = m(
          i.length ? [s].concat(i).join(".") : s,
          this.formProps.fieldProps
        ), l = (o == null ? void 0 : o.labelPropertyName) || this.labelPropertyName.formInputs, a = (o == null ? void 0 : o.identifierPropertyName) || this.identifierPropertyName.formInputs;
        return {
          values: t.map((n) => {
            const p = typeof n == "object" ? n : {};
            return {
              labelInternal: n[l] ?? n,
              idInternal: n[a] || "",
              ...p
            };
          }),
          fieldId: s,
          fieldType: r
        };
      }
      return r === "group" ? {
        values: Object.entries(t).reduce((o, [l, a]) => (o.push(this.getCollapsedFilterValue(
          a,
          // depending if group is repeatable or not get to properties attribute
          e.items ? e.items.properties[l] : e.properties[l],
          l,
          [l].concat(i)
        )), o), []),
        fieldType: r,
        fieldId: s
      } : r === "date" && typeof t != "string" ? {
        values: Object.values(t).map((o) => ({
          // convert to de date locale for display
          labelInternal: o ? this.formatToDisplayDate(o) : ""
        })),
        fieldId: s,
        // BaseCollapsedRow needs information if date is type daterange, timerange or datetime
        // so alter to 'date' and 'time' for daterange and timerange respectively and 'datetime'
        // for datetime.
        fieldType: Object.keys(t).reduce((o, l) => {
          const a = l.split("_")[0];
          return a !== o ? o + a : o;
        }, "")
      } : t;
    },
    formatToDisplayDate(t) {
      const { groups: { minus: e, year: s, month: i, day: r } = {} } = t.match(/((?<minus>-)?(?<year>\d{4})-?(?<month>\d{2})?-?(?<day>\d{2})?)/) || {};
      return s ? `${r ? `${r}.` : ""}${i ? `${i}.` : ""}${e || ""}${s}` : "";
    },
    formatToStorageDate(t) {
      const { groups: { minus: e, year: s, month: i, day: r } = {} } = t.match(/(?<day>\d{2})?\.?(?<month>\d{2})?\.?(?<minus>-)?(?<year>\d{4})/) || {};
      return s ? `${e || ""}${s}${i ? `-${i}` : ""}${r ? `-${r}` : ""}` : "";
    },
    /**
     * function to transform collapsed values to form field values (necessary if something changed
     * in collapsed values, e.g. a filter value was removed)
     * @param {{ values: Object[], fieldId: string, fieldType: string }} collapsedValues - the updated collapsed
     *  values coming from collapsed filter row
     * @param {Object} filterData - the relevant OpenAPI form field information
     * @param {string[]} parentFields - if field is a field group we also need the parent field name(s)
     *  (in theory there could be many but BaseAdvancedSearch is currently only supporting one nesting level)
     * @returns {any} - value returned depending on the filter type
     */
    setFormFilterValues(t, e, s = []) {
      const { values: i, fieldType: r, fieldId: o } = t;
      if (e.type === "string")
        return r === "date" ? this.formatToStorageDate(i[0].labelInternal) : i[0].labelInternal;
      if (e.type === "boolean")
        return i[0].labelInternal;
      if (e.type === "integer" || e.type === "float")
        return Number(i[0].labelInternal);
      if ((r.includes("date") || r.includes("time")) && e.type === "object") {
        const l = Object.keys(e.properties);
        return i.reduce((a, n, p) => ({
          ...a,
          [l[p]]: this.formatToStorageDate(n.labelInternal)
        }), {});
      }
      if (r.includes("chips")) {
        const l = m(
          s.length ? [o].concat(s).join(".") : o,
          this.formProps.fieldProps
        ), a = (l == null ? void 0 : l.labelPropertyName) || this.labelPropertyName.formInputs, n = (l == null ? void 0 : l.identifierPropertyName) || this.identifierPropertyName.formInputs;
        return i.filter((p) => !!p.labelInternal).map((p) => {
          const d = JSON.parse(JSON.stringify(p));
          return this.$delete(d, "labelInternal"), this.$delete(d, "idInternal"), {
            // and add it to the values that are returned
            ...d,
            // apart from the labelProperty and the identifierProperty
            [a]: p.labelInternal,
            [n]: p.idInternal
          };
        });
      }
      return !r.includes("chips") && e.type === "array" ? this.setFormFilterValues(
        t,
        e.items
      ) : r === "group" && e.type === "object" ? i.filter((l) => u(l.values)).reduce((l, a) => ({
        ...l,
        [a.fieldId]: this.setFormFilterValues(
          a,
          e.properties[a.fieldId],
          [a.fieldId].concat(s)
        )
      }), {}) : null;
    },
    filterHtmlRenderFields(t, e = []) {
      const { fieldProps: s } = this.formProps;
      return Object.entries(t).reduce((i, [r, o]) => {
        const { field_type: l } = o["x-attrs"] ? o["x-attrs"] : {};
        if (l === "group") {
          const a = this.filterHtmlRenderFields(
            o.properties || o.items.properties,
            [r].concat(e)
          );
          return a.length ? i.concat({
            [r]: a
          }) : i;
        }
        if (l === "chips") {
          const a = ((e.length ? m(e.join("."), s) : s) || {})[r];
          if (!this.interpretFormChipsLabelAsHtml && (a != null && a.interpretChipsLabelAsHtml) || this.interpretFormChipsLabelAsHtml && (!a || !Object.keys(a).includes("interpretChipsLabelAsHtml") || a.interpretChipsLabelAsHtml))
            return i.concat(r);
        }
        return i;
      }, []);
    },
    /**
     * a function to add a new property to a nested object
     *
     * @param {string|Object} renderProp - this is either a string - then an object
     *  with `previousFieldProps` and this property will be created, or an object in
     *  the style of { [parentProperty]: ['childProp1', 'childProp2'] } - this object
     *  can also be nested deeper - 'childProp2' could instead also be an object in the
     *  style above again
     * @param {Object} fieldProps - an object for all fields including `renderProp` that contains
     *  other properties `renderProp` or [renderProp.key] should receive
     *  so: { [renderProp]: { renderPropProperties } }
     * @param {string} propertyName - the name of the property to be added or overwritten
     * @param {*} propertyValue - the value of the property to be added or overwritten
     * @param {boolean} [overwritePreviousValues=true] - define if a preexisting value for
     *  `propertyName` should be overwritten
     * @returns {{[p: string]: *}|{}} - returns an object in the style
     *  { [renderProp|renderProp.key]: { ...previousFieldProps, [propertyName]: propertyValue }}
     *  or a deeper nested version thereof
     */
    addNewPropertyValueToNestedObject(t, e, s, i, r = !1) {
      if (typeof t == "string") {
        const o = e[t] || {};
        return {
          [t]: {
            // if previous values should be overwritten - place the add the previous
            // object properties first
            ...r ? o : {},
            [s]: i,
            // otherwise add them after the new property
            ...r ? {} : o
          }
        };
      }
      return typeof t == "object" ? Object.entries(t).reduce((o, [l, a]) => ({
        ...o,
        // add an object in the form of [formGroupPropertyName]: {},
        [l]: {
          // add all the field props that have been defined for that form group fields
          // previously
          ...e[l],
          // then overwrite form group fields that are defined in the renderProp array
          ...a.reduce((n, p) => ({
            ...n,
            // add property to fieldProps of this field
            ...this.addNewPropertyValueToNestedObject(
              p,
              e[l] || {},
              s,
              i
            )
          }), {})
        }
      }), {}) : {};
    }
  }
};
var x = function() {
  var e = this, s = e._self._c;
  return s("div", { ref: "searchContainer", staticClass: "base-advanced-search" }, [e.mode === "list" && e.appliedFiltersInt && e.appliedFiltersInt.length ? e._l(e.appliedFiltersInt, function(i, r) {
    return s("BaseAdvancedSearchRow", { key: "filter-" + r, staticClass: "base-advanced-search__filter-row", attrs: { mode: e.mode, "search-row-id": `${e.rowId}-${i[e.identifierPropertyName.filter]}-${r}`, "is-main-search": !1, "autocomplete-results": e.filtersAutocompleteResults[r], "filter-list": e.displayedFilters, "applied-filter": i, "is-loading": e.filtersLoadingState[r], "default-filter": e.defaultFilter, placeholder: e.placeholder.filterRow || e.placeholder, "autocomplete-property-names": e.autocompletePropertyNames, "label-property-name": e.labelPropertyName, "identifier-property-name": e.identifierPropertyName, "drop-down-info-texts": e.dropDownInfoTexts, "advanced-search-text": e.advancedSearchText, "assistive-text": {
      addFilter: e.assistiveText.addFilter,
      removeFilter: e.assistiveText.removeFilter,
      selectFilterLabel: e.assistiveText.selectFilterLabel,
      searchLabel: e.assistiveText.searchLabel,
      selectedOption: e.assistiveText.selectedOption,
      loaderActive: e.assistiveText.autocompleteLoaderActive,
      autocompleteResultsRetrieved: e.assistiveText.autocompleteResultsRetrieved,
      autocompleteNoResults: e.assistiveText.autocompleteNoResults,
      autocompleteInitial: e.assistiveText.autocompleteInitial,
      categoryAnnouncement: e.assistiveText.categoryAnnouncement,
      optionsAnnouncement: e.assistiveText.optionsAnnouncement
    }, "date-field-delay": e.dateFieldDelay, language: e.language, "highlight-autocomplete-match": e.highlightAutocompleteMatch, "highlight-autocomplete-tags": e.highlightAutocompleteTags }, on: { "remove-filter": function(o) {
      return e.removeFilter(o, r);
    }, "update:applied-filter": function(o) {
      return e.updateFilter(o, r);
    }, "fetch-autocomplete-results": function(o) {
      return e.fetchAutocomplete(o, r);
    } }, scopedSlots: e._u([{ key: "autocomplete-option", fn: function({ option: o, collectionId: l }) {
      return [e._t("autocomplete-option", null, { option: o, collectionId: l })];
    } }], null, !0) });
  }) : e._e(), s("BaseAdvancedSearchRow", e._g({ ref: "mainSearch", attrs: { "search-row-id": `main-${e.rowId}`, mode: e.mode, "applied-filter": e.mainFilter, "filter-list": e.displayedFilters, "form-filter-list": e.formFilterList, "default-filter": e.defaultFilter, "autocomplete-results": e.filtersAutocompleteResults[e.mainFilterIndex], "is-loading": e.filtersLoadingState[e.mainFilterIndex], placeholder: e.placeholder.main || e.placeholder, "autocomplete-property-names": e.autocompletePropertyNames, "label-property-name": e.labelPropertyName, "identifier-property-name": e.identifierPropertyName, "drop-down-info-texts": e.dropDownInfoTexts, "advanced-search-text": e.advancedSearchText, "assistive-text": {
    addFilter: e.assistiveText.addFilter,
    removeFilter: e.assistiveText.removeFilter,
    selectFilterLabel: e.assistiveText.selectFilterLabel,
    searchLabel: e.assistiveText.searchLabel,
    selectedOption: e.assistiveText.selectedOption,
    loaderActive: e.assistiveText.autocompleteLoaderActive,
    autocompleteResultsRetrieved: e.assistiveText.autocompleteResultsRetrieved,
    autocompleteNoResults: e.assistiveText.autocompleteNoResults,
    autocompleteInitial: e.assistiveText.autocompleteInitial,
    categoryAnnouncement: e.assistiveText.categoryAnnouncement,
    optionsAnnouncement: e.assistiveText.optionsAnnouncement,
    results: e.assistiveText.results
  }, "date-field-delay": e.dateFieldDelay, language: e.language, "highlight-autocomplete-match": e.highlightAutocompleteMatch, "highlight-autocomplete-tags": e.highlightAutocompleteTags }, on: { "update:appliedFilter": function(i) {
    e.mainFilter = i;
  }, "update:applied-filter": function(i) {
    e.mainFilter = i;
  }, "add-filter-row": e.addFilterRow, "fetch-autocomplete-results": function(i) {
    return e.fetchAutocomplete(i, e.mainFilterIndex);
  }, "option-selected": e.fillOptionToForm }, scopedSlots: e._u([{ key: "after", fn: function() {
    return [e.mode === "form" ? s("BaseButton", { class: [
      "base-advanced-search__expand-button",
      { "base-button-icon-rotate-180": e.formOpen }
    ], attrs: { text: e.showAdvancedSearchButtonText ? e.advancedSearchText.advancedButtonLabel : "", "aria-expanded": `${e.formOpen}`, "aria-controls": `${e.rowId}-form`, description: e.advancedButtonDescription, "button-style": "row", icon: "drop-down", "icon-size": "small", "icon-position": "right" }, nativeOn: { click: function(i) {
      return i.preventDefault(), i.stopPropagation(), e.openAdvancedSearch.apply(null, arguments);
    }, keydown: function(i) {
      return !i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter") && e._k(i.keyCode, "space", 32, i.key, [" ", "Spacebar"]) ? null : (i.preventDefault(), i.stopPropagation(), e.openAdvancedSearch.apply(null, arguments));
    }, focusin: function(i) {
      i.stopPropagation();
    } } }) : e._e()];
  }, proxy: !0 }, { key: "below", fn: function() {
    return [e.mode === "form" && e.formOpen ? s("BaseForm", e._b({ class: [
      "base-advanced-search__search-form",
      { "base-advanced-search__search-form--hidden": !e.formMounted }
    ], attrs: { id: `${e.rowId}-form`, "form-field-json": e.formFilterList, "value-list": e.formFilterValuesInt, "label-property-name": e.labelPropertyName.formInputs, "identifier-property-name": e.identifierPropertyName.formInputs }, on: { "input-complete": e.updateFormFilters, "fetch-autocomplete": e.fetchFormAutocomplete, "form-mounted": e.formIsMounted }, scopedSlots: e._u([{ key: "label-addition", fn: function({ fieldName: i, groupNames: r }) {
      return [e._t("form-label-addition", null, { fieldName: i, groupNames: r })];
    } }, { key: "pre-input-field", fn: function({ fieldName: i, groupNames: r }) {
      return [e._t("form-pre-input-field", null, { fieldName: i, groupNames: r })];
    } }, { key: "input-field-addition-before", fn: function({ fieldName: i, groupNames: r }) {
      return [e._t("form-input-field-addition-before", null, { fieldName: i, groupNames: r })];
    } }, { key: "input-field-inline-before", fn: function({ fieldName: i, groupNames: r }) {
      return [e._t("form-input-field-inline-before", null, { fieldName: i, groupNames: r })];
    } }, { key: "input-field-addition-after", fn: function({ fieldName: i, groupNames: r }) {
      return [e._t("form-input-field-addition-after", null, { fieldName: i, groupNames: r })];
    } }, { key: "post-input-field", fn: function({ fieldName: i, groupNames: r }) {
      return [e._t("form-post-input-field", null, { fieldName: i, groupNames: r })];
    } }, { key: "error-icon", fn: function() {
      return [e._t("form-error-icon")];
    }, proxy: !0 }, { key: "remove-icon", fn: function() {
      return [e._t("form-remove-icon")];
    }, proxy: !0 }, { key: "below-input", fn: function({ fieldName: i, groupNames: r }) {
      return [e._t("form-below-input", null, { fieldName: i, groupNames: r })];
    } }, { key: "drop-down-entry", fn: function({ option: i, fieldName: r, groupNames: o }) {
      return [e._t("form-drop-down-entry", function() {
        return [e.mode === "form" && (typeof e.renderFormChipsLabelAsHtml == "boolean" && e.renderFormChipsLabelAsHtml || typeof e.renderFormChipsLabelAsHtml == "object" && (e.renderFormChipsLabelAsHtml.includes(r) || o != null && o.length && e.renderFormChipsLabelAsHtml.some((l) => typeof l == "object" && e.extractNestedPropertyValue(o.join("."), l).includes(r)))) ? [s("span", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: {
          value: i[e.labelPropertyName.formInputs],
          interpretTextAsHtml: !0
        }, expression: `{
                  value: option[labelPropertyName.formInputs],
                  interpretTextAsHtml: true,
                }` }] })] : e._e()];
      }, { fieldName: r, groupNames: o, option: i })];
    } }], null, !0) }, "BaseForm", e.amendedFormProps, !1)) : e.mode === "form" && !e.formOpen && e.collapsedFiltersArray.length ? s("div", [s("BaseCollapsedFilterRow", { attrs: { filters: e.collapsedFiltersArray, "date-time-text": e.advancedSearchText.collapsedDateTime, "interpret-label-as-html": e.renderFormChipsLabelAsHtml, "assistive-text": {
      removeFiltersLabel: e.assistiveText.removeAllFiltersLabel,
      filterRemovedNotification: e.assistiveText.removeFilterValueNotification,
      appliedFiltersLabel: e.assistiveText.collapsedAppliedFiltersLabel,
      booleanFilterLabel: e.assistiveText.collapsedBooleanFilterValue,
      optionToRemoveSelected: e.assistiveText.collapsedOptionToRemoveSelected
    } }, on: { "update:filters": function(i) {
      e.collapsedFiltersArray = i;
    }, "remove-all": e.removeAllFilters } })], 1) : e._e()];
  }, proxy: !0 }, { key: "autocomplete-option", fn: function({ option: i, collectionId: r }) {
    return [e._t("autocomplete-option", function() {
      return [e.mode === "form" && (typeof e.renderFormChipsLabelAsHtml == "boolean" && e.renderFormChipsLabelAsHtml || typeof e.renderFormChipsLabelAsHtml == "object" && e.renderFormChipsLabelAsHtml.includes(r)) ? [s("span", { directives: [{ name: "insert-text-as-html", rawName: "v-insert-text-as-html", value: {
        value: i[e.labelPropertyName.autocompleteOption],
        interpretTextAsHtml: !0
      }, expression: `{
              value: autocompleteOption[labelPropertyName.autocompleteOption],
              interpretTextAsHtml: true,
            }` }] })] : e._e()];
    }, { option: i, collectionId: r })];
  } }], null, !0) }, e.$listeners)), e.assistiveTextNotification ? s("span", { staticClass: "assistive-text", attrs: { "aria-live": "assertive" } }, [e._v(" " + e._s(e.assistiveTextNotification) + " ")]) : e._e()], 2);
}, A = [], T = /* @__PURE__ */ N(
  O,
  x,
  A,
  !1,
  null,
  "a5184ef3",
  null,
  null
);
const $ = T.exports;
export {
  $ as default
};
//# sourceMappingURL=BaseAdvancedSearch.vue.es.js.map
