<!-- @author yanglan -->
<!-- @email yanglan@yangqianguan.com -->
<!-- @date 2018-04-28 13:03:29.047 -->
<!-- @desc generated by yqg-cli@0.1.0-beta.8 -->

<template>

    <div v-if="visible && inView" :class="{'in-dialog': isInBDialog}" class="b-popper-wrap">
        <div ref="popper" :name="name" class="b-popper">
            <slot></slot>
        </div>
    </div>

</template>

<script type="text/babel">

import BDialog from '../b-dialog';
import {isValidPlacement} from './helper/helper';


export default {
    name: 'BPopper',

    props: {
        name: {
            type: String,
            default: null
        },

        visible: {
            type: Boolean,
            default: false
        },

        placement: {
            type: String,
            validator: isValidPlacement,
            default: 'bottom-start'
        }
    },
    data() {
        return {
            inView: false
        };
    },
    computed: {
        isInBDialog() {
            const vm = this;

            let isInDialog = false;
            const rec = ({$parent}) => {
                if (!$parent) return;

                if ($parent.$options.name === BDialog.name) {
                    isInDialog = true;
                    return;
                }

                rec($parent);
            };

            rec(vm);

            return isInDialog;
        }
    },
    watch: {
        visible(val) {
            const vm = this;
            if (val) {
                vm.$nextTick(() => {
                    const {$el, $refs: {popper}} = vm;
                    if ($el.parentNode && popper) {
                        vm.makePosition($el.parentNode, $el, popper);
                    }
                });
            }
        }
    },
    mounted() {
        const io = new IntersectionObserver(([{isIntersecting}]) => {
            if (isIntersecting) {
                this.inView = isIntersecting;
                io.disconnect();
            }
        }, {
            delay: 1000,
            threshold: 1.0,
            trackVisibility: true
        });
        io.observe(this.$el.parentNode);
    },
    methods: {
        makePosition(ref, el, popper) {
            const vm = this;
            const {placement} = vm;

            const refRect = ref.getBoundingClientRect();
            const popperRect = popper.getBoundingClientRect();

            const left = 0; const top = 0;
            const TotalHeight = refRect.height + popperRect.height;
            const DiffWidth = refRect.width - popperRect.width;
            switch (placement) {
                case 'top-start': {
                    Object.assign(el.style, {
                        left: `${left}px`,
                        top: `${top - TotalHeight}px`
                    });
                    break;
                }
                case 'top': {
                    Object.assign(el.style, {
                        left: `${left + DiffWidth / 2}px`,
                        top: `${top - TotalHeight}px`
                    });
                    break;
                }
                case 'top-end': {
                    Object.assign(el.style, {
                        left: `${left + DiffWidth}px`,
                        top: `${top - TotalHeight}px`
                    });
                    break;
                }
                case 'right-start': {
                    Object.assign(el.style, {
                        left: `${left + refRect.width}px`,
                        top: `${top - refRect.height}px`
                    });
                    break;
                }
                case 'right': {
                    Object.assign(el.style, {
                        left: `${left + refRect.width}px`,
                        top: `${top - TotalHeight / 2}px`
                    });
                    break;
                }
                case 'right-end': {
                    Object.assign(el.style, {
                        left: `${left + refRect.width}px`,
                        top: `${top - popperRect.height}px`
                    });
                    break;
                }
                case 'bottom-start': {
                    Object.assign(el.style, {
                        left: `${left}px`,
                        top: `${top}px`
                    });
                    break;
                }
                case 'bottom': {
                    Object.assign(el.style, {
                        left: `${left + DiffWidth / 2}px`,
                        top: `${top}px`
                    });
                    break;
                }
                case 'bottom-end': {
                    Object.assign(el.style, {
                        left: `${left + DiffWidth}px`,
                        top: `${top}px`
                    });
                    break;
                }
                case 'left-start': {
                    Object.assign(el.style, {
                        left: `${left - popperRect.width}px`,
                        top: `${top - refRect.height}px`
                    });
                    break;
                }
                case 'left': {
                    Object.assign(el.style, {
                        left: `${left - popperRect.width}px`,
                        top: `${top - TotalHeight / 2}px`
                    });
                    break;
                }
                case 'left-end': {
                    Object.assign(el.style, {
                        left: `${left - popperRect.width}px`,
                        top: `${top - popperRect.height}px`
                    });
                    break;
                }
                default: {
                    Object.assign(el.style, {left: `${left}px`, top: `${top}px`});
                    break;
                }
            }
        }
    }
};
</script>
