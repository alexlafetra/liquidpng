import a from "vuedraggable";
import { createId as r, sort as o } from "../../utils/utils.es.js";
import d from "../BaseInput/BaseInput.vue.es.js";
import { ref as p } from "vue";
import { useAnnouncer as u } from "../../composables/useAnnouncer.es.js";
import c from "../../mixins/i18n.es.js";
import h from "../../mixins/navigateList.es.js";
import "./BaseChipsInputField.vue.es2.js";
import f from "../../_virtual/_plugin-vue2_normalizer.es.js";
const m = {
  name: "BaseChipsInputField",
  components: {
    BaseInput: d,
    BaseChip: () => import("../BaseChip/BaseChip.vue.es.js").then((t) => t.default || t),
    Draggable: a
  },
  mixins: [
    c,
    h
  ],
  model: {
    prop: "input",
    event: "input"
  },
  props: {
    /**
     if field is occurring more then once - set an id
     */
    id: {
      type: String,
      default: ""
    },
    /**
     * list of selected options (strings or objects - set `isStringArray` `true` if it is an array of strings),
     *  displayed as chips
     * (you can use the `.sync` modifier on this property)
     */
    selectedList: {
      type: Array,
      default: () => []
    },
    /**
     * input string
     */
    input: {
      type: String,
      default: ""
    },
    /**
     * specify input field type
     * @values text, search
     */
    inputType: {
      type: String,
      default: "text",
      validator: (t) => ["text", "search"].includes(t)
    },
    /**
     * input field label
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * define if label should be visible
     */
    showLabel: {
      type: Boolean,
      default: !0
    },
    /**
     * input field placeholder
     */
    placeholder: {
      type: String,
      default: null
    },
    /**
     * define if the user can add an option that is not in the list
     */
    // can the user add Entries that are not available in the vocabulary (selectable list)
    allowUnknownEntries: {
      type: Boolean,
      default: !0
    },
    /**
     * define only a single or multiple options can be selected
     */
    // define if one or several entries can be selected from drop down menu
    allowMultipleEntries: {
      type: Boolean,
      default: !0
    },
    /**
     * this means typed input will be added as chip directly
     */
    addSelectedEntryDirectly: {
      type: Boolean,
      default: !1
    },
    /**
     * if `true` a button with that functionality will be visible
     */
    sortable: {
      type: Boolean,
      default: !1
    },
    /**
     * define if chips should be draggable
     */
    draggable: {
      type: Boolean,
      default: !1
    },
    /**
     * define if entries should always appear linked (-> with grey background)
     */
    alwaysLinked: {
      type: Boolean,
      default: !1
    },
    /**
     * set content for the info box activatable by click.
     * see [BaseHoverBox](BaseHoverBox) for more details
     */
    hoverboxContent: {
      type: Object,
      default: () => ({})
    },
    /**
     * show spinner to indicate that something is loading
     * (for dynamically fetched entries that need to do backend requests)
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * if sorting is enabled this will be the text shown in the button
     */
    sortText: {
      type: String,
      default: "Sort A – Z"
    },
    /**
     * if `true` sorting will consider the last string in a label or if a comma is
     * present the string before the comma
     */
    sortName: {
      type: Boolean,
      default: !1
    },
    /**
     * set a language (ISO 639-1)
     */
    language: {
      type: String,
      default: ""
    },
    /**
     * option to have the border of the input field not displayed
     */
    showInputBorder: {
      type: Boolean,
      default: !0
    },
    /**
     * define if standard form field styling should be
     * used (otherwise no border, no box shadow)
     */
    useFormFieldStyling: {
      type: Boolean,
      default: !0
    },
    /**
     * specify the id of a linked drop down list
     */
    dropDownListId: {
      type: String,
      default: ""
    },
    /**
     * specify a linked list option (e.g. drop down)
     *   (will be used in `aria-activedescendant` attribute)
     */
    linkedListOption: {
      type: [Number, String],
      default: null
    },
    /**
     * specify the object property that should be used as identifier
     */
    identifierPropertyName: {
      type: String,
      default: ""
    },
    /**
     * specify the object property that should be used as value to be displayed
     */
    labelPropertyName: {
      type: String,
      default: "label"
    },
    /**
     * specify `true` if `selectedList` array is a array of strings
     */
    isStringArray: {
      type: Boolean,
      default: !1
    },
    /**
     * property for special case component [BaseChipsBelow](BaseChipsBelow) - if `false` in this case chips will
     * not be displayed in the input field
     */
    displayChipsInline: {
      type: Boolean,
      default: !0
    },
    /**
     * mark as required field (currently only used for aria-required)
     */
    required: {
      type: Boolean,
      default: !1
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field
     * for an example see [BaseInput](BaseInput)
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * set `true` if input field should be disabled
     * for an example see [BaseInput](BaseInput)
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * add an error message to be displayed below form field if field is invalid
     * for an example see [BaseInput](BaseInput)
     */
    errorMessage: {
      type: String,
      default: ""
    },
    /**
     * define if error icon should be shown
     * for an example see [BaseInput](BaseInput)
     */
    showErrorIcon: {
      type: Boolean,
      default: !0
    },
    /**
     * if `true` a remove icon will be shown allowing to remove
     * all input at once
     * for an example see [BaseInput](BaseInput)
     */
    clearable: {
      type: Boolean,
      default: !1
    },
    /**
     * if `true` space is reserved for a loader that can be activated
     * with the 'isLoading' prop
     */
    loadable: {
      type: Boolean,
      default: !1
    },
    /**
     * possibility to steer input field active state from outside
     * it is possible to use the `.sync` modifier here
     */
    isActive: {
      type: Boolean,
      default: !1
    },
    /**
     * specify additional input field styling
     */
    inputClass: {
      type: String,
      default: ""
    },
    /**
     * use this prop to deactivate automatic setting of focus as soon as input element
     * becomes active - this might require external handling of focus setting!
     */
    setFocusOnActive: {
      type: Boolean,
      default: !0
    },
    /**
     * define true if chip should be editable on click
     *
     * **Caveat**: chips can not be both draggable AND editable and it can not show
     *  `hoverBoxContent` as soon as it is editable respectively - if both are set `true` edit
     *  functionality takes precedent - chip will not be draggable, `hoverBoxContent` will not
     *  be shown!
     */
    chipsEditable: {
      type: Boolean,
      default: !1
    },
    /**
     * this prop gives the option to add assistive text for screen readers
     * properties:
     *
     * **selectedOption**: text read when a selected option is focused (currently only
     *  working for editable chips)
     * **loaderActive**: text that is announced when results are being fetched (prop
     *  `isLoading` is set `true`)
     * **optionAdded**: text read when option was added to the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     * **optionToRemoveSelected**: text read when option is marked active for removal (by using
     *  backspace in empty input field). string {label} could be added to be replaced
     *  by the actual chip label (value in [`labelPropertyName`])
     * **optionRemoved**: text read when option was removed from the selected list. string {label}
     *  could be added to be replaced by the actual chip label (value in [`labelPropertyName`])
     */
    assistiveText: {
      type: Object,
      default: () => ({
        selectedOption: "",
        loaderActive: "loading.",
        optionAdded: "option {label} added to selected list.",
        optionToRemoveSelected: "option {label} from selected list marked for removal. Press delete or backspace to remove.",
        optionRemoved: "option {label} removed."
      })
    },
    /**
     * define if selected options chips should come with a remove icon
     * (usually desired usability wise just an additional option for `allowMultipleEntries`
     * `false` if there is any other means of removal
     * (e.g. [BaseAdvancedSearch](#baseadvancedsearch)))
     */
    chipsRemovable: {
      type: Boolean,
      default: !0
    },
    /**
     * if necessary chip text can
     *  be rendered as v-html directive
     *
     *  **caveat**: setting this variable `true` can lead to XSS attacks. Only use
     *    this prop on trusted content and never on user-provided content. This is
     *    also why this will only take effect on selected chips with identifier (=selected
     *    from the options not a direct user input)
     */
    interpretChipsLabelAsHtml: {
      type: Boolean,
      default: !1
    }
  },
  setup() {
    const t = p(null), { announcement: e } = u(t);
    return {
      chipsInputField: t,
      announcement: e
    };
  },
  data() {
    return {
      /**
       * internal representation of selectedList
       * @type {(String[]|Object[])}
       */
      selectedListInt: [],
      /**
       * store active state of the base input field
       * @type {boolean}
       */
      isActiveInt: !1,
      /**
       * for removing chips via backspace, to get delay after
       * keydown event
       * @type {?number}
       */
      timeout: null,
      /**
       * for removing chips via backspace, to no accidentally delete
       * chips on multiple backspace keydown events
       * @type {boolean}
       */
      fired: !1,
      /**
       * for dragging functionality (transition)
       * @type {boolean}
       */
      drag: !1,
      /**
       * variable for the currently active chip (for arrow key use)
       * @type {number}
       */
      indexActiveForRemove: -1,
      /**
       * variable for internal input handling
       * @type {string}
       */
      inputInt: ""
    };
  },
  computed: {
    /**
     * if an id was not provided in props we create an internal id
     * @returns {string}
     */
    internalId() {
      return this.id || r();
    },
    inputListeners() {
      return {
        // add all the listeners from the parent
        ...this.$listeners,
        // keep this BaseInput event from propagating and use component's own event
        "update:is-active": () => {
        }
      };
    }
  },
  watch: {
    /**
     * selectedList is watched to also change selectedListInt if necessary
     * was thinking of making this a computed property however if you do
     * list manipulations (e.g. push, splice) the setter is not triggered
     * --> more complicated to inform parent (because sometimes setter triggered sometimes not)
     */
    selectedList: {
      handler(t) {
        if (t) {
          const e = t.map((n) => ({
            ...this.isStringArray ? { [this.labelPropertyName]: n } : n,
            idInt: n[this.identifierPropertyName] || this.getIdInt(n)
          }));
          JSON.stringify(e) !== JSON.stringify(this.selectedListInt) && (this.selectedListInt = e);
        } else
          this.selectedListInt = [];
      },
      deep: !0,
      immediate: !0
    },
    /**
     * to have isActive prop in sync
     * @param {boolean} val - internal input field active value
     */
    isActiveInt(t) {
      this.$emit("update:is-active", t);
    },
    /**
     * watch for outside changes in the input field active state
     * @param {boolean} val - the prop value set from outside
     */
    isActive: {
      handler(t) {
        t !== this.isActiveInt && (this.isActiveInt = t);
      },
      immediate: !0
    },
    /**
     * also input needs to be synchronized between component and parent (if necessary)
     */
    input: {
      handler(t) {
        t !== this.inputInt && (this.inputInt = t);
      },
      immediate: !0
    },
    /**
     * watch if input changes internally and emit event if necessary
     */
    inputInt: {
      handler(t) {
        t !== this.input && this.$emit("input", t);
      },
      immediate: !0
    }
  },
  methods: {
    /** KEYBOARD HANDLING FOR CHIPS */
    /**
     * function triggered on any keydown on the input field
     * @param {KeyboardEvent} event
     */
    checkKeyEvent(t) {
      const { key: e } = t;
      if ((e === "Tab" && !(this.clearable && this.inputInt) || e === "Enter" && !this.allowMultipleEntries) && (this.isActiveInt = !1), this.chipsRemovable && (e === "Backspace" || e === "Delete"))
        e === "Backspace" && !this.fired && !this.inputInt && this.indexActiveForRemove < 0 ? this.indexActiveForRemove = this.selectedListInt.length - 1 : this.indexActiveForRemove >= 0 && !this.fired && !this.inputInt && (this.removeEntry(
          this.selectedListInt[this.indexActiveForRemove],
          this.indexActiveForRemove
        ), this.indexActiveForRemove = -1), this.fired = !0, this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.timeout = setTimeout(() => {
          this.fired = !1;
        }, 200);
      else if (!this.inputInt && (t.key === "ArrowRight" || t.key === "ArrowLeft")) {
        const n = t.key === "ArrowRight", i = this.navigate(
          this.selectedListInt,
          n,
          this.indexActiveForRemove,
          !0
        );
        this.indexActiveForRemove = this.selectedListInt.indexOf(i);
      } else
        this.indexActiveForRemove = -1;
      this.indexActiveForRemove >= 0 && (this.announcement = this.assistiveText.optionToRemoveSelected.replace("{label}", this.selectedListInt[this.indexActiveForRemove][this.labelPropertyName]));
    },
    /** LIST MODIFICATIONS */
    /**
     * remove an entry from the list of selected entries
     *
     * @param {Object} option - the option selected from the list of selected
     * options
     * @param {number} index - the index of the item in the list
     */
    removeEntry(t, e) {
      const n = this.selectedListInt[e][this.labelPropertyName];
      this.selectedListInt.splice(e, 1), this.updateParentList(this.selectedListInt), this.$emit("removed", t);
      const i = this.$refs.baseInput.$el.getElementsByTagName("input"), s = Array.from(i).find((l) => l.id === this.internalId);
      s && s.click(), setTimeout(() => {
        this.announcement = this.assistiveText.optionRemoved.replace("{label}", n);
      }, 1e3);
    },
    /**
     * adding an selected option to the array of selected options
     */
    addOption() {
      if (this.inputInt && this.allowUnknownEntries && this.addSelectedEntryDirectly) {
        const t = this.selectedListInt.find((e) => e[this.labelPropertyName] === this.inputInt);
        if (t)
          this.$emit("duplicate", t);
        else {
          const e = this.allowMultipleEntries ? this.selectedListInt.length : 0, n = {
            idInt: this.getIdInt(),
            [this.labelPropertyName]: this.inputInt
          };
          this.$set(this.selectedListInt, e, n), this.updateParentList(this.selectedListInt), this.announcement = this.assistiveText.optionAdded.replace("{label}", this.inputInt);
        }
        this.inputInt = "";
      }
    },
    modifyListEntry(t, e) {
      typeof this.selectedListInt[e][this.labelPropertyName] == "object" && this.selectedListInt[e][this.labelPropertyName][this.language] !== void 0 ? this.selectedListInt[e] = {
        [this.labelPropertyName]: {
          [this.language]: t
        }
      } : typeof this.selectedListInt[e][this.labelPropertyName] == "string" && (this.selectedListInt[e] = {
        [this.labelPropertyName]: t
      }), this.updateParentList(this.selectedListInt);
    },
    /**
     * function called when parent needs to be informed of selected
     * list changes
     *
     * @param {Object[]} newSelectedListInt - the altered list of selected options
     */
    updateParentList(t) {
      let e = JSON.parse(JSON.stringify(t));
      this.isStringArray ? e = e.map((n) => n[this.labelPropertyName]) : t.length && (e = e.map((n) => (this.$delete(n, "idInt"), n))), this.$emit("update:selected-list", e);
    },
    /**
     * every selected option needs an internal id to be uniquely identifyable
     * by draggablejs
     *
     * @param {Object} [option=null] - the option the internal id is determined for
     */
    getIdInt(t = null) {
      if (t) {
        const e = this.selectedListInt.find((n) => n[this.labelPropertyName] === t[this.labelPropertyName] || n[this.labelPropertyName] === t);
        if (e)
          return e.idInt;
      }
      return r();
    },
    /** SORTING */
    /** function called when the 'sort' button is clicked */
    sortSelectedList() {
      this.isActiveInt = !1, o(
        this.selectedListInt,
        this.labelPropertyName,
        this.sortName,
        this.language ? this.getLangLabel : null
      ), this.updateParentList(this.selectedListInt);
    },
    /** DRAGGABLE FUNCTIONALITIES */
    /**
     * need to set custom due to some strange effects not showing correct element in some cases
     * @param {DataTransfer} dataTransfer
     * @param {HTMLElement} dragEl - the dragged HTML Element
     */
    setDragElement(t, e) {
      const n = e.cloneNode(!0);
      n.id = "chip-inline-drag", n.style.position = "absolute", n.style.top = "-99999px", n.style.left = "-99999px", document.body.appendChild(n), t.setDragImage(n, 0, 0);
    },
    onDragEnd() {
      this.drag = !1;
      const t = document.getElementById("chip-inline-drag");
      t && t.parentNode.removeChild(t), JSON.stringify(this.selectedList) !== JSON.stringify(this.selectedListInt) && this.updateParentList(this.selectedListInt);
    },
    /** HOVER BOX FUNCTIONALITY */
    /**
     * function triggered when a chip is clicked and hover box functionality is
     * available
     * @param {boolean} value - should hover box be showing or not
     * @param {Object} option - the option on which click was made
     */
    hoverBoxActive(t, e) {
      this.$emit("hoverbox-active", { value: t, option: e });
    }
  }
};
var y = function() {
  var e = this, n = e._self._c;
  return n("div", { ref: "chipsInputField", staticClass: "base-chips-input-field" }, [n("BaseInput", e._g({ ref: "baseInput", attrs: { id: e.internalId, "field-type": e.inputType, placeholder: e.allowMultipleEntries || !e.selectedListInt.length ? e.placeholder : "", label: e.label, "show-label": e.showLabel, "show-input-border": e.showInputBorder, "is-active": e.isActiveInt, "use-form-field-styling": e.useFormFieldStyling, "drop-down-list-id": e.dropDownListId, "linked-list-option": e.linkedListOption, "hide-input-field": !e.allowMultipleEntries && !!e.selectedListInt.length, invalid: e.invalid, required: e.required, disabled: e.disabled, clearable: e.clearable, loadable: e.loadable, "error-message": e.errorMessage, "show-error-icon": e.showErrorIcon, "is-loading": e.isLoading, "input-class": e.inputClass, "set-focus-on-active": e.setFocusOnActive, "assistive-text": {
    loaderActive: e.assistiveText.loaderActive
  } }, on: { "update:isActive": function(i) {
    e.isActiveInt = i;
  }, "update:is-active": function(i) {
    e.isActiveInt = i;
  }, keydown: [function(i) {
    return !i.type.indexOf("key") && e._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : (i.preventDefault(), e.addOption.apply(null, arguments));
  }, e.checkKeyEvent] }, scopedSlots: e._u([{ key: "label-addition", fn: function() {
    return [e._t("label-addition"), e.sortable ? n("button", { staticClass: "base-chips-input-field__sort", attrs: { "aria-label": `${e.label}. ${e.sortText.replace(/[—–-]/, "to")}`, type: "button" }, on: { click: function(i) {
      return e.sortSelectedList(e.selectedListInt);
    } } }, [e._v(" " + e._s(e.sortText) + " ")]) : e._e()];
  }, proxy: !0 }, { key: "pre-input-field", fn: function() {
    return [e._t("pre-input-field")];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [e._t("input-field-addition-before"), e.displayChipsInline ? n("div", { staticClass: "base-chips-input-field__chips" }, [e.draggable && !e.chipsEditable ? [n("draggable", { attrs: { "set-data": e.setDragElement, "force-fallback": !0, animation: 200, handle: ".base-chip__text" }, on: { start: function(i) {
      e.drag = !0;
    }, end: e.onDragEnd }, model: { value: e.selectedListInt, callback: function(i) {
      e.selectedListInt = i;
    }, expression: "selectedListInt" } }, [n("transition-group", { staticClass: "base-chips-input-field__chips-transition", attrs: { name: e.drag ? null : "flip-list", type: "transition" } }, [e._l(e.selectedListInt, function(i, s) {
      return [e._t("chip", function() {
        return [n("BaseChip", { key: e.allowMultipleEntries ? "chip-" + i.idInt : s, attrs: { id: i.idInt, entry: e.getLangLabel(i[e.labelPropertyName], !0), "hover-box-content": e.hoverboxContent, "is-linked": e.alwaysLinked || i[e.identifierPropertyName] === 0 || !!i[e.identifierPropertyName], "chip-active": e.indexActiveForRemove === s, "is-removable": e.chipsRemovable, "interpret-text-as-html": e.interpretChipsLabelAsHtml && !!i[e.identifierPropertyName] }, on: { "remove-entry": function(l) {
          return e.removeEntry(i, s);
        }, "hoverbox-active": function(l) {
          return e.hoverBoxActive(l, i);
        } } })];
      }, null, {
        entry: i,
        index: s,
        indexActiveForRemove: e.indexActiveForRemove,
        removeEntry: e.removeEntry
      })];
    })], 2)], 1)] : [e._l(e.selectedListInt, function(i, s) {
      return [e._t("chip", function() {
        return [n("BaseChip", { key: e.allowMultipleEntries ? "chip-" + i.idInt : s, attrs: { id: i.idInt, entry: e.getLangLabel(i[e.labelPropertyName], !0), "hover-box-content": e.hoverboxContent, editable: e.chipsEditable, "is-linked": e.alwaysLinked || i[e.identifierPropertyName] === 0 || !!i[e.identifierPropertyName], "chip-active": e.indexActiveForRemove === s, "assistive-text": e.assistiveText.selectedOption, "is-removable": e.chipsRemovable, "interpret-text-as-html": e.interpretChipsLabelAsHtml && !!i[e.identifierPropertyName] }, on: { "remove-entry": function(l) {
          return e.removeEntry(i, s);
        }, "value-changed": function(l) {
          return e.modifyListEntry(l, s);
        }, "hoverbox-active": function(l) {
          return e.hoverBoxActive(l, i);
        } } })];
      }, null, {
        entry: i,
        index: s,
        indexActiveForRemove: e.indexActiveForRemove,
        removeEntry: e.removeEntry
      })];
    })]], 2) : e._e()];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [e._t("input-field-inline-before")];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [e._t("input-field-addition-after")];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [e._t("post-input-field")];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [e._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [e._t("remove-icon")];
  }, proxy: !0 }, { key: "below-input", fn: function() {
    return [e._t("below-input")];
  }, proxy: !0 }], null, !0), model: { value: e.inputInt, callback: function(i) {
    e.inputInt = i;
  }, expression: "inputInt" } }, e.inputListeners))], 1);
}, v = [], b = /* @__PURE__ */ f(
  m,
  y,
  v,
  !1,
  null,
  "77085512",
  null,
  null
);
const N = b.exports;
export {
  N as default
};
//# sourceMappingURL=BaseChipsInputField.vue.es.js.map
