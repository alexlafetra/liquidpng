{"version":3,"file":"BaseDateInput.vue.cjs.js","sources":["../../../src/components/BaseDateInput/BaseDateInput.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"baseDateInput\"\n    class=\"base-date-input\">\n    <div\n      v-if=\"showLabelRow\"\n      :class=\"['base-date-input__label-row',\n               { 'base-date-input__label-row--visible': showLabel }]\">\n      <legend\n        v-if=\"showLabel\"\n        ref=\"label\"\n        class=\"base-date-input__label\"\n        @click.prevent=\"\">\n        {{ label }}\n      </legend>\n      <div\n        :class=\"['base-date-input__label-additions',\n                 {'base-date-input__label-additions--switch-height': isSwitchableFormat },\n                 {'base-date-input__label-additions--wrap': wrapLabelRow }]\">\n        <div\n          ref=\"labelAdditions\"\n          :class=\"['base-date-input__label-additions-inner',\n                   {'base-date-input__label-additions-inner--switch': isSwitchableFormat },\n                   {'base-date-input__label-additions-inner--no-label-switch': isSwitchableFormat\n                     && !showLabel }]\">\n          <!-- @slot to add additional elements to the label row -->\n          <slot name=\"label-addition\" />\n          <BaseSwitchButton\n            v-if=\"isSwitchableFormat\"\n            v-model=\"dateFormatInt\"\n            :options=\"tabSwitchOptions\"\n            :label=\"formatTabsLegend\"\n            :active-tab=\"dateFormatInt\"\n            class=\"base-date-input__switch-buttons\" />\n        </div>\n      </div>\n    </div>\n\n    <!-- FORM FIELDS -->\n    <!-- keydown event is counter productive to workflow here -->\n    <!-- eslint-disable-next-line vuejs-accessibility/click-events-have-key-events -->\n    <div\n      v-click-outside=\"clickedOutside\"\n      class=\"base-date-input__field-wrapper\"\n      @click=\"clickedInside\">\n      <!-- @slot to add elements within form field but before the input element line for an example see [BaseInput](BaseInput)-->\n      <slot name=\"pre-input-field\" />\n      <div class=\"base-date-input__input-fields\">\n        <!-- @slot add elements within input form field but before all other elements - this field wraps if necessary for an example see [BaseInput](BaseInput) -->\n        <slot name=\"input-field-addition-before\" />\n        <div class=\"base-date-input__input-line\">\n          <!-- @slot add elements directly in the input line (no wrapping) for an example see [BaseInput](BaseInput)-->\n          <slot name=\"input-field-inline-before\" />\n          <!-- INPUT FROM -->\n          <BaseInput\n            :id=\"`input-${internalId}-from`\"\n            v-model=\"inputFrom\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"fromOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :input-class=\"inputClass\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutFrom\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('from', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputFrom\"\n                  :placeholder=\"isFromTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"fromOpen\"\n                  :type=\"isFromTimeField ? 'time' : minDateView\"\n                  :format=\"isFromTimeField ? 'HH:mm' : datePickerValueFormat\"\n                  :value-type=\"isFromTimeField ? 'format' : datePickerValueFormat\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('from')\"\n                  @click.native.prevent=\"onInputClick\"\n                  @change=\"isFromTimeField ? closeTimePicker('from', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                    component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"`input-${internalId}-from`\"\n                      ref=\"inputFrom\"\n                      :value=\"inputFrom\"\n                      :placeholder=\"isFromTimeField ? placeholder.time ?? placeholder\n                        : placeholder.date ?? placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-' + internalId\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      enterkeyhint=\"done\"\n                      autocomplete=\"off\"\n                      @input=\"checkDate($event, 'From')\"\n                      @keydown=\"handleInputKeydown($event, 'From')\"\n                      @blur=\"onInputBlur($event, 'from')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of datepicker\n                  is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                ref=\"baseIcon\"\n                :name=\"isFromTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"fromOpen = !fromOpen\" />\n            </template>\n          </BaseInput>\n\n          <span\n            v-if=\"type === 'daterange' || type === 'timerange'\"\n            class=\"base-date-input__separator\">{{ rangeSeparator }}</span>\n\n          <!-- INPUT TO -->\n          <BaseInput\n            v-if=\"type !== 'single'\"\n            :id=\"`input-${internalId}-to`\"\n            v-model=\"inputTo\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"toOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutTo\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('to', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputTo\"\n                  :placeholder=\"isToTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"toOpen\"\n                  :type=\"isToTimeField ? 'time' : minDateView\"\n                  :format=\"isToTimeField ? 'HH:mm' : datePickerValueFormat\"\n                  :value-type=\"isToTimeField ? 'format' : datePickerValueFormat\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('to')\"\n                  @click.native.prevent=\"onInputClick\"\n                  @change=\"isToTimeField ? closeTimePicker('to', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                      component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"`input-${internalId}-to`\"\n                      ref=\"inputTo\"\n                      :value=\"inputTo\"\n                      :placeholder=\"isToTimeField ? placeholder.time ?? placeholder\n                        : placeholder.date ?? placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-to-' + internalId\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      enterkeyhint=\"done\"\n                      autocomplete=\"off\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      @input=\"checkDate($event, 'To')\"\n                      @keydown=\"handleInputKeydown($event, 'To')\"\n                      @blur=\"onInputBlur($event, 'to')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of\n                  datepicker is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                :name=\"isToTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"toOpen = !toOpen\" />\n            </template>\n          </BaseInput>\n        </div>\n      </div>\n      <!-- @slot for adding elements after input -->\n      <slot name=\"post-input-field\" />\n    </div>\n\n    <div class=\"base-date-input__below\">\n      <!-- @slot to add elements below input fields e.g. add drop down -->\n      <slot name=\"below-input\" />\n    </div>\n  </div>\n</template>\n\n<script>\nimport ClickOutside from 'vue-click-outside';\nimport DatePicker from 'vue2-datepicker';\nimport { capitalizeString, createId, debounce } from '@/utils/utils';\n\nimport en from 'vue2-datepicker/locale/en';\nimport de from 'vue2-datepicker/locale/de';\nimport fr from 'vue2-datepicker/locale/fr';\n\nimport BaseInput from '@/components/BaseInput/BaseInput';\nimport BaseIcon from '@/components/BaseIcon/BaseIcon';\n\n/**\n * Form Input Field Component for Date, Date - Date, Date - Time, or Time - Time\n *\n * for date also a format switch between date | year is available\n *\n */\n\nexport default {\n  name: 'BaseDateInput',\n  components: {\n    BaseInput,\n    BaseIcon,\n    BaseSwitchButton: () => import('@/components/BaseSwitchButton/BaseSwitchButton').then(m => m.default || m),\n    DatePicker,\n  },\n  directives: {\n    ClickOutside,\n  },\n  model: {\n    prop: 'input',\n    event: 'selected',\n  },\n  props: {\n  /**\n   * select date or datetime or a range\n   */\n    type: {\n      type: String,\n      default: 'single',\n      validator(val) {\n        return ['daterange', 'datetime', 'single', 'timerange'].includes(val);\n      },\n    },\n    /**\n     * input field settable from outside.\n     *   attention: if this is an object it needs to contain all the\n     *   properties (e.g. date_from, time_to) already otherwise only\n     *   a string will be returned\n     */\n    input: {\n      type: [Object, String, Date],\n      required: true,\n    },\n    /** label for input field, required for usability purposes, handle\n     * showing of label with property showLabel\n     */\n    label: {\n      type: String,\n      required: true,\n    },\n    /**\n     * defines if input label should be visible\n     */\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * set a placeholder for the input field (object with date and time attribute respectively)\n     */\n    placeholder: {\n      type: [Object, String],\n      default: () => ({ date: 'Select Date', time: 'Select Time' }),\n    },\n    /**\n     * define the range separator\n     */\n    rangeSeparator: {\n      type: String,\n      default: 'â€“',\n    },\n    /**\n     * specify date format.\n     *\n     *  **date_year**: display tabs that allow for toggle between only choosing year\n     *   or complete date\n     *  **date_month_year**: display tabs that allow for toggle between choosing only year,\n     *   year and month or complete date\n     */\n    format: {\n      type: String,\n      default: 'day',\n      validator(val) {\n        return ['day', 'month', 'year', 'date_year', 'date_month_year'].includes(val);\n      },\n    },\n    /**\n     * specify labels displayed instead of 'DD.MM.YYYY' and 'YYYY'\n     *   should have the form `{ date: 'xxx', month: 'zzz', year: 'yyy' }`\n     */\n    dateFormatLabels: {\n      type: Object,\n      default: () => ({ date: 'DD.MM.YYYY', month: 'MM.YYYY', year: 'YYYY' }),\n      validator(val) {\n        const labelKeys = Object.keys(val);\n        return labelKeys.includes('date') && labelKeys.includes('year');\n      },\n    },\n    /**\n     * a legend for the date format switch buttons\n     */\n    formatTabsLegend: {\n      type: String,\n      default: 'Switch between date formats',\n    },\n    /**\n     * set calendar language (ISO 639-1).\n     * **caveat**: currently only `en`, `de` and `fr` are supported\n     *  @values de, en, fr\n     */\n    language: {\n      type: String,\n      default: 'en',\n      validator: val => ['de', 'en', 'fr'].includes(val),\n    },\n    /**\n     * set id\n     */\n    id: {\n      type: [Number, String],\n      default: '',\n    },\n    /**\n     * define if standard form field styling should be\n     * used (otherwise no border, no box shadow)\n     */\n    useFormFieldStyling: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * option to have the border of the input field not displayed\n     */\n    showInputBorder: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * mark as required field (currently only used for aria-required)\n     */\n    required: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * mark the form field as invalid and ideally also provide an error message\n     * to display below the form field\n     * for an example see [BaseInput](BaseInput)\n     */\n    invalid: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set `true` if input field should be disabled\n     * for an example see [BaseInput](BaseInput)\n     */\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * add an error message to be displayed below form field if field is invalid\n     * for an example see [BaseInput](BaseInput)\n     */\n    errorMessage: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define if error icon should be shown\n     * for an example see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once\n     * for an example see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * specify additional input field styling\n     */\n    inputClass: {\n      type: String,\n      default: '',\n    },\n    /**\n     * use this prop to deactivate automatic setting of focus as soon as input element\n     * becomes active - this might require external handling of focus setting!\n     */\n    setFocusOnActive: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * in order to be able to set input field active state from outside\n     */\n    isActive: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * use this prop to set a delay in ms before calender is displayed\n     */\n    isActiveDelay: {\n      type: Number,\n      default: 0,\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal input representation with all possible values for\n       * date and time\n       * @typedef {Object} inputInt\n       * @property {string} inputInt.date - attribute a single date or datetime date is stored in\n       * @property {string} inputInt.date_from - storing daterange from\n       * @property {string} inputInt.date_to - storing daterange to\n       * @property {string} inputInt.time - storing the time for datetime type\n       * @property {string} inputInt.time_from - storing timerange from\n       * @property {string} inputInt.time_to - storing timerange to\n       */\n      inputInt: {\n        date: '',\n        date_from: '',\n        date_to: '',\n        time: '',\n        time_from: '',\n        time_to: '',\n      },\n      /**\n       * variable for toggling format between date and year for date_year format\n       * @type {string}\n       */\n      dateFormatInt: '',\n      /**\n       * variable to store the date when switching from date to year in order to be\n       * able to restore exact date when switching back\n       * @type {inputInt}\n       */\n      tempDateStore: {},\n      /**\n       * to steer closing of datepicker from input field once date is selected\n       * @type {boolean}\n       */\n      fromOpen: false,\n      /**\n       * to steer closing of datepicker to input field once date is selected\n       * @type {boolean}\n       */\n      toOpen: false,\n      /**\n       * variable to keep active state in sync with potential parent prop\n       * (this is needed as independent variable from toOpen and fromOpen for example in\n       * BaseAdvancedSearchRow to keep dropdown open even if datepicker is closed)\n       */\n      isActiveInt: false,\n      /**\n       * variable to steer if input fade out of from field should be shown\n       * @type {boolean}\n       */\n      useFadeOutFrom: false,\n      /**\n       * variable to steer if input fade out of to field should be shown\n       * @type {boolean}\n       */\n      useFadeOutTo: false,\n      /**\n       * variable to steer if icons should be shown (becoming false if not enough\n       * space)\n       * @type {boolean}\n       */\n      showIcons: true,\n      /**\n       * variable to store icon size which is calculated in the beginning and might be\n       * hidden later\n       * @type {number}\n       */\n      iconSize: 24,\n      /**\n       * Resize Observer to trigger fade out calculations when component is resized\n       * @type {?ResizeObserver}\n       */\n      resizeObserver: null,\n      /**\n       * function needs to be triggered when date switch is populated\n       * @type {?ResizeObserver}\n       */\n      labelAdditionsObserver: null,\n      /**\n       * datepicker localisations\n       *   using object fixes problem of missing localisation files in rollup-esm-build\n       */\n      lang: {\n        de,\n        en,\n        fr,\n      },\n      /**\n       * variable to set css class according to label elements wrapping or not\n       * @type {boolean}\n       */\n      wrapLabelRow: false,\n    };\n  },\n  computed: {\n    internalId() {\n      return this.id || createId();\n    },\n    /**\n     * this is the format we want to store computed based on what\n     * was specified in format and what date toggle tabs (via dateFormatInt) might say\n     * TODO: check if this is still needed with custom input\n     * @returns {string}\n     */\n    datePickerValueFormat() {\n      if (this.format === 'year' || this.dateFormatInt === 'YYYY') {\n        // use single letter for year here to allow negative dates\n        return 'Y';\n      }\n      if (this.format === 'month' || this.dateFormatInt === 'MM.YYYY') {\n        // use single letter for year here to allow negative dates\n        return 'MM.Y';\n      }\n      // use single letter for year here to allow negative dates\n      return 'DD.MM.Y';\n    },\n    /**\n     * if the format is settable this.format is date_year and can not be\n     * used directly for the date picker component\n     * @returns {string}\n     */\n    minDateView() {\n      if (this.isSwitchableFormat && this.dateFormatInt === 'YYYY') {\n        return 'year';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'MM.YYYY') {\n        return 'month';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'DD.MM.YYYY') {\n        return 'day';\n      }\n      return this.format;\n    },\n    /**\n     * compute the properties of the object provided in input prop\n     * @returns {string[]}\n     */\n    inputProperties() {\n      // if input is object return those keys // else for a single date it\n      // could also be a string - then just return an empty array\n      return typeof this.input === 'object' ? Object.keys(this.input) : [];\n    },\n    /**\n     * check if input is just a single date or an object\n     * @returns {boolean}\n     */\n    isInputTypeString() {\n      return typeof this.input === 'string' || !this.inputProperties.length;\n    },\n    /**\n     * handle input for the 'from' input field\n     */\n    inputFrom: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string} - a date in the format DD.MM.YYYY\n       */\n      get() {\n        // if it is a time field just return the time_from value\n        if (this.isFromTimeField) {\n          return this.inputInt.time_from;\n        }\n        // else it is a date (either single or date_from) --> convert it into the\n        // correct format for display (DD.MM.YYYY instead of the saved DD-MM-YYY)\n        return this.parseToDateDisplay(this.inputInt.date || this.inputInt.date_from);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       * @param {string} oldValue - the previous value of inputFrom\n       */\n      set(val, oldValue) {\n        let newDate = val;\n        if (this.isFromTimeField) {\n          this.inputInt.time_from = newDate;\n        } else {\n          newDate = this.parseToDateStorage(val);\n          if (this.inputProperties.includes('date_from')) {\n            this.inputInt.date_from = newDate;\n          } else {\n            this.inputInt.date = newDate;\n          }\n        }\n        // watching of computed values does not work so emit event for altered inputInt right here\n        // the actual value is not needed here since data were transformed and\n        // original object structure with correct data is retrieved with function getInputData\n        if (newDate !== oldValue) {\n          this.emitData();\n        }\n      },\n    },\n    /**\n     * as above - if there is only a single time field get value from 'time' variable\n     * if it is a range use 'time_to''\n     */\n    inputTo: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string}\n       */\n      get() {\n        // check if a to time field exists\n        if (this.isToTimeField) {\n          // return the appropriate attribute value\n          return this.inputInt.time || this.inputInt.time_to;\n        }\n        // else return the date_to attribute value\n        return this.parseToDateDisplay(this.inputInt.date_to);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       * @param {string} oldValue - the previous value of inputTo\n       */\n      set(val, oldValue) {\n        let newValue = val;\n        // check if field is date field\n        if (!this.isToTimeField) {\n          newValue = this.parseToDateStorage(newValue);\n          // if so, set date_to attribute value and transform value appropriately\n          // TODO: this could be insufficient since currently no validity checks on input string\n          this.inputInt.date_to = newValue;\n          // else check if type is timerange\n        } else if (this.inputProperties.includes('time_from')) {\n          this.inputInt.time_to = newValue;\n          // else assume the type is datetime\n        } else {\n          this.inputInt.time = newValue;\n        }\n        // watching of computed values does not work so emit event for altered inputInt right here\n        // the actual value is not needed here since data were transformed and\n        // original object structure with correct data is retrieved with function getInputData\n        if (newValue !== oldValue) {\n          this.emitData();\n        }\n      },\n    },\n    /**\n     * determine if the initially provided date is a year or a full date\n     * (used to set the correct date display format and date/year switch button)\n     * @returns {boolean}\n     */\n    isDateFormatYear() {\n      return (this.isInputTypeString && this.inputInt.date\n          && /^(-?[0-9]{1,4}|-[0-9]{0,4})$/.test(this.inputInt.date))\n        || (this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key] && /^(-?[0-9]{1,4}|-[0-9]{0,4})$/.test(this.inputInt[key])));\n    },\n    isDateFormatMonth() {\n      return ((this.isInputTypeString && this.inputInt.date\n          && /^(-?[0-9]{1,4}|-[0-9]{0,4})-[0-1]?[0-9]$/.test(this.inputInt.date))\n        || this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key]\n          && /^(-?[0-9]{1,4}|-[0-9]{0,4})-[0-1]?[0-9]$/.test(this.inputInt[key])));\n    },\n    /**\n     * check if format switch tabs should be shown\n     * @returns {boolean}\n     */\n    isSwitchableFormat() {\n      return this.format === 'date_month_year' || this.format === 'date_year';\n    },\n    /**\n     * return the format options for date, month, year switches\n     * @returns {[{label: string, value: string}]}\n     */\n    tabSwitchOptions() {\n      // minimal options\n      const options = [\n        { label: this.dateFormatLabels.date, value: 'DD.MM.YYYY' },\n        { label: this.dateFormatLabels.year, value: 'YYYY' },\n      ];\n      // if format can be month as well, add month option\n      if (this.format === 'date_month_year') {\n        options.splice(1, 0, {\n          label: this.dateFormatLabels.month,\n          value: 'MM.YYYY',\n        });\n      }\n      return options;\n    },\n    /**\n     * determine if the from field is a time field\n     * @returns {boolean}\n     */\n    isFromTimeField() {\n      return this.type === 'timerange';\n    },\n    /**\n     * determine if the to field is a time field\n     * @returns {boolean}\n     */\n    isToTimeField() {\n      return this.type === 'datetime' || this.type === 'timerange';\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    inputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // and add custom listeners\n        ...{\n          // stop these BaseInput originating events to substitute them with the\n          // correct events in search container element\n          'clicked-outside': (event) => {\n            event.stopPropagation();\n          },\n          // need to stop the event triggered in original BaseInput and only trigger\n          // when component isActiveInt has changed\n          'update:is-active': () => {},\n          // stop BaseInput input event since BaseDateInput will propagate their own\n          input: () => {},\n        },\n      };\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    dateInputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // stop native input event here and emit own event (in inputInt watcher)\n        // with just the values\n        input: () => {},\n      };\n    },\n    /**\n     * check if label-addition slot exists is filled\n     */\n    labelRowSlotsHaveData() {\n      // get label-addition slot\n      const slotElements = this.$slots['label-addition'];\n      // check if slot exists and has data and actually has content\n      // (this did not work with SSR otherwise...)\n      return !!slotElements && !!slotElements.length\n        && slotElements.some(elem => elem.tag || elem.text?.trim());\n    },\n    /**\n     * determines if label row should be shown\n     * @returns {Boolean|boolean}\n     */\n    showLabelRow() {\n      // show label when prop is set true or a label addition was added via slot\n      return this.showLabel || this.isSwitchableFormat || this.labelRowSlotsHaveData;\n    },\n  },\n  watch: {\n    inputInt: {\n      handler() {\n        /**\n         * Event emitted on input, passing input string\n         *\n         * @event input\n         * @param {string} - the input event value however\n         * passing only the event.target.value\n         *\n         */\n        this.$emit('input', this.getInputData());\n      },\n      deep: true,\n    },\n    /**\n     * watch format and set correct dateFormat\n     */\n    format: {\n      handler(val) {\n        if (val === 'year') {\n          this.dateFormatInt = 'YYYY';\n          return;\n        }\n        if (val === 'month') {\n          this.dateFormatInt = 'MM.YYYY';\n          return;\n        }\n        this.dateFormatInt = 'DD.MM.YYYY';\n      },\n      immediate: true,\n    },\n    /**\n     * watch input set from outside and set internal inputInt accordingly as well as\n     * set the correct display format\n     */\n    input: {\n      handler(val) {\n        // check if input string is different from inputInt\n        if (JSON.stringify(val) !== JSON.stringify(this.getInputData())) {\n          const isDateTimeField = this.type === 'datetime';\n          this.inputFrom = isDateTimeField\n            ? val.date : val.date ?? val.date_from ?? val.time ?? val.time_from ?? val ?? '';\n          this.inputTo = isDateTimeField ? val.time : val.date_to ?? val.time_to ?? '';\n          // check if external input was year format and set internal format accordingly\n          if (this.isSwitchableFormat) {\n            if (this.isDateFormatYear) {\n              this.dateFormatInt = 'YYYY';\n            } else if (this.isDateFormatMonth) {\n              this.dateFormatInt = 'MM.YYYY';\n            } else {\n              this.dateFormatInt = 'DD.MM.YYYY';\n            }\n          }\n        }\n      },\n      // to not need to do extra assignment in created()\n      immediate: true,\n    },\n    /**\n     * in order to allow user to restore previous date after switching\n     * from date to year and back store in temp variable (but only if previous date was full date\n     * (check necessary for starting with year where format is switched to 'YYYY'\n     * but no previous full date avaliable))\n     * @param {string} val - the changed dateFormatInt value\n     * @param {string} old - the previous value\n     */\n    dateFormatInt(val, old) {\n      // in order to allow user to restore previous date after switching\n      // from date to year and back store in temp variable if\n      // a) date is not just format 'YYYY' & switch was made from full date\n      if (!this.isDateFormatYear && old === 'DD.MM.YYYY') {\n        this.tempDateStore = { ...this.inputInt };\n        // b) tab switch was made from month to year\n      } else if (!this.isDateFormatYear\n        && (val === 'YYYY' && old === 'MM.YYYY')) {\n        // if there is no previous stored date just store everything\n        if (!this.tempDateStore) {\n          this.tempDateStore = { ...this.inputInt };\n          // if there was a previous stored date check for every date prop in inputInt\n          // if stored date should be overwritten\n        } else {\n          Object.keys(this.inputInt).filter(key => !!key.includes('date'))\n            .forEach((dateKey) => {\n              // date should be overwritten if month or year are different from\n              // the already stored date\n              if (!this.monthAndYearIdent(\n                // check if the positive dates are identical\n                this.removeYearMinusFromStorageDate(this.inputInt[dateKey], old),\n                (/^-/.test(this.tempDateStore[dateKey]) ? this.tempDateStore[dateKey].replace('-', '') : this.tempDateStore[dateKey]),\n                // and also check if the operator in front of year is identical\n              ) && this.isNegativeStorageDate(this.inputInt[dateKey], old)\n                === /^-/.test(this.tempDateStore[dateKey])) {\n                this.$set(this.tempDateStore, dateKey, this.inputInt[dateKey]);\n              }\n            });\n        }\n      }\n      this.convertDate(old);\n      // since inputInt is manipulated directly in this case (easier with Date conversions)\n      // inputFrom and inputTo setters are not triggered and we need to emit the new data manually\n      this.emitData();\n    },\n    /**\n     * watch for changes in input field active variable to keep in sync with parent\n     * @param {boolean} val - the changed internal is active variable\n     */\n    isActiveInt(val) {\n      /**\n       * replace BaseInput state with BaseDateInput field active state and\n       * propagate this one\n       *\n       * @event update:is-active\n       * @param {boolean} - is input field active\n       */\n      this.$emit('update:is-active', val);\n    },\n    /**\n     * also adjust internal variable when active state changes from outside\n     * @param {boolean} val - the changed isActive prop\n     */\n    isActive: {\n      handler(val) {\n        if (val !== this.isActiveInt) {\n          this.isActiveInt = val;\n          // if is active is set from outside also open the first date field\n          this.fromOpen = val;\n        }\n        // if isActive is set false from outside also close date picker\n        if (!val) {\n          this.fromOpen = false;\n          this.toOpen = false;\n        }\n      },\n      immediate: true,\n    },\n  },\n  mounted() {\n    if (this.$refs.baseIcon) {\n      this.iconWidth = this.$refs.baseIcon.$el.clientWidth;\n    }\n    // initialize the resize observer to calculate fade out and label row when component is resized\n    this.initObservers();\n  },\n  updated() {\n    // this hack is necessary because otherwise keyboard navigation was impaired by the datepicker\n    // pop up elements\n    // check if datepicker element is actually open\n    if (this.fromOpen || this.toOpen) {\n      // wait until elements are rendered\n      this.$nextTick(() => {\n        // get all focusable elements that have the 'mx-' in the class name\n        // had to add 'div's as well because of some strange effect in Firefox\n        const keyboardfocusableElements = [...this.$el.querySelectorAll(\n          'div, a, button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])',\n        )]\n          .filter(el => !el.hasAttribute('disabled'))\n          .filter(el => el.className.includes('mx-'));\n        // iterate through the elements and add tabindex -1\n        keyboardfocusableElements.forEach((element) => {\n          element.setAttribute('tabindex', -1);\n        });\n      });\n    }\n  },\n  beforeDestroy() {\n    if (this.resizeObserver) this.resizeObserver.disconnect();\n    if (this.labelAdditionsObserver) this.labelAdditionsObserver.disconnect();\n  },\n  methods: {\n    /**\n     * since the complete datepicker lies within the BaseInput, the BaseInput click event\n     *  is triggered also when a date is picked from the date picker - this leads to the undesired\n     *  side effect that the date picker pop up is reopened when a date was selected there\n     *  therefore we only allow the click event to pass on when the user clicks on the input field\n     *  DIRECTLY\n     * @param {PointerEvent} event - the native click event\n     */\n    onInputClick(event) {\n      if (event.target.tagName !== 'INPUT') {\n        event.stopPropagation();\n      }\n    },\n    /**\n     * in general input field active styling is handled via focusin and\n     * clicked-outside, however for special case iOS touch  devices have\n     * up and down arrows that do not trigger any event other than blur and will\n     * cause the dropdowns of input fields to remain open\n     * @param {FocusEvent} event - the native blur event\n     * @param {string} origin - did event emit from 'from' or 'to' date field\n     */\n    onInputBlur(event, origin) {\n      const relatedTargetInput = event.relatedTarget?.parentElement ? event.relatedTarget.parentElement\n        .getElementsByTagName('input') : null;\n      // so since these arrows only navigate between input fields we check if there is a\n      // related target and if this related target is an input field and if yes we make sure\n      // the id is different from the input id of this component (the one the event originated from)\n      if (event.relatedTarget\n        && ((event.relatedTarget.tagName === 'INPUT'\n            && (!event.relatedTarget?.id || event.relatedTarget.id !== event.target.id))\n          // additionally also set input active false when the BaseInput 'remove' button\n          // (displayed if `clearable` is true) is triggered in the other date field of the range\n          || (event.relatedTarget?.className === 'base-input__remove-icon-wrapper'\n            && relatedTargetInput && relatedTargetInput[0]?.id !== event.target.id))) {\n        // set input active state false\n        this[`${origin}Open`] = false;\n      }\n    },\n    initObservers() {\n      // create an observer with the fade out calc function\n      const tempResizeObserver = new ResizeObserver(debounce(50, () => {\n        if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n          this.calcLabelAdditionsWidth();\n        }\n        this.calcFadeOut(['From', 'To']);\n      }));\n      // put it on the relevant element\n      tempResizeObserver.observe(this.$refs.baseDateInput);\n      // store it in variable\n      this.resizeObserver = tempResizeObserver;\n\n      if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n        // second observer to trigger label additions width calc as soon as element is rendered\n        const tempLabelAdditionsObserver = new ResizeObserver(debounce(50, (entries, observer) => {\n          // only do calc when element is filled\n          if (entries[0].contentRect.width > 0) {\n            this.calcLabelAdditionsWidth(this.$refs.baseDateInput.clientWidth);\n            // only do this once as soon as elements are rendered - then disconnect!\n            observer.disconnect();\n          }\n        }));\n        tempLabelAdditionsObserver.observe(this.$refs.labelAdditions);\n        this.labelAdditionsObserver = tempLabelAdditionsObserver;\n      }\n    },\n    /**\n     * transform the date to the correct display format\n     * @param {string} dateString - the date string in YYYY-MM-DD format\n     */\n    parseToDateDisplay(dateString) {\n      // if no date string was provided just return an empty string\n      if (!dateString) return '';\n      // now check if year is negative\n      const isNegativeYear = this.isNegativeStorageDate(dateString);\n      // if so, create a positive date string\n      const positiveDateString = isNegativeYear\n        ? this.removeYearMinusFromStorageDate(dateString) : dateString;\n      // now do the transformation and add the minus to the year again if necessary\n      return this.addYearMinusToDateDisplay(\n        positiveDateString.split('-').reverse().join('.'),\n        isNegativeYear,\n      );\n    },\n    /**\n     * transform the date to the correct storage format\n     * @param {string} dateString - the date string in DD.MM.YYYY format\n     */\n    parseToDateStorage(dateString) {\n      return dateString ? dateString.split('.').reverse().join('-') : '';\n    },\n    /**\n     * checks done on keydown events\n     * a) tab key needs separate handling and only needs to set input field close when\n     * there is no clearable button (or shift key was used for going to previous field)\n     * b) prevent user from entering chars other than number or period (date) or colon (time)\n     * and not more characters than the date format requires\n     * @param {KeyboardEvent} event - the keydown event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    handleInputKeydown(event, origin) {\n      let currentInputString = event.target.value;\n      // get the key triggering the event\n      const { key } = event;\n      // now check for the specific input key to preventDefault and prevent unwanted\n      // characters\n      // create boolean to determine if it is a time field (otherwise date is assumed)\n      const isTimeField = this.isTimeInputField(origin);\n      // if time ':' is allowed in input regex - otherwise '.'\n      const allowedFieldKey = isTimeField ? ':' : '\\\\.';\n      // check if '-' should be an allowed key\n      let allowMinus = false;\n      if ((this.dateFormatInt === 'DD.MM.YYYY' && /^\\d{2}\\.\\d{2}\\.\\d{0,4}$/.test(currentInputString))\n        || (this.dateFormatInt === 'MM.YYYY' && /^\\d{2}\\.\\d{0,4}$/.test(currentInputString))\n        || (this.dateFormatInt === 'YYYY' && /^\\d{0,4}$/.test(currentInputString))) {\n        allowMinus = true;\n      }\n      // create regex for allowed keys\n      const allowedKeysRegex = new RegExp(`([0-9${allowMinus ? '-' : ''}]|${allowedFieldKey}|Backspace|Delete|Tab|Enter|ArrowRight|ArrowLeft)`);\n      // create regex that should not be allowed if max length is reached\n      const disallowedKeysOnLengthRegex = new RegExp(`([0-9]|${allowedFieldKey})`);\n      // get the max length for the respective format (for time: 'HH:mm' = 5)\n      // also check for a minus\n      let formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n      if (!isTimeField && this.isNegativeDisplayDate(currentInputString)) {\n        // add one extra to formatLength for the '-' if date is negative\n        formatLength += 1;\n      }\n      // check if\n      // * key was not any of the allowed keys\n      // * or was an allowed key but the length is to long for the format in\n      //    question (and no text was selected = will be replaced)\n      // * if type is date and key was period and date format is year or last char in string was\n      //    already a period\n      // * if type is time and key was colon and last char was already a colon\n      // * and also make sure copy & paste is allowed!\n      if ((!allowedKeysRegex.test(key)\n        || (disallowedKeysOnLengthRegex.test(key) && currentInputString.length >= formatLength\n          && document.activeElement.selectionEnd - document.activeElement.selectionStart === 0)\n        || (!isTimeField && key === '.' && (this.dateFormatInt === 'YYYY'\n          || currentInputString.charAt(currentInputString.length - 1) === '.'))\n        || (isTimeField && key === ':' && currentInputString.charAt(currentInputString.length - 1) === ':'))\n        && !(['c', 'v', 'x'].includes(key) && event.ctrlKey)) {\n        event.preventDefault();\n      }\n      // when the user tries to leave the field check if input string is valid\n      if (key === 'Enter') {\n        this.checkDateValidity(origin);\n        currentInputString = this[`input${origin}`];\n      }\n      // check if key was tab because of reasons specified above and close picker if necessary\n      if (key === 'Enter' || (key === 'Tab' && (event.shiftKey || !this.clearable\n        || !currentInputString))) {\n        // if yes set the relevant input field open status to false\n        this[`${origin.charAt(0).toLowerCase()}${origin.slice(1)}Open`] = false;\n      }\n    },\n    /**\n     * this function is triggered with the input event - it checks the length of the value and\n     * adds the '.' (date) or (':') or '0' in the correct places or removes '-' that was added at\n     * a wrong position if necessary\n     * @param {InputEvent} event - the input event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDate(event, origin) {\n      // get the value in question\n      let modifiedValue = event.target.value;\n      // this is a workaround necessary because of the manual input event triggered in BaseInput\n      // (~line 610) but since input has not changed with this event we can easily filter it out\n      // by only applying the operations if input has changed\n      if (modifiedValue === this[`input${origin}`]) return;\n      // otherwise continue to check the input\n      // determine if input is coming from a time or date field\n      const isTimeField = this.isTimeInputField(origin);\n      // depending on that different characters need to be added\n      const charToAdd = isTimeField ? ':' : '.';\n      // check if value is present and if input type is other than 'deleteContentBackward' because\n      // otherwise the dots can not be deleted anymore\n      if (modifiedValue && event.inputType !== 'deleteContentBackward') {\n        // remove a non-matching '-' character\n        if (modifiedValue !== '-' && !this.isNegativeDisplayDate(modifiedValue)) {\n          modifiedValue = modifiedValue.replace('-', '');\n        }\n        // now check the date format and if input so far matches the appropriate regex\n        if ((!isTimeField && this.dateFormatInt === 'DD.MM.YYYY' && /^(\\d{2}$|\\d{2}\\.\\d{2})$/.test(modifiedValue))\n            || ((this.dateFormatInt === 'MM.YYYY' || isTimeField) && /^\\d{2}$/.test(modifiedValue))) {\n          // if so - add a period character\n          modifiedValue = `${modifiedValue}${charToAdd}`;\n        }\n        const firstTwoDigitsRegex = new RegExp(`^[1-9]${isTimeField ? ':' : '\\\\.'}$`);\n        // check if input was a period - if yes - check date validity and add zeros if necessary\n        if (firstTwoDigitsRegex.test(modifiedValue)) {\n          modifiedValue = `0${modifiedValue}`;\n        } else if (/^\\d{2}\\.\\d\\.$/.test(modifiedValue)) {\n          const [day, month, year] = modifiedValue.split('.');\n          modifiedValue = `${day}.0${month}.${year}`;\n        }\n      }\n      this[`input${origin}`] = modifiedValue;\n    },\n    /**\n     * this function is triggered with the blur event on the input and does a last check on the\n     * validity of the value\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDateValidity(origin) {\n      // important and mostly different checks to make depending if value is date or time\n      // so save that in variable\n      const isTimeField = this.isTimeInputField(origin);\n      // since Date() has problems with negative dates just remove the '-' and add it again after!\n      let positiveDate = this.removeYearMinusFromDisplayDate(this[`input${origin}`]);\n      // check if there is a value present\n      if (positiveDate) {\n        // also save the current format length\n        const formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n        // get the separator depending on time or date field\n        const separator = isTimeField ? ':' : '.';\n        // get the array length of array with string split up by separator (should be same for\n        // format and value string)\n        const numberFormatParts = isTimeField ? 2 : this.dateFormatInt.split('.').length;\n        // first check if periods (date) or colons (time) are too many\n        if (positiveDate.split(separator).length > numberFormatParts) {\n          // just remove all the periods or colons - there the next check will add some again\n          positiveDate = positiveDate.replaceAll('.', '');\n        }\n        // check if there are too little separators\n        if (numberFormatParts > positiveDate.split(separator).length) {\n          // check if day and month (for DDMMYYYY) or month and year (for MMYYYY) or time\n          // are without period or colon respectively\n          if (formatLength !== 4 && /^\\d{3}/.test(positiveDate)) {\n            // this assumes the first two digits are for day or month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            positiveDate = `${positiveDate.slice(0, 2)}${separator}${positiveDate.slice(2, positiveDate.length)}`;\n          }\n          // check if there is a second period between month and year (for DDMMYYYY)\n          if (this.dateFormatInt === 'DD.MM.YYYY' && formatLength !== 4 && /^\\d{2}\\.\\d{3}/.test(positiveDate)) {\n            // this assumes there are two digits for day and month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            positiveDate = `${positiveDate.slice(0, 5)}.${positiveDate.slice(5, positiveDate.length)}`;\n          }\n        }\n        // second check if the length of the value is correct\n        if (positiveDate.length !== formatLength) {\n          // distinguish between date and time string\n          if (isTimeField) {\n            // check if minutes are missing\n            if (/^\\d{1,2}:?$/.test(positiveDate)) {\n              const [hours] = positiveDate.split(':');\n              positiveDate = `${hours}:00`;\n            }\n            // check if zeros out front are missing from hour\n            if (/^\\d:\\d{1,2}$/.test(positiveDate)) {\n              const [hours, minutes] = positiveDate.split(':');\n              positiveDate = `0${hours}:${minutes}`;\n            }\n            // check if zeros out front are missing from minute\n            if (/^\\d{2}:\\d$/.test(positiveDate)) {\n              const [hours, minutes] = positiveDate.split(':');\n              positiveDate = `${hours}:0${minutes}`;\n            }\n          } else {\n            // first check reason for length mismatch is year is\n            // completely missing for date format\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^\\d{1,2}\\.\\d{1,2}\\.?(\\d{0,3})$/.test(positiveDate)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [day, month, year] = positiveDate.split('.');\n              if (!year) {\n                // repair date and add the year if it is missing\n                positiveDate = `${day}.${month}.${currentYear}`;\n                // else assume there are digits missing from the year and add 0\n              } else {\n                positiveDate = `${day}.${month}.${year.padStart(4, '0')}`;\n              }\n            }\n            // for month format\n            if (this.dateFormatInt === 'MM.YYYY' && /^\\d{1,2}\\.?(\\d{0}|\\d{2})$/.test(positiveDate)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [month, year] = positiveDate.split('.');\n              // repair date and add first two year digits - if date more than 10 years to the\n              // future - make it current century - otherwise last century\n              const century = (currentYear).toString().slice(0, 2);\n              positiveDate = `${month}.${year > (currentYear + 10).toString().slice(2, 4)\n                ? Number(century - 1) : century}${year || currentYear.toString().slice(2, 4)}`;\n            }\n            // second check if the reason for the length not matching is that the day is\n            // missing a zero\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^[1-9]\\.\\d{1,2}\\.\\d{4}$/.test(positiveDate)) {\n              // get the values\n              const [day, month, year] = positiveDate.split('.');\n              // repair date and add a zero to day\n              positiveDate = `0${day}.${month}.${year}`;\n            }\n            // second check if the reason for mismatching length is that the zero in month\n            // is missing\n            if (['DD.MM.YYYY', 'MM.YYYY'].includes(this.dateFormatInt) && /^\\d{2}?\\.?[1-9]\\.\\d{4}$/.test(positiveDate)) {\n              // get values, reverse in order to be able to get also correct values for format\n              // 'month'\n              const [year, month, day] = positiveDate.split('.').reverse();\n              // repair date and add missing zero to month\n              positiveDate = `${day}.0${month}.${year}`;\n            }\n            // if format is year assume there are zeros in the year missing\n            if (this.dateFormatInt === 'YYYY') {\n              positiveDate = `${positiveDate.padStart(4, '0')}`;\n            }\n          }\n          // now check if time/date has now the correct length - if not still remove the value\n          if (positiveDate.length !== formatLength) {\n            positiveDate = '';\n          }\n        }\n        // now check for general validity\n        if (isTimeField) {\n          // just add random date to see if time is valid\n          if (Number.isNaN(Date.parse(`1212-12-12T${positiveDate}`))) {\n            let [hours, minutes] = positiveDate.split(':');\n            // check if valid hours\n            if (!/^([0-1][0-9]|2[0-4])$/.test(hours)) {\n              hours = '00';\n            }\n            // check if valid minutes\n            if (!/^[0-5][0-9]$/.test(minutes)) {\n              minutes = '00';\n            }\n            // construct a new time\n            const newTime = `${hours}:${minutes}`;\n            // now check again if time is valid now if yes assign, if no delete the string\n            positiveDate = Number.isNaN(Date.parse(`1212-12-12T${newTime}`)) ? '' : newTime;\n          }\n        } else {\n          // now truly check if date is a valid date\n          if (Number.isNaN(Date.parse(this.parseToDateStorage(positiveDate)))) {\n            // TODO: check if date has appropriate number of periods\n            const [year, month, day] = positiveDate.split('.').reverse();\n            if (this.dateFormatInt === 'DD.MM.YYYY') {\n              // TODO: could this check already be done on input???\n              // check if something is wrong with the day\n              if (!/^(0[1-9]|[1-2][0-9]|3[0-1])/.test(day)) {\n                // replace day with appropriate value\n                positiveDate = `01.${month}.${year}`;\n              }\n            } if (this.dateFormatInt !== 'YYYY') {\n              // check if something is wrong with the month\n              if (!/^(0[1-9]|1[0-2])/.test(month)) {\n                // replace month with appropriate value\n                positiveDate = `${day ? `${day}.` : ''}01.${year}`;\n              }\n            }\n          }\n          // since technically invalid dates (like 30.02.2000) will also be considered a\n          // valid date by Date.parse() just convert to Date and back one more time\n          // new Date(input) will always convert to the actual day in the next month\n          // e.g. 31.06. --> 01.07. ; 30.02. --> 02.03.\n          const tempDate = this.getDateString(this.convertToDate(this.parseToDateStorage(positiveDate)));\n          if (!Number.isNaN(Date.parse(this.parseToDateStorage(tempDate)))) {\n            positiveDate = tempDate;\n          } else {\n            positiveDate = '';\n          }\n        }\n        // now add the minus again if necessary\n        this[`input${origin}`] = this.addYearMinusToDateDisplay(\n          positiveDate,\n          this.isNegativeDisplayDate(this[`input${origin}`]),\n        );\n        // after everything also still check if the new date/time string needs a fade out\n        this.calcFadeOut([origin]);\n      }\n      const data = this.getInputData();\n      /**\n       * this event is emitted when the value was validated in case input should just be considered\n       * after date validation\n       *\n       * @event value-validated\n       * @param {string, Object} - the validated string or input object\n       */\n      this.$emit('value-validated', data);\n    },\n    /**\n     * a function to have the time picker close automatically as soon as minutes\n     * are selected\n     * @param {string} origin - is it from the 'from' or 'to' part of the picker\n     * @param {any} time - the selected time (not needed here but passed by event)\n     * @param {string} type - was 'hour' or 'minute' selected\n     */\n    closeTimePicker(origin, time, type) {\n      if (type === 'minute') {\n        // get capitalized origin here since needed 2x\n        const uppercaseOrigin = capitalizeString(origin);\n        // check date validity\n        this.checkDateValidity(uppercaseOrigin);\n        // close the drop down\n        this[`${origin}Open`] = false;\n        // check if the new date/time string needs a fade out\n        this.calcFadeOut([uppercaseOrigin]);\n      }\n    },\n    /**\n     * function triggered on datepicker 'pick' event, handling date picker closing\n     * and date validation\n     *  caveat: this event is just triggered for DATE picker - not time!\n     * @param origin\n     */\n    datePicked(origin) {\n      this[`${origin}Open`] = false;\n      // need this here because on blur() date is not updated\n      this.checkDateValidity(capitalizeString(origin));\n    },\n    /**\n     * handle click outside event and adjust input active variable accordingly\n     * @param {MouseEvent} event - the event provided by the click outside directive\n     */\n    clickedOutside(event) {\n      this.isActiveInt = false;\n      /**\n       * emit a custom clicked-outside event instead of BaseInput event (propagation stopped)\n       *\n       * @event clicked-outside\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('clicked-outside', event);\n    },\n    /**\n     * handle click inside the component and adjust input active variable accordingly\n     * @param {MouseEvent} event - event triggered by mouse click\n     */\n    clickedInside(event) {\n      this.isActiveInt = true;\n      /**\n       * event additionally triggered to BaseInput default click-input-field to also\n       * set field active if component sourroundings are clicked\n       *\n       * @event click-input-field\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('click-input-field', event);\n    },\n    /**\n     * data emit function, transforming data before emit event\n     */\n    emitData() {\n      // get a data object that only contains fields that were also present\n      // in external input\n      const data = this.getInputData();\n      /**\n       * emit an event when focus leaves the input\n       *\n       * @event selected\n       * @param {string, Object} - the input string or object\n       */\n      this.$emit('selected', data);\n    },\n    /**\n     * convert function triggered on format tab switch\n     */\n    convertDate(oldFormat) {\n      // go over each property of inputInt (that includes date - since not applicable to time\n      // values)\n      Object.entries(this.inputInt).filter(([key]) => !!key.includes('date'))\n        .forEach(([dateKey, dateValue]) => {\n          // get the date to convert and remove the minus if there is one\n          const dateToConvert = this.removeYearMinusFromStorageDate(dateValue, oldFormat);\n          if (dateToConvert) {\n            if (this.minDateView === 'year') {\n              // convert date string to real date in order to get year and convert back to string\n              this.$set(this.inputInt, dateKey, this.addYearMinusToDateStorage(\n                this.convertToDate(dateToConvert).getFullYear().toString(),\n                this.isNegativeStorageDate(dateValue, oldFormat),\n              ));\n              return;\n            }\n            let useStorageDate;\n            const storageDate = this.tempDateStore ? this.tempDateStore[dateKey] : null;\n            const isNegativeTempStorageDate = !!storageDate && /^-/.test(storageDate);\n            const isNegativeNewDateValue = this.isNegativeStorageDate(dateValue, oldFormat);\n            const positiveTempStorageDate = isNegativeTempStorageDate ? storageDate.replace('-', '') : storageDate;\n            if (this.minDateView === 'month') {\n              useStorageDate = !!positiveTempStorageDate\n                // get stored date if\n                // a) previous date was full date and month and year\n                // are identical with stored year and month\n                && ((!this.isDateFormatYear\n                    && this.monthAndYearIdent(positiveTempStorageDate, dateToConvert))\n                  // b) previous date was year and it is identical with stored year\n                  || (new Date(positiveTempStorageDate)\n                    .getFullYear().toString() === dateToConvert))\n                // also check that they have the identical sign\n                && (isNegativeTempStorageDate === isNegativeNewDateValue);\n              // assume the format is 'date'\n            } else {\n              // check if a previous date was stored and year (coming from year)\n              useStorageDate = !!positiveTempStorageDate && ((this.isDateFormatYear\n                && new Date(positiveTempStorageDate).getFullYear().toString() === dateToConvert\n                  && isNegativeTempStorageDate === this.isNegativeStorageDate(dateValue, oldFormat))\n                // or month and year (coming from month) was changed or is still the same\n                || (this.isDateFormatMonth\n                && this.monthAndYearIdent(positiveTempStorageDate, dateToConvert)\n                  && (isNegativeTempStorageDate === isNegativeNewDateValue)));\n              // if a previous date was stored use this one else use the input date\n            }\n            const newDate = useStorageDate ? positiveTempStorageDate : dateToConvert;\n            // now assign the new date to the input variable\n            this.$set(\n              this.inputInt,\n              dateKey,\n              this.addYearMinusToDateStorage(\n                this.getDateString(this.convertToDate(newDate)),\n                // use the original dates here before minus was removed, depending on which date was used\n                (useStorageDate ? isNegativeTempStorageDate : isNegativeNewDateValue),\n              ),\n            );\n          }\n        });\n    },\n    /**\n     * if input was just a single string return that otherwise\n     * only return the properties provided by external input\n     * if input is empty set value to empty string instead of null (default vue2-datepicker)\n     * @returns {string | Object}\n     */\n    getInputData() {\n      if (this.isInputTypeString) {\n        return this.inputInt.date !== null ? this.inputInt.date : '';\n      }\n      const data = {};\n      this.inputProperties.forEach(key => this.$set(data, key, this.inputInt[key] !== null ? this.inputInt[key] : ''));\n      return data;\n    },\n    /**\n     * convert a value to a date in local time at zero hours\n     *\n     * @param {string} value - the date string stored in db (format YYYY-MM-DD) - this needs to\n     *  be a positive date value!! (remove minus from negative years before applying this function)\n     * @returns {Date} - (e.g. Fri Jul 30 2021 00:00:00 GMT+0200 (Central European Summer Time))\n     */\n    convertToDate(value) {\n      return new Date(`${value}T00:00:00.000`);\n    },\n    /**\n     * a function to convert a date to a string in the format YYYY-MM-DD\n     *\n     * @param {Date} date in format\n     * @returns {string} - returns a string in format YYYY-MM-DD\n     */\n    getDateString(date) {\n      // there is always a year // add padStart to always have 4 digits\n      let dateString = `${date.getFullYear().toString().padStart(4, '0')}`;\n      // if date format is not 'year' only - add month\n      if (this.dateFormatInt !== 'YYYY') {\n        const month = (date.getMonth() + 1).toString();\n        dateString = `${dateString}-${month.length < 2 ? '0' : ''}${month}`;\n      }\n      // if date format is 'date' - add day\n      if (this.dateFormatInt === 'DD.MM.YYYY') {\n        const day = date.getDate().toString();\n        dateString = `${dateString}-${day.length < 2 ? '0' : ''}${day}`;\n      }\n      return dateString;\n    },\n    /**\n     * compare 2 dates for identical month and year values respectively\n     *  these dates need to be positive values (remove the minus from the date\n     *  before applying this function)\n     * @param {string} date1 - a string in YYYY-MM-DD format\n     * @param {string} date2 - a string in YYYY-MM-DD format\n     * @returns {boolean}\n     */\n    monthAndYearIdent(date1, date2) {\n      const convertedDate1 = this.convertToDate(date1);\n      const convertedDate2 = this.convertToDate(date2);\n      const monthDate1 = convertedDate1.getMonth();\n      const monthDate2 = convertedDate2.getMonth();\n      const yearDate1 = convertedDate1.getFullYear();\n      const yearDate2 = convertedDate2.getFullYear();\n      return monthDate1 === monthDate2 && yearDate1 === yearDate2;\n    },\n    /**\n     * check for a negative year in the date that is displayed\n     * @param {string} date - date string in the format DD.MM.YYYY\n     * @returns {boolean}\n     */\n    isNegativeDisplayDate(date) {\n      if (!date) return false;\n      if (this.dateFormatInt === 'MM.YYYY') {\n        return /^\\d{0,2}\\.-\\d{0,4}$/.test(date);\n      }\n      if (this.dateFormatInt === 'YYYY') {\n        return /^-\\d{0,4}$/.test(date);\n      }\n      return /^\\d{0,2}\\.\\d{0,2}\\.-\\d{0,4}$/.test(date);\n    },\n    /**\n     * check if year is negative in the stored date\n     * @param {string} date - a date string in the format YYYY-MM-DD\n     * @param {string} [format=undefined] - in case not the current format (this.dateFormatInt) should\n     *  be used for evaluation provide it with this param\n     * @returns {boolean}\n     */\n    isNegativeStorageDate(date, format = undefined) {\n      // if there is no date to evaluate just return false\n      if (!date) return false;\n      // either use the format provided as param or the currently set format in dateFormatInt\n      const formatToCheck = format || this.dateFormatInt;\n      if (formatToCheck === 'MM.YYYY') {\n        return /^-\\d{0,4}-\\d{0,2}$/.test(date);\n      }\n      if (formatToCheck === 'YYYY') {\n        return /^-\\d{0,4}$/.test(date);\n      }\n      return /^-\\d{0,4}-\\d{0,2}-\\d{0,2}$/.test(date);\n    },\n    /**\n     * since minus has to be temporarily removed for some actions add it again\n     *  after with this function (for displayed date)\n     * @param {string} date - date in the format DD.MM.YYYY\n     * @param {boolean} [isNegative=true] - optionally do not add minus when calling this\n     *  function\n     * @returns {string}\n     */\n    addYearMinusToDateDisplay(date, isNegative = true) {\n      if (isNegative) {\n        const [year, month, day] = date.split('.').reverse();\n        return `${day !== undefined ? `${day}.` : ''}${month !== undefined ? `${month}.` : ''}-${year}`;\n      }\n      return date;\n    },\n    /**\n     * since minus has to be temporarily removed for some actions add it again\n     *  after with this function (for stored date)\n     * @param {string} date - date in the format YYYY-MM-DD\n     * @param {boolean} [isNegative=true] - optionally do not add minus when calling this\n     *  function\n     * @returns {string}\n     */\n    addYearMinusToDateStorage(date, isNegative = true) {\n      if (isNegative) {\n        return `-${date}`;\n      }\n      return date;\n    },\n    /**\n     * remove the minus from the date since some functions (especially Date() ) can\n     *  not cope with negative dates (for displayed date)\n     * @param {string} date - the date string in format DD.MM.YYYY\n     * @returns {string}\n     */\n    removeYearMinusFromDisplayDate(date) {\n      return this.isNegativeDisplayDate(date)\n        ? date.replace('-', '') : date;\n    },\n    /**\n     * remove the minus from the date since some functions (especially Date()) can\n     *  not cope with negative dates (for stored date)\n     * @param {string} date - the date string in format YYYY-MM-DD\n     * @param {string} [format=undefined] - in case not the currently selected format should be used\n     *  for date evaluation provide the format with this param\n     * @returns {string}\n     */\n    removeYearMinusFromStorageDate(date, format = undefined) {\n      return this.isNegativeStorageDate(date, format)\n        ? date.replace('-', '') : date;\n    },\n    isTimeInputField(origin) {\n      return this.type === 'timerange' || (this.type === 'datetime' && origin.toLowerCase() === 'to');\n    },\n    /**\n     * function to calculate if fade out in the input fields should be shown, needs to be\n     * recalculated after resize or if input changes\n     */\n    calcFadeOut(inputFields) {\n      // now iterate through the relevant fields\n      inputFields.forEach((field) => {\n        // check if element exists\n        if (this.$refs[`input${field}`]) {\n          // now get the input field value\n          const inputValue = this.$refs[`input${field}`].value;\n          // for width (and fade out) calculation either use that or the placeholder visible\n          // in the field (this is saved in a separate variable from inputValue because for\n          // show icons only input value is relevant)\n          const text = inputValue || this.$refs[`input${field}`].getAttribute('placeholder');\n          // now check if any of the two exists\n          if (text) {\n            // create a span\n            const span = document.createElement('span');\n            // hide the span\n            span.setAttribute('class', 'hide');\n            // add the input extracted text to this span\n            span.innerHTML = text;\n            // add the element to the document body\n            document.body.appendChild(span);\n            // get the width of that element\n            const textWidth = span.offsetWidth;\n            // remove the element again\n            document.body.removeChild(span);\n            // now also get the input width\n            const inputWidth = this.$refs[`input${field}`].offsetWidth;\n            // check if the input value or placeholder width exceeds input width\n            if (textWidth > inputWidth) {\n              // if yes and there is input and icons are shown\n              if (inputValue && this.showIcons) {\n                // remove icons\n                this.showIcons = false;\n                // otherwise use fade out\n              } else {\n                this[`useFadeOut${field}`] = true;\n              }\n              // if input value or placeholder fit the input width\n            } else if (textWidth <= inputWidth) {\n              // check first if the fade out is used\n              if (this[`useFadeOut${field}`]) {\n                // if so - disable this one first\n                this[`useFadeOut${field}`] = false;\n                // else check if the icon would actually fit in the input together with the\n                // input width - if so - show icons\n              } else if (!this.showIcons && textWidth + this.iconWidth <= inputWidth) {\n                this.showIcons = true;\n              }\n            }\n          }\n        }\n      });\n    },\n    /**\n     * function to correctly style the date format switch buttons and prevent\n     * overlay with label\n     */\n    calcLabelAdditionsWidth() {\n      // get the complete element width\n      const observableWidth = this.$refs.baseDateInput.clientWidth;\n      // get the label margin\n      const labelMargin = this.showLabel\n        ? Number(getComputedStyle(this.$refs.label)['margin-right'].replace('px', '')) : 0;\n      const labelWidth = this.showLabel ? this.$refs.label.clientWidth : 0;\n      // calculate the remaining container space after label, label margin and date switch width\n      const spacingLeft = observableWidth\n        - labelWidth\n        - labelMargin\n        - this.$refs.labelAdditions.clientWidth;\n      // if no space is left set a class that sets label additions width to 100% so element has to wrap\n      this.wrapLabelRow = spacingLeft < 0;\n    },\n    /**\n     * add delay before value is set\n     *\n     * @param {String} origin - is event originating from 'from' or 'to' field\n     * @param {boolean} value\n     */\n    isActiveHandler(origin, value) {\n      // if false set value immediately\n      if (!value) {\n        this[`${origin}Open`] = value;\n        this.isActiveInt = this.fromOpen || this.toOpen;\n        // check for date validity here instead of blur event (necessary for time input\n        // which is not triggered otherwise)\n        this.checkDateValidity(capitalizeString(origin));\n        return;\n      }\n\n      // otherwise add a delay\n      setTimeout(() => {\n        this[`${origin}Open`] = value;\n        this.isActiveInt = this.fromOpen || this.toOpen;\n      }, this.isActiveDelay);\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import '../../styles/variables.scss';\n\n  .base-date-input {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    position: relative;\n\n    .base-date-input__label-row {\n      display: flex;\n      flex-wrap: wrap;\n      width: 100%;\n      height: 100%;\n      justify-content: space-between;\n      align-items: center;\n\n      &.base-date-input__label-row--visible {\n        margin-bottom: $spacing-small-half;\n      }\n\n      .base-date-input__label {\n        color: $font-color-second;\n        margin-bottom: $spacing-small-half;\n        text-align: left;\n        align-self: flex-end;\n        margin-right: 50px;\n      }\n\n      .base-date-input__label-additions {\n        position: relative;\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        justify-content: flex-end;\n        flex: 1 1 auto;\n        height: $line-height;\n\n        &.base-date-input__label-additions--switch-height {\n          height: calc(#{$line-height} + #{$spacing-small-half});\n\n          &.base-date-input__label-additions--wrap {\n            margin-top: 2px;\n          }\n        }\n\n        &.base-date-input__label-additions--wrap {\n          width: 100%;\n        }\n      }\n\n      .base-date-input__label-additions-inner {\n        position: absolute;\n        right: 0;\n        display: flex;\n        align-items: center;\n        margin-bottom: $spacing-small-half;\n\n        &.base-date-input__label-additions-inner--switch {\n          bottom: 0;\n          margin-bottom: calc(-#{$spacing-small-half} / 2);\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} - 2px);\n          }\n        }\n        &.base-date-input__label-additions-inner--no-label-switch {\n          margin-bottom:  2px;\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} + 1px);\n          }\n        }\n\n        .base-date-input__switch-buttons {\n          bottom: 0;\n          display: flex;\n          line-height: $line-height;\n        }\n      }\n    }\n\n    .base-date-input__field-wrapper {\n      display: flex;\n      align-items: baseline;\n      width: 100%;\n\n      .base-date-input__input-fields {\n        display: flex;\n        align-items: center;\n        flex: 1 1 auto;\n        flex-wrap: wrap;\n\n        .base-date-input__input-line {\n          display: flex;\n          flex: 1 1 auto;\n          align-items: center;\n\n          .base-date-input__input-wrapper {\n\n            & + .base-date-input__input-wrapper {\n              margin-left: $spacing;\n            }\n\n            .base-date-input__datepicker {\n              flex-grow: 1;\n              width: auto;\n              font-family: inherit;\n              font-size: inherit;\n              line-height: $row-height-small;\n\n              .base-date-input__input {\n                padding: $spacing-small-half 0;\n                min-height: $row-height-small;\n                width: 100%;\n              }\n            }\n\n            .base-date-input__icon-wrapper::before {\n              content: '';\n            }\n\n            .base-date-input__date-icon {\n              position: relative;\n              width: $icon-large;\n              height: $icon-large;\n              color: $font-color-second;\n              cursor: pointer;\n              flex-shrink: 0;\n              align-self: center;\n              margin-left: $spacing-small;\n            }\n          }\n\n          .base-date-input__separator {\n            padding: 0 $spacing;\n          }\n        }\n      }\n    }\n\n    .base-date-input__below {\n      position: relative;\n    }\n  }\n\n  @media screen and (max-width: $mobile) {\n    .base-date-input .base-date-input__label-row .base-date-input__label-additions {\n      align-items: center;\n    }\n  }\n</style>\n\n<style lang=\"scss\">\n  @import '../../styles/_datepicker.scss';\n</style>\n"],"names":["_sfc_main","BaseInput","BaseIcon","m","DatePicker","ClickOutside","val","labelKeys","de","en","fr","createId","oldValue","newDate","newValue","key","options","event","slotElements","elem","_a","isDateTimeField","old","dateKey","el","element","origin","relatedTargetInput","_b","_c","_d","tempResizeObserver","debounce","tempLabelAdditionsObserver","entries","observer","dateString","isNegativeYear","positiveDateString","currentInputString","isTimeField","allowedFieldKey","allowMinus","allowedKeysRegex","disallowedKeysOnLengthRegex","formatLength","modifiedValue","charToAdd","day","month","year","positiveDate","separator","numberFormatParts","hours","minutes","currentYear","century","newTime","tempDate","data","time","type","uppercaseOrigin","capitalizeString","oldFormat","dateValue","dateToConvert","useStorageDate","storageDate","isNegativeTempStorageDate","isNegativeNewDateValue","positiveTempStorageDate","value","date","date1","date2","convertedDate1","convertedDate2","monthDate1","monthDate2","yearDate1","yearDate2","format","formatToCheck","isNegative","inputFields","field","inputValue","text","span","textWidth","inputWidth","observableWidth","labelMargin","labelWidth","spacingLeft"],"mappings":"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"}