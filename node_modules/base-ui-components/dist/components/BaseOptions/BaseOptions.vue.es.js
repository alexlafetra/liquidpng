import { debounce as h } from "../../utils/utils.es.js";
import p from "../BaseButton/BaseButton.vue.es.js";
import l from "../../mixins/i18n.es.js";
import "./BaseOptions.vue.es2.js";
import u from "../../_virtual/_plugin-vue2_normalizer.es.js";
const d = {
  name: "BaseOptions",
  components: {
    BaseButton: p
  },
  mixins: [l],
  props: {
    /**
     * set showing of option buttons from outside.
     *   the [`.sync` modifier](https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier) may be used on this prop
     */
    showOptions: {
      type: Boolean,
      default: !1
    },
    /**
     * hide options completely (necessary if only before or after slot elements should remain)
     */
    optionsHidden: {
      type: Boolean,
      default: !1
    },
    /**
     * define alignment of options button and options
     */
    alignOptions: {
      type: String,
      default: "right",
      validator: (i) => ["left", "right"].includes(i)
    },
    /**
     * define in which scenario an options button should be shown:
     *
     *   **always**: always show the options button
     *   **mobile**: only show options button when window size < 640px
     *   **never**: never show the options button - just show the available options directly
     *   **fitted**: use options button whenever the actions (incl. before and after slot) do
     *    not fit the row anymore
     */
    useOptionsButtonOn: {
      type: String,
      default: "always",
      validator: (i) => ["always", "mobile", "never", "fitted"].includes(i)
    },
    /**
     * define the options button text as an object with `show` (=text that should be
     * shown with options hidden) and `hide` (=text that should be shown with options visible)
     *   values can be either plain strings or a string leading to a localization file.
     *   (only relevant if `useOptionsButtonOn` is different from 'never')
     */
    optionsButtonText: {
      type: Object,
      default: () => ({
        show: "options",
        hide: "return"
      }),
      validator: (i) => "show" in i && "hide" in i
    },
    /**
     * define the icon for the options button as an object with `show` (=icon that should be
     * shown with options hidden) and `hide` (=icon that should be shown with options visible)
     *   see [BaseIcon](BaseIcon) for available icons.
     *   (only relevant if `useOptionsButtonOn` is different from 'never')
     */
    optionsButtonIcon: {
      type: Object,
      default: () => ({
        show: "options-menu",
        hide: "remove"
      }),
      validator: (i) => "show" in i && "hide" in i
    },
    /**
     * define if slot after-options should be shown before or after options.
     * if row wraps because of space issues
     *   (only relevant with use of options button)
     */
    showAfterOptionsBelow: {
      type: Boolean,
      default: !0
    },
    /**
     * in order to display options one can either use the slot `options` or specify a
     * config via `optionsConfig` prop. If the latter option is used the following properties
     * need to be provided:
     *
     *   **text** `string` - the text displayed in the button
     *   **icon** `string` - the icon name to display
     *    (for available icons see [BaseIcon](BaseIcon) )
     *   **value** `string` - the value emitted on button click
     *   **disabled** `boolean?` - should button be shown as disabled
     */
    optionsConfig: {
      type: Array,
      default: () => [{
        text: "delete",
        icon: "waste-bin",
        value: "delete",
        disabled: !1
      }],
      validator: (i) => i.every((t) => {
        const s = ["text", "icon", "value"], o = Object.keys(t);
        return s.every((e) => o.includes(e));
      })
    },
    /**
     * specify an array of values set in `optionsConfig` property `value`
     *  for options that should appear disabled.
     *  This is equivalent to and just a more convenient way than to
     *  set the `optionsConfig` property `disabled`
     */
    disableOptions: {
      type: Array,
      default: () => []
    },
    /**
     * set true if options button should be disabled
     *  not relevant for `useOptionsButtonOn` with value `never`
     */
    optionsButtonDisabled: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      /**
       * internal variable for options toggle
       * @type {boolean}
       */
      showOptionsInt: !1,
      /**
       * is window size < 640px
       * @type {boolean}
       */
      isMobile: !0,
      /**
       * total row width needed to calc if options and after options
       * should be shown inline
       * @type {number}
       */
      rowWidth: 4e3,
      /**
       * beforeOptions element width needed to calc if options
       * should be shown inline
       * @type {number}
       */
      beforeOptionsWidth: 0,
      /**
       * afterOptions element width needed to calc if options
       * should be shown inline
       * @type {number}
       */
      afterOptionsWidth: 0,
      /**
       * options button element width needed to calc if options
       * should be shown inline
       * @type {number}
       */
      optionsButtonWidth: 0,
      /**
       * width remaining inline for the actual action buttons to be rendered
       * @type {number}
       */
      remainingActionsWidth: 4e3,
      /**
       * beforeOptions element width needed to calc if options
       * should be shown inline
       * @type {number}
       */
      actionButtonsWidth: 0,
      /**
       * for removing chips via backspace, to get delay after
       * keydown event
       * @type {?number}
       */
      timeout: null,
      /**
       * resize observer for specific element (instead of window)
       */
      resizeObserver: null,
      /**
       * mutation observer for specific element
       */
      mutationObserver: null
    };
  },
  computed: {
    /**
     * translate prop into boolean value to see if options
     * button should be shown
     * @returns {Boolean}
     */
    useOptionsButton() {
      return this.useOptionsButtonOn === "always" || this.useOptionsButtonOn === "mobile" && this.isMobile || this.useOptionsButtonOn === "fitted" && !this.optionsFittingRowWidth;
    },
    /**
     * determine if options should be shown inline or below options row
     * @returns {Boolean}
     */
    showOptionsInline() {
      return this.remainingActionsWidth - this.actionButtonsWidth > 0 || !this.useOptionsButton;
    },
    /**
     * determine if afterOptions slot should be shown above or below options in a
     * wrapping situation
     */
    showAfterOptionsInline() {
      return this.afterSlotHasData && (!this.useOptionsButton && this.remainingActionsWidth > this.actionButtonsWidth || this.useOptionsButton && (!this.showAfterOptionsBelow || this.remainingActionsWidth > 0));
    },
    optionsFittingRowWidth() {
      return this.rowWidth - this.actionButtonsWidth - this.beforeOptionsWidth - this.afterOptionsWidth > 0;
    },
    /**
     * determine if action buttons need to be flex-wrapped
     */
    wrapActions() {
      return this.rowWidth <= this.actionButtonsWidth;
    },
    wrapHeaderActions() {
      return this.rowWidth - this.beforeOptionsWidth < this.actionButtonsWidth;
    },
    /**
     * determine if before slot has data
     * @returns {Boolean}
     */
    beforeSlotHasData() {
      return !!this.$slots.beforeOptions;
    },
    /**
     * determine if after slot has data
     * @returns {Boolean}
     */
    afterSlotHasData() {
      return !!this.$slots.afterOptions;
    }
  },
  watch: {
    // watch options toggle to recalculate the remaining size
    // for options (= should they be shown inline or below)
    showOptionsInt(i) {
      this.showOptions !== i && this.$emit("update:show-options", i);
    },
    // update show options internal value if different from parent
    showOptions: {
      handler(i) {
        this.showOptionsInt !== i && this.useOptionsButton && (this.showOptionsInt = i);
      },
      immediate: !0
    },
    /**
     * watch use options button variable which changes if options button
     * is only used on mobile
     * @param {boolean} val
     */
    useOptionsButton: {
      handler(i) {
        this.showOptionsInt = !i;
      },
      immediate: !0
    },
    /**
     * watch isMobile to have the options transform into options button when
     * useOptionsButtonOn is 'mobile'
     *
     * @param {boolean} val
     */
    isMobile(i) {
      this.useOptionsButtonOn === "mobile" && i && (this.showOptionsInt = !1);
    },
    optionsButtonDisabled(i) {
      i && (this.showOptionsInt = !1);
    }
  },
  mounted() {
    this.initObserver();
  },
  updated() {
    this.calcFixedElementWidth(), this.showOptionsInt && this.$refs.actions && this.calcOptionsWidth();
  },
  beforeDestroy() {
    this.resizeObserver && this.resizeObserver.unobserve(this.$refs.optionsRow), this.mutationObserver && this.afterSlotHasData && this.mutationObserver.disconnect();
  },
  methods: {
    initObserver() {
      const i = new ResizeObserver(h(50, this.resizeActions));
      if (i.observe(this.$refs.optionsRow), this.resizeObserver = i, this.afterSlotHasData) {
        const t = new MutationObserver(this.calcOptionsWidth);
        t.observe(this.$refs.afterOptions, {
          childList: !0,
          subtree: !0
        }), this.mutationObserver = t;
      }
    },
    optionTriggered(i) {
      this.$emit("option-triggered", i);
    },
    /**
     * method for all resize actions with setTimeout function to prevent
     * triggering to often
     */
    resizeActions() {
      this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.timeout = setTimeout(() => {
        this.calcIsMobile();
      }, 200), this.calcOptionsWidth();
    },
    /**
     * calculate if size is mobile size after initial render and
     * window resize events
     */
    calcIsMobile() {
      this.isMobile = window.innerWidth < 640;
    },
    /**
     * calculate the variable width elements width after initial render, options toggle
     * or window resize events
     */
    calcOptionsWidth() {
      const { optionsRow: i } = this.$refs;
      i && (this.rowWidth = i.clientWidth), this.remainingActionsWidth = i ? this.rowWidth - this.beforeOptionsWidth - this.afterOptionsWidth - (this.useOptionsButton ? this.optionsButtonWidth : 0) : 0;
      const t = this.$refs.actions;
      t && (this.actionButtonsWidth = t.clientWidth);
    },
    /**
     * function for elements width that only has to be calculated once
     */
    calcFixedElementWidth() {
      this.beforeSlotHasData && this.$refs.beforeOptions && (this.beforeOptionsWidth = this.$refs.beforeOptions.clientWidth), this.afterSlotHasData && this.$refs.afterOptions && (this.afterOptionsWidth = this.$refs.afterOptions.clientWidth);
      const i = this.$refs.optionsButton;
      this.useOptionsButton && i && (this.optionsButtonWidth = i.$el.clientWidth);
    }
  }
};
var f = function() {
  var t = this, s = t._self._c;
  return s("div", { staticClass: "base-options" }, [s("div", { ref: "optionsRow", class: [
    "base-options__row",
    `base-options__row-${t.alignOptions}`,
    {
      "base-options__row-wrap": !t.showOptionsInline || !t.useOptionsButton && t.remainingActionsWidth < t.actionButtonsWidth
    }
  ] }, [t.beforeSlotHasData ? s("div", { ref: "beforeOptions", staticClass: "base-options__before" }, [t._t("beforeOptions")], 2) : t._e(), t.alignOptions === "right" ? s("div", { staticClass: "base-options__spacer" }) : t._e(), !t.optionsHidden && t.showOptionsInline && t.showOptionsInt ? s("div", { ref: "actions", class: [
    "base-options__options-inline",
    { "base-options__options-inline-wrap": t.wrapActions },
    { "base-options__options-inline-left": t.alignOptions === "left" }
  ] }, [t._t("options", function() {
    return [t.optionsConfig.length ? t._l(t.optionsConfig, function({ text: o, icon: e, disabled: n, value: r }, a) {
      return s("BaseButton", { key: o + "_" + a, attrs: { text: o, icon: e, disabled: n || t.disableOptions.includes(r), "has-background-color": !1, "icon-size": "large", "button-style": "single" }, on: { clicked: function(b) {
        return t.optionTriggered(r);
      } } });
    }) : t._e()];
  })], 2) : t._e(), !t.optionsHidden && t.useOptionsButton ? s("BaseButton", { ref: "optionsButton", class: [{ "base-options__options-button-left": t.alignOptions === "left" }], attrs: { text: t.showOptionsInt ? t.getI18nTerm(t.optionsButtonText.hide) : t.getI18nTerm(t.optionsButtonText.show), icon: t.showOptionsInt ? t.optionsButtonIcon.hide : t.optionsButtonIcon.show, disabled: t.optionsButtonDisabled }, on: { clicked: function(o) {
    t.showOptionsInt = !t.showOptionsInt;
  } } }) : t._e(), t.alignOptions === "left" ? s("div", { staticClass: "base-options__spacer base-options__spacer-left" }) : t._e(), t.showAfterOptionsInline && t.afterSlotHasData ? s("div", { ref: "afterOptions", staticClass: "base-options__after-inline" }, [t._t("afterOptions")], 2) : t._e()], 1), s("transition", { attrs: { name: "slide-fade-options" } }, [!t.optionsHidden && t.showOptionsInt && !t.showOptionsInline ? s("div", { staticClass: "base-options__below" }, [t._t("options", function() {
    return [t.optionsConfig.length ? t._l(t.optionsConfig, function(o, e) {
      return s("BaseButton", { key: o.text + "_" + e, attrs: { text: o.text, icon: o.icon, "has-background-color": !1, "icon-size": "large", "button-style": "single" }, on: { clicked: function(n) {
        return t.optionTriggered(o.value);
      } } });
    }) : t._e()];
  })], 2) : t._e()]), !t.showAfterOptionsInline && t.afterSlotHasData ? s("div", { staticClass: "base-options__after" }, [t._t("afterOptions")], 2) : t._e()], 1);
}, c = [], O = /* @__PURE__ */ u(
  d,
  f,
  c,
  !1,
  null,
  "71e17d35",
  null,
  null
);
const v = O.exports;
export {
  v as default
};
//# sourceMappingURL=BaseOptions.vue.es.js.map
