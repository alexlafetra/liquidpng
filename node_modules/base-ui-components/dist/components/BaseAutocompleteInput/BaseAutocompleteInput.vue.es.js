import o from "../BaseInput/BaseInput.vue.es.js";
import r from "../BaseDropDownList/BaseDropDownList.vue.es.js";
import { createId as s } from "../../utils/utils.es.js";
import { useAnnouncer as l } from "../../composables/useAnnouncer.es.js";
import { ref as a } from "vue";
import u from "../../mixins/navigateList.es.js";
import "./BaseAutocompleteInput.vue.es2.js";
import p from "../../_virtual/_plugin-vue2_normalizer.es.js";
const d = {
  name: "BaseAutocompleteInput",
  components: {
    BaseInput: o,
    BaseDropDownList: r
  },
  mixins: [
    u
  ],
  model: {
    prop: "input",
    event: "input"
  },
  props: {
    /**
     * input field settable from outside
     */
    input: {
      type: [String, Number],
      default: ""
    },
    /**
     * provide a list of options for the drop down.
     * could be a list of strings or objects - if it is objects if necessary please adapt
     * the props `labelPropertyName` (value to be displayed) and `identifierPropertyName` (used for
     * identification) for correct handling
     */
    list: {
      type: Array,
      default: () => []
    },
    /** label for input field, required for usability purposes, handle
     * showing of label with property `showLabel`
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * defines if input label should be visible
     */
    showLabel: {
      type: Boolean,
      default: !0
    },
    /**
     * if field is occurring more then once - set an id
     * in case a custom input is used with the input slot it is important to
     * assign the same id to the input element
     */
    id: {
      type: String,
      default: ""
    },
    /**
     * set a placeholder for the input field
     */
    placeholder: {
      type: String,
      default: "Enter Text Here"
    },
    /**
     * mark as required field (currently only used for `aria-required`)
     */
    required: {
      type: Boolean,
      default: !1
    },
    /**
     * mark the form field as invalid and ideally also provide an error message
     * to display below the form field
     */
    invalid: {
      type: Boolean,
      default: !1
    },
    /**
     * add an error message to be displayed below form field if field is invalid
     */
    errorMessage: {
      type: String,
      default: ""
    },
    /**
     * define if error icon should be shown
     */
    showErrorIcon: {
      type: Boolean,
      default: !0
    },
    /**
     * set input field in active state from outside.
     * the `.sync` modifier can be used on this prop
     */
    isActive: {
      type: Boolean,
      default: null
    },
    /**
     * option to have the border of the input field not displayed
     */
    showInputBorder: {
      type: Boolean,
      default: !0
    },
    /**
     * define if standard form field styling should be
     * used (otherwise no box shadow)
     */
    useFormFieldStyling: {
      type: Boolean,
      default: !0
    },
    /**
     * if `true` a remove icon (or a custom icon if slot `remove-icon` is used) will be shown allowing to remove
     * all input at once
     */
    clearable: {
      type: Boolean,
      default: !1
    },
    /**
     * if `true` space is reserved for a loader that can be activated
     * with the 'isLoading' prop
     */
    loadable: {
      type: Boolean,
      default: !1
    },
    /**
     * show spinner to indicate that something is loading
     * (for dynamically fetched entries that need to do backend requests)
     */
    isLoading: {
      type: Boolean,
      default: !1
    },
    /**
     * set a language (ISO 639-1)
     */
    language: {
      type: String,
      default: ""
    },
    /**
     * set `true` if input field should be disabled
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * specify the object property that should be used as identifier
     */
    identifierPropertyName: {
      type: String,
      default: "id"
    },
    /**
     * specify the object property that should be used as value to be displayed
     */
    labelPropertyName: {
      type: String,
      default: "label"
    },
    /**
     * message displayed when no selectable options are available
     */
    dropDownNoOptionsInfo: {
      type: String,
      default: "No options available"
    },
    /**
     * if this is `true` parent needs to take care of filling the options list on string
     * input etc. - useful for fetching autocomplete options from a backend
     */
    dynamicFetch: {
      type: Boolean,
      default: !0
    },
    /**
     * set this flag to `true` to highlight autocomplete option characters that match
     *  the current search input string
     */
    highlightStringMatch: {
      type: Boolean,
      default: !1
    },
    /**
     * if `highlightAutocompleteMatch` is set `true`
     *  provide tag names to style the matched characters
     *  (without '<' and '>', e.g. ['b'] for <b>)
     */
    highlightStringTags: {
      type: Array,
      default: () => []
    },
    /**
     * add text that is announced when results are being fetched (prop
     *  `isLoading` is set `true`) and when results were retrieved (drop down
     *  list changed)
     */
    assistiveText: {
      type: Object,
      default: () => ({
        loaderActive: "Drop down options are loading.",
        resultsRetrieved: "{number} options found with your input."
      })
    }
  },
  setup() {
    const e = a(null), { announcement: t } = l(e);
    return {
      autocompleteInput: e,
      announcement: t
    };
  },
  data() {
    return {
      /**
       * internal input representation passed on to BaseInput
       * @type {?string|Object}
       */
      inputInt: null,
      /**
       * needed for navigation via keyboard in drop down list
       * the index of the current active option in the list array
       * @type {number}
       */
      activeOptionIndex: -1,
      /**
       * internal representation for active state of input and drop down
       * @type {boolean}
       */
      isActiveInt: !1,
      /**
       * timeout for drop down options found announcer because otherwise
       * text not read if more than one character entered into input
       * @type {?number}
       */
      timeout: null
    };
  },
  computed: {
    inputListeners() {
      return {
        // add all the listeners from the parent
        ...this.$listeners,
        // keep this input from propagating and use own event
        // (handled this way because this input event is only triggered on
        // keyboard input not when I select from the drop down)
        input: () => {
        },
        // keep this BaseInput event from propagating and use component's own event
        "update:is-active": () => {
        }
      };
    },
    /**
     * compute an internal representation for the list to always have an
     * object with identifier provided to BaseDropDownList
     * @returns {Object[]}
     */
    listInt() {
      return this.optionsIsListOfStrings ? this.list.map((e) => ({
        [this.labelPropertyName]: e,
        [this.identifierPropertyName]: `${e}-${s()}`
      })) : this.list;
    },
    /**
     * additionally if the list is not fetched dynamically filter already selected
     * options from the  list
     * (since inputInt is always only string now this can only be done by comparing
     * the label!)
     */
    filteredListInt() {
      return this.dynamicFetch ? this.listInt : this.listInt.filter((e) => e[this.labelPropertyName].toLowerCase().includes(this.inputInt.toLowerCase()));
    },
    /**
     * determine if list prop is array of strings or objects
     * @returns {boolean}
     */
    optionsIsListOfStrings() {
      return !!this.list && !!this.list.length && typeof this.list[0] == "string";
    },
    /**
     * the currently active option object
     */
    activeOption: {
      /**
       * setter function of activeOption - will set active option index
       * @param {?Object} val - the active option (by hover or arrow key use)
       */
      set(e) {
        this.activeOptionIndex = this.listInt.indexOf(e);
      },
      /**
       * getter function for activeOption - determined by active option index
       * @returns {?Object}
       */
      get() {
        return this.listInt[this.activeOptionIndex];
      }
    }
  },
  watch: {
    /**
     * watch input prop to update internal representation
     */
    input: {
      handler(e) {
        e !== this.inputInt && (this.inputInt = e);
      },
      immediate: !0
    },
    /**
     * watch internal input variable to inform parent of changes if necessary
     * @param {Object|string} val
     */
    inputInt(e) {
      e !== this.input && this.$emit("input", e), this.dynamicFetch && this.$emit("fetch-dropdown-entries", { value: e });
    },
    isActive: {
      /**
       * watch prop isActive to sync with internal variable
       * @param {boolean} val - is input active
       */
      handler(e) {
        e !== this.isActiveInt && (this.isActiveInt = e);
      },
      immediate: !0
    },
    /**
     * watch internal is active variable to be able to inform parent about
     * changes
     * @param {boolean} val
     */
    isActiveInt(e) {
      e || (this.activeOptionIndex = -1), this.$emit("update:is-active", e);
    },
    filteredListInt(e) {
      this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.timeout = setTimeout(() => {
        this.isActiveInt && (e.length ? this.announcement = this.assistiveText.resultsRetrieved.replace("{number}", e.length) : this.announcement = this.dropDownNoOptionsInfo);
      }, 1e3);
    }
  },
  methods: {
    /**
     * event for keydown arrow (up, down) key use
     *
     * @param {KeyboardEvent} event - the keydown event
     */
    onArrowKey(e) {
      this.listInt.length && (this.activeOption = this.navigate(
        this.listInt,
        e.key === "ArrowDown",
        this.activeOptionIndex,
        !1,
        !0
      ));
    },
    /**
     * triggered on keydown enter event and will add
     * a selected option
     */
    onEnter() {
      this.activeOption ? this.selectOption(this.activeOption) : this.isActiveInt = !1;
    },
    /**
     * if user continues typing after 'enter' (which closes the drop down)
     * the dropdown should open again
     */
    onKeydown(e) {
      const { key: t } = e;
      ["Tab", "Enter"].includes(t) || (this.isActiveInt = !0);
    },
    /**
     * function to toggle the drop down e.g. on space or enter key
     */
    toggleDropDown() {
      this.isActiveInt = !this.isActiveInt;
    },
    /**
     * @param {Object} selectedOption - the option selected from drop down or by keyboard
     * enter - always an object due to internal identifier prop added in case it was a string
     */
    selectOption(e) {
      if (this.inputInt = e[this.labelPropertyName], this.optionsIsListOfStrings)
        this.$emit("selected", this.inputInt);
      else {
        const t = this.list.find((n) => n[this.identifierPropertyName] === e[this.identifierPropertyName]);
        this.$emit("selected", t);
      }
      this.isActiveInt = !1;
    }
  }
};
var f = function() {
  var t = this, n = t._self._c;
  return n("div", { ref: "autocompleteInput", staticClass: "base-autocomplete-input" }, [n("BaseInput", t._g({ staticClass: "base-autocomplete-input__input-field", attrs: { id: t.id, "is-active": t.isActiveInt, label: t.label, "show-label": t.showLabel, placeholder: t.placeholder, required: t.required, invalid: t.invalid, "error-message": t.errorMessage, "show-error-icon": t.showErrorIcon, "use-form-field-styling": t.useFormFieldStyling, "show-input-border": t.showInputBorder, clearable: t.clearable, loadable: t.loadable, "is-loading": t.isLoading, language: t.language, disabled: t.disabled, "drop-down-list-id": `${t.id}-list-identifier`, "linked-list-option": t.activeOption ? t.activeOption[t.identifierPropertyName] : null, "assistive-text": {
    loaderActive: t.assistiveText.loaderActive
  } }, on: { "update:isActive": function(i) {
    t.isActiveInt = i;
  }, "update:is-active": function(i) {
    t.isActiveInt = i;
  }, keydown: [function(i) {
    return !i.type.indexOf("key") && t._k(i.keyCode, "enter", 13, i.key, "Enter") ? null : (i.preventDefault(), t.onEnter.apply(null, arguments));
  }, function(i) {
    return !i.type.indexOf("key") && t._k(i.keyCode, "up", 38, i.key, ["Up", "ArrowUp"]) && t._k(i.keyCode, "down", 40, i.key, ["Down", "ArrowDown"]) ? null : (i.preventDefault(), t.onArrowKey.apply(null, arguments));
  }, t.onKeydown] }, scopedSlots: t._u([{ key: "below-input", fn: function() {
    return [t.isActiveInt ? n("BaseDropDownList", { staticClass: "base-autocomplete-input__drop-down", attrs: { "drop-down-options": t.filteredListInt, "active-option": t.activeOption, "identifier-property-name": t.identifierPropertyName, "label-property-name": t.labelPropertyName, "list-id": `${t.id}-list-identifier`, language: t.language, "drop-down-no-options-info": t.dropDownNoOptionsInfo, "use-highlight-string-match": t.highlightStringMatch, "highlight-string-tags": t.highlightStringTags, "highlight-string-match": t.inputInt }, on: { "update:activeOption": function(i) {
      t.activeOption = i;
    }, "update:active-option": function(i) {
      t.activeOption = i;
    }, "update:selected-option": t.selectOption }, nativeOn: { click: function(i) {
      i.stopPropagation();
    }, touchstart: function(i) {
      i.stopPropagation();
    } }, scopedSlots: t._u([{ key: "option", fn: function({ option: i }) {
      return [t._t("drop-down-entry", null, { item: i })];
    } }], null, !0) }) : t._e()];
  }, proxy: !0 }, { key: "label-addition", fn: function() {
    return [t._t("label-addition")];
  }, proxy: !0 }, { key: "pre-input-field", fn: function() {
    return [t._t("pre-input-field")];
  }, proxy: !0 }, { key: "input-field-addition-before", fn: function() {
    return [t._t("input-field-addition-before")];
  }, proxy: !0 }, { key: "input-field-inline-before", fn: function() {
    return [t._t("input-field-inline-before")];
  }, proxy: !0 }, { key: "input-field-addition-after", fn: function() {
    return [t._t("input-field-addition-after")];
  }, proxy: !0 }, { key: "post-input-field", fn: function() {
    return [t._t("post-input-field")];
  }, proxy: !0 }, { key: "error-icon", fn: function() {
    return [t._t("error-icon")];
  }, proxy: !0 }, { key: "remove-icon", fn: function() {
    return [t._t("remove-icon")];
  }, proxy: !0 }], null, !0), model: { value: t.inputInt, callback: function(i) {
    t.inputInt = i;
  }, expression: "inputInt" } }, t.inputListeners))], 1);
}, c = [], h = /* @__PURE__ */ p(
  d,
  f,
  c,
  !1,
  null,
  "105b1cf0",
  null,
  null
);
const A = h.exports;
export {
  A as default
};
//# sourceMappingURL=BaseAutocompleteInput.vue.es.js.map
